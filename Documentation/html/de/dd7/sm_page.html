<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FP-SNS-DATALOG2: Sensor Manager</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FP-SNS-DATALOG2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Sensor Manager</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#design_sm">Design</a></li>
<li class="level1"><a href="#layer_sm">3-layer architecture</a></li>
<li class="level1"><a href="#dataflow_sm">Sensor Data flow</a><ul><li class="level2"><a href="#eventlistener_sm">Event/Listener design pattern</a></li>
<li class="level2"><a href="#interface_sm">Interfaces</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro_sm"></a>
Introduction</h1>
<p>SensorManager is an eLooM-based application-level module that interfaces sensors and offers their data to other application modules. It is implemented as an acquisition engine that:</p><ul>
<li>orchestrates multiple task accesses to sensor bus</li>
<li>defines interfaces to avoid implementation dependencies</li>
<li>dispatches events to notify when a certain amount of data is available</li>
</ul>
<h1><a class="anchor" id="design_sm"></a>
Design</h1>
<p>As for any eLooM-based module, the SensorManager is packed into a folder. It is totally self-contained, so it is independent from other modules and it can be added to your custom FW application by just dragging and dropping the needed folder. Since modules are eLooM based application, the folder structure stands on eLooM layered architecture. Each FW modules implements concretely or extends services, classes and objects made available by the eLooM framework. More specifically, here you can find:</p><ul>
<li>Drivers, objects that implements the base interface for any low-level subsystem that can be used into the FW module (i.e.: I2C, DFSDM).</li>
<li>Events, objects that handle information about something that happened in the system at a given moment. These files implement the event and source/listener design patterns.</li>
<li>Services, any kind of further utilities for the FW module.</li>
</ul>
<p>Into the root folder of the FW module, there are the application objects, where the features are implemented. These files are always built on top of eLooM interfaces, so that they can be OS-based tasks, managed tasks, drivers or IOdrivers.</p>
<h1><a class="anchor" id="folder_sm"></a>
Folder structure</h1>
<p>The SensorManager folder contains the following kind of files:</p><ul>
<li>Communication: managed tasks and interfaces that implements the bus peripheral communication. The supported peripherals are:<ul>
<li>I2C</li>
<li>SPI</li>
<li>MDF</li>
</ul>
</li>
<li>Sensors: managed tasks and interfaces that implements the single sensor threads. The supported sensors are:<ul>
<li>IIS2DLPC</li>
<li>IIS2ICLX</li>
<li>IIS2MDC</li>
<li>IIS3DWB</li>
<li>ILPS22QS</li>
<li>IMP23ABSU</li>
<li>IMP34DT05</li>
<li>ISM330DHCX</li>
<li>ISM330IS</li>
<li>LIS2DU12</li>
<li>LIS2MDL</li>
<li>LPS22DF</li>
<li>LPS22HH</li>
<li>LSM6DSV16X</li>
<li>MP23DB01HP</li>
<li>STTS22H</li>
</ul>
</li>
<li>Utilities: SensorManager and eLooM macros, services and utilities</li>
</ul>
<p><a class="anchor" id="fig1"></a></p><div class="image">
<img src="../../SensorManager_folder.jpg" alt="" width="300px"/>
<div class="caption">
Fig.1 - SensorManager files</div></div>
<h1><a class="anchor" id="layer_sm"></a>
3-layer architecture</h1>
<p>SensorManager module is based on a three-layer architecture. There is the Application Layer, where we can find all the SM Tasks.</p>
<p><a class="el" href="../../de/dd7/sm_page.html#fig2">Fig.2</a> displays an example with the ISM330DHCX Task, in charge to manage the related sensor.</p>
<p><a class="anchor" id="fig2"></a></p><div class="image">
<img src="../../eLooM_3_layer.png" alt=""/>
<div class="caption">
Fig.2 - eLooM 3-level structure</div></div>
<p>The SPIBusTask in charge to schedule and process the SPI request comes from all the sensor tasks. Under the Application layer we find the Service Layer, this layer is like a bridge between the tasks and the low level api typically. In this case we find the PID (Platform Independent Driver) of the component, that implements the protocol used to communicate with the component itself. Last layer is the Low-Level API, in this layer there are the objects in charge to communicate with the component through a peripheral. In the Low-Level API the SM application takes advantage of the configuration file generated from CubeMX.</p>
<p>Resuming the entire process:</p><ul>
<li>SPIBusTask schedules the requests and processes them via the SPIMasterDriver</li>
<li>The SensorTask implements its own SPIBusIF</li>
<li>The SPIBusIF is used by SPIBusTask</li>
<li>One change to one layer doesnâ€™t affect the other layers.</li>
</ul>
<p>Note that the Connector is the same type of the stmdev_ctx_t used in the ST PID sensor driver. This allows us to reuse that driver (in the eLooM framework the PID is not a driver, but a service, while the low-level API is the I2C/SPI master driver) to control the sensor.</p>
<h1><a class="anchor" id="dataflow_sm"></a>
Sensor Data flow</h1>
<p>On top of the PID driver already provided bt ST, SensorManager provides a set of interfaces and abstract classes as displayed in the following Figure.</p>
<p><a class="el" href="../../de/dd7/sm_page.html#fig3">Fig.3</a> displays how bus interfaces are implemented in the SensorManager.</p>
<p><a class="anchor" id="fig3"></a></p><div class="image">
<img src="../../bus.png" alt=""/>
<div class="caption">
Fig.3 - Bus Interface UML</div></div>
<h2><a class="anchor" id="eventlistener_sm"></a>
Event/Listener design pattern</h2>
<p>This architecture allows a Managed task, like the SPIBusTask, to export an easy-to-use API to connect and disconnect sensor objects at application level. The following code shows how to allocate a Sensor (IIS3DWB) and a Bus (SPI3) and how to connect them so that the application knows that a specific sensor can be accessed through a specific bus.</p>
<pre class="fragment">   // Allocate the Tasks objects
  sSPI3BusObj = SPIBusTaskAlloc(&amp;MX_SPI3InitParams);
  sIIS3DWBObj = IIS3DWBTaskAlloc();

  // Add Tasks to the Application Context
  res = ACAddTask(pAppContext, (AManagedTask*)sSPI3BusObj);
  res = ACAddTask(pAppContext, (AManagedTask*)sIIS3DWBObj);

  // Connect the Sensor task to the Bus
  SPIBusTaskConnectDevice((SPIBusTask*)sSPI3BusObj, IIS3DWBTaskGetSensorIF((IIS3DWBTask*)sIIS3DWBObj));
</pre><p>Each sensor is handled by a dedicated task at application level to manage data acquisition from the specific sensor. When a read/write transaction is necessary, the task appends a message to the specific bus message queue and waits for an OS semaphore to be released. At this point, since the bus message queue is no longer empty, the bus task wakes up and initiates the actual transaction (read/write) on the bus using DMA and it enters in a blocked state waiting for the transaction to be completed. In this scenario, data acquisition is handled by the hardware (BUS + DMA) without any intervention of the core. When the data transaction is completed, the DMA throws an interrupt that wakes up the bus task, which in turn wakes up the task which originally made the request.</p>
<h2><a class="anchor" id="interface_sm"></a>
Interfaces</h2>
<p>Each sensor tasks must implement the interfaces required from the SensorManager. The interfaces abstract a common behavior, so to obtain:</p><ul>
<li>Interface segregation principle (many client-specific interfaces are better than one general-purpose interface).</li>
<li>Easy to extend. You are free to add a new sensor to the Sensor Manager by just implementing the required interfaces.</li>
<li>A barrier preventing coupling to dependencies.</li>
</ul>
<p><a class="anchor" id="fig4"></a></p><div class="image">
<img src="../../interfaces.png" alt=""/>
<div class="caption">
Fig.4 - Interfaces implemented in SensorManager</div></div>
<p>We have two kinds of interfaces involved:</p><ul>
<li>The ISourceObservable interface is dedicated for which wants just to be an observer of the sensor tasks, which is interested to read information from the sensor. Basically, the interfaces exposes the Event Source interface of the sensor to the observer.</li>
<li>The ISensor extends the first one adding more features, in this case allow the user Task to control the sensor. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 11 2023 15:25:02 for FP-SNS-DATALOG2 by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
