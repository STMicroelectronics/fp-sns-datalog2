<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FP-SNS-DATALOG2: Middlewares/ST/BlueNRG-2/includes/bluenrg1_gap_aci.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FP-SNS-DATALOG2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_18d39804a75e1fcb1deadc3198692f5c.html">Middlewares</a></li><li class="navelem"><a class="el" href="dir_0d4e7aba86dbe6d2cd1e6eea82503c8e.html">ST</a></li><li class="navelem"><a class="el" href="dir_2e42254e94167f8ce9b060f4cb1c5ee1.html">BlueNRG-2</a></li><li class="navelem"><a class="el" href="dir_10dc0f704103e0abe478ca72540dee30.html">includes</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bluenrg1_gap_aci.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for external uC - BlueNRG-x in network coprocessor mode (gap_aci) Autogenerated files, do not edit!!  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="bluenrg1__types_8h_source.html">bluenrg1_types.h</a>&quot;</code><br />
</div>
<p><a href="bluenrg1__gap__aci_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_whitelist___entry__t__s.html">Whitelist_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_whitelist___identity___entry__t__s.html">Whitelist_Identity_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaff9cbd2d0a48039f2421db05f457bf0d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_whitelist___entry__t__s.html">Whitelist_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gaff9cbd2d0a48039f2421db05f457bf0d">Whitelist_Entry_t</a></td></tr>
<tr class="separator:gaff9cbd2d0a48039f2421db05f457bf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160729332d2312d81c6e81c0f3fb44bb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga160729332d2312d81c6e81c0f3fb44bb">Bonded_Device_Entry_t</a></td></tr>
<tr class="separator:ga160729332d2312d81c6e81c0f3fb44bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffeede0f2a7aab6ac6d59f2e08a35fda"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_whitelist___identity___entry__t__s.html">Whitelist_Identity_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gaffeede0f2a7aab6ac6d59f2e08a35fda">Whitelist_Identity_Entry_t</a></td></tr>
<tr class="separator:gaffeede0f2a7aab6ac6d59f2e08a35fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa04d32f0009ee0df4fbe4643c4e593a5"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gaa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> (void)</td></tr>
<tr class="memdesc:gaa04d32f0009ee0df4fbe4643c4e593a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in non-discoverable mode. This command disables the LL advertising.  <a href="group___g_a_p___functions.html#gaa04d32f0009ee0df4fbe4643c4e593a5">More...</a><br /></td></tr>
<tr class="separator:gaa04d32f0009ee0df4fbe4643c4e593a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1472bbcc86d4f3b87615733a0c22bdd9"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga1472bbcc86d4f3b87615733a0c22bdd9">aci_gap_set_limited_discoverable</a> (uint8_t Advertising_Type, uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Own_Address_Type, uint8_t Advertising_Filter_Policy, uint8_t Local_Name_Length, uint8_t Local_Name[], uint8_t Service_Uuid_length, uint8_t Service_Uuid_List[], uint16_t Slave_Conn_Interval_Min, uint16_t Slave_Conn_Interval_Max)</td></tr>
<tr class="memdesc:ga1472bbcc86d4f3b87615733a0c22bdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in limited discoverable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.2.3). The device will be discoverable for maximum period of TGAP (lim_adv_timeout) = 180 seconds (from errata). The advertising can be disabled at any time by issuing <a class="el" href="group___g_a_p___functions.html#gaa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> command. The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP will use default values for adv intervals for limited discoverable mode (250 ms and 500 ms respectively). To allow a fast connection, the host can set Local_Name, Service_Uuid_List, Slave_Conn_Interval_Min and Slave_Conn_Interval_Max. If provided, these data will be inserted into the advertising packet payload as AD data. These parameters are optional in this command. These values can be set in advertised data using GAP_Update_Adv_Data command separately. The total size of data in advertising packet cannot exceed 31 bytes. With this command, the BLE Stack will also add automatically the following standard AD types: - AD Flags - Power Level When advertising timeout happens (i.e. limited discovery period has elapsed), controller generates <a class="el" href="group___a_c_i___g_a_p__events.html#ga2b2959f4046febc21171af4788a40da0">aci_gap_limited_discoverable_event</a> event.  <a href="group___g_a_p___functions.html#ga1472bbcc86d4f3b87615733a0c22bdd9">More...</a><br /></td></tr>
<tr class="separator:ga1472bbcc86d4f3b87615733a0c22bdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1795e7e98ac1e1165238b143a06dd3"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga6b1795e7e98ac1e1165238b143a06dd3">aci_gap_set_discoverable</a> (uint8_t Advertising_Type, uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Own_Address_Type, uint8_t Advertising_Filter_Policy, uint8_t Local_Name_Length, uint8_t Local_Name[], uint8_t Service_Uuid_length, uint8_t Service_Uuid_List[], uint16_t Slave_Conn_Interval_Min, uint16_t Slave_Conn_Interval_Max)</td></tr>
<tr class="memdesc:ga6b1795e7e98ac1e1165238b143a06dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in general discoverable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.2.4). The device will be discoverable until the host issues the <a class="el" href="group___g_a_p___functions.html#gaa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> command. The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP uses the default values for adv intervals for general discoverable mode. When using connectable undirected advertising events: - Adv_Interval_Min = 30 ms - Adv_Interval_Max = 60 ms When using non- connectable advertising events or scannable undirected advertising events: - Adv_Interval_Min = 100 ms - Adv_Interval_Max = 150 ms Host can set the Local Name, a Service UUID list and the Slave Connection Interval Range. If provided, these data will be inserted into the advertising packet payload as AD data. These parameters are optional in this command. These values can be also set using <a class="el" href="group___g_a_p___functions.html#gaff0e0210b67c4fed57edc3e228365a8c" title="This command can be used to update the advertising data for a particular AD type. If the AD type spec...">aci_gap_update_adv_data()</a> separately. The total size of data in advertising packet cannot exceed 31 bytes. With this command, the BLE Stack will also add automatically the following standard AD types: - AD Flags - TX Power Level.  <a href="group___g_a_p___functions.html#ga6b1795e7e98ac1e1165238b143a06dd3">More...</a><br /></td></tr>
<tr class="separator:ga6b1795e7e98ac1e1165238b143a06dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e333853ba4eb3b6e94f2acdf7597cce"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga8e333853ba4eb3b6e94f2acdf7597cce">aci_gap_set_direct_connectable</a> (uint8_t Own_Address_Type, uint8_t Directed_Advertising_Type, uint8_t Direct_Address_Type, uint8_t Direct_Address[6], uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max)</td></tr>
<tr class="memdesc:ga8e333853ba4eb3b6e94f2acdf7597cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device in direct connectable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.3.3). Device uses direct connectable mode to advertise using High Duty cycle advertisement events or Low Duty cycle advertisement events and the address as either what is specified in the Own Address Type parameter. The command specifies the type of the advertising used. If the privacy is enabled, the Type parameter in reconnection address is used for advertising, otherwise the address of the type specified in OwnAddrType is used. The device will be in directed connectable mode only for 1.28 seconds. If no connection is established within this duration, the device enters non discoverable mode and advertising will have to be again enabled explicitly. The controller generates a <a class="el" href="group___h_c_i___l_e__meta__events.html#gaca8160d0515ff237c4c8f4db8e45c77a">hci_le_connection_complete_event</a> event with the status set to 0x3C (Directed Advertising Timeout) if the connection was not established and 0x00 if the connection was successfully established. If Host privacy (i.e. privacy 1.1) is enabled this command returns BLE_STATUS_INVALID_PARAMS.  <a href="group___g_a_p___functions.html#ga8e333853ba4eb3b6e94f2acdf7597cce">More...</a><br /></td></tr>
<tr class="separator:ga8e333853ba4eb3b6e94f2acdf7597cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e39b68644bdc0149ea9270427715cd"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gaf7e39b68644bdc0149ea9270427715cd">aci_gap_set_io_capability</a> (uint8_t IO_Capability)</td></tr>
<tr class="memdesc:gaf7e39b68644bdc0149ea9270427715cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IO capabilities of the device. This command has to be given only when the device is not in a connected state.  <a href="group___g_a_p___functions.html#gaf7e39b68644bdc0149ea9270427715cd">More...</a><br /></td></tr>
<tr class="separator:gaf7e39b68644bdc0149ea9270427715cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2bee68b2757f1aa0a2034a90b8d2f61"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gad2bee68b2757f1aa0a2034a90b8d2f61">aci_gap_set_authentication_requirement</a> (uint8_t Bonding_Mode, uint8_t MITM_Mode, uint8_t SC_Support, uint8_t KeyPress_Notification_Support, uint8_t Min_Encryption_Key_Size, uint8_t Max_Encryption_Key_Size, uint8_t Use_Fixed_Pin, uint32_t Fixed_Pin, uint8_t Identity_Address_Type)</td></tr>
<tr class="memdesc:gad2bee68b2757f1aa0a2034a90b8d2f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authentication requirements for the device. This command has to be given only when the device is not in a connected state.  <a href="group___g_a_p___functions.html#gad2bee68b2757f1aa0a2034a90b8d2f61">More...</a><br /></td></tr>
<tr class="separator:gad2bee68b2757f1aa0a2034a90b8d2f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafb71362ebef8fec2dc0c10a05c92e0"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gacafb71362ebef8fec2dc0c10a05c92e0">aci_gap_set_authorization_requirement</a> (uint16_t Connection_Handle, uint8_t Authorization_Enable)</td></tr>
<tr class="memdesc:gacafb71362ebef8fec2dc0c10a05c92e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authorization requirements of the device. This command has to be given when connected to a device if authorization is required to access services which require authorization.  <a href="group___g_a_p___functions.html#gacafb71362ebef8fec2dc0c10a05c92e0">More...</a><br /></td></tr>
<tr class="separator:gacafb71362ebef8fec2dc0c10a05c92e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5acbb617b13a0880a76d8f063153e6f"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gab5acbb617b13a0880a76d8f063153e6f">aci_gap_pass_key_resp</a> (uint16_t Connection_Handle, uint32_t Pass_Key)</td></tr>
<tr class="memdesc:gab5acbb617b13a0880a76d8f063153e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command should be send by the host in response to <a class="el" href="group___a_c_i___g_a_p__events.html#ga4820d33fd0fa8fec40c725b78b02c913">aci_gap_pass_key_req_event</a> event. The command parameter contains the pass key which will be used during the pairing process.  <a href="group___g_a_p___functions.html#gab5acbb617b13a0880a76d8f063153e6f">More...</a><br /></td></tr>
<tr class="separator:gab5acbb617b13a0880a76d8f063153e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f00c7d04afae40779a36b27684f840"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga14f00c7d04afae40779a36b27684f840">aci_gap_authorization_resp</a> (uint16_t Connection_Handle, uint8_t Authorize)</td></tr>
<tr class="memdesc:ga14f00c7d04afae40779a36b27684f840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authorize a device to access attributes. This command should be send by the host in response to <a class="el" href="group___a_c_i___g_a_p__events.html#ga6d4fcbf921e882f089829f5ed7c63123">aci_gap_authorization_req_event</a> event.  <a href="group___g_a_p___functions.html#ga14f00c7d04afae40779a36b27684f840">More...</a><br /></td></tr>
<tr class="separator:ga14f00c7d04afae40779a36b27684f840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8135485b2fce4116c825e226b43046"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gafc8135485b2fce4116c825e226b43046">aci_gap_init</a> (uint8_t Role, uint8_t privacy_enabled, uint8_t device_name_char_len, uint16_t *Service_Handle, uint16_t *Dev_Name_Char_Handle, uint16_t *Appearance_Char_Handle)</td></tr>
<tr class="memdesc:gafc8135485b2fce4116c825e226b43046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristics will also be added: - Device Name - Appearance - Peripheral Preferred Connection Parameters (peripheral role only) WARNING: A section of the Flash memory (pointed by stored_device_id_data_p) is used by this procedure. When this section is empty, data are written inside. This normally happens once during the lifetime of the device, when the command is executed for the first time (or every time it is called after that section has been erased). Do not power off the device while this function is writing into Flash memory. If the functions returns FLASH_WRITE_FAILED, it means that the flash area pointed by stored_device_id_data_p is corrupted (probably due to a power loss during the first call to <a class="el" href="group___g_a_p___functions.html#gafc8135485b2fce4116c825e226b43046" title="Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristic...">aci_gap_init()</a>). To fix the problem, that flash area has to be erased, so that the <a class="el" href="group___g_a_p___functions.html#gafc8135485b2fce4116c825e226b43046" title="Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristic...">aci_gap_init()</a> can reinitialize it correctly.  <a href="group___g_a_p___functions.html#gafc8135485b2fce4116c825e226b43046">More...</a><br /></td></tr>
<tr class="separator:gafc8135485b2fce4116c825e226b43046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7581dbd49beb7d43c2c28a21bd352e6"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gaf7581dbd49beb7d43c2c28a21bd352e6">aci_gap_set_non_connectable</a> (uint8_t Advertising_Event_Type, uint8_t Own_Address_Type)</td></tr>
<tr class="memdesc:gaf7581dbd49beb7d43c2c28a21bd352e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device into non connectable mode. This mode does not support connection. The privacy setting done in the <a class="el" href="bluenrg__lp__gap__aci_8h.html#ab9fbdf6ff1531cfd0ef106e7c068f8ca">aci_gap_init</a> command plays a role in deciding the valid parameters for this command. Advertiser filter policy is internally set to 0x00.  <a href="group___g_a_p___functions.html#gaf7581dbd49beb7d43c2c28a21bd352e6">More...</a><br /></td></tr>
<tr class="separator:gaf7581dbd49beb7d43c2c28a21bd352e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2212b78100bc3c64553036247fa612bb"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga2212b78100bc3c64553036247fa612bb">aci_gap_set_undirected_connectable</a> (uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Own_Address_Type, uint8_t Adv_Filter_Policy)</td></tr>
<tr class="memdesc:ga2212b78100bc3c64553036247fa612bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device into undirected connectable mode. If privacy is enabled in the device, a resolvable private address is generated and used as the advertiser's address. If not, the address of the type specified in own_addr_type is used for advertising.  <a href="group___g_a_p___functions.html#ga2212b78100bc3c64553036247fa612bb">More...</a><br /></td></tr>
<tr class="separator:ga2212b78100bc3c64553036247fa612bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80162feee4f10fbfce5099ba0a7a61ba"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga80162feee4f10fbfce5099ba0a7a61ba">aci_gap_slave_security_req</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga80162feee4f10fbfce5099ba0a7a61ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a slave security request to the master. This command has to be issued to notify the master of the security requirements of the slave. The master may encrypt the link, initiate the pairing procedure, or reject the request.  <a href="group___g_a_p___functions.html#ga80162feee4f10fbfce5099ba0a7a61ba">More...</a><br /></td></tr>
<tr class="separator:ga80162feee4f10fbfce5099ba0a7a61ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff0e0210b67c4fed57edc3e228365a8c"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gaff0e0210b67c4fed57edc3e228365a8c">aci_gap_update_adv_data</a> (uint8_t AdvDataLen, uint8_t AdvData[])</td></tr>
<tr class="memdesc:gaff0e0210b67c4fed57edc3e228365a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to update the advertising data for a particular AD type. If the AD type specified does not exist, then it is added to the advertising data. If the overall advertising data length is more than 31 octets after the update, then the command is rejected and the old data is retained.  <a href="group___g_a_p___functions.html#gaff0e0210b67c4fed57edc3e228365a8c">More...</a><br /></td></tr>
<tr class="separator:gaff0e0210b67c4fed57edc3e228365a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25c52a344740f51d8818182e5f4ba2c0"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga25c52a344740f51d8818182e5f4ba2c0">aci_gap_delete_ad_type</a> (uint8_t ADType)</td></tr>
<tr class="memdesc:ga25c52a344740f51d8818182e5f4ba2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to delete the specified AD type from the advertisement data if present.  <a href="group___g_a_p___functions.html#ga25c52a344740f51d8818182e5f4ba2c0">More...</a><br /></td></tr>
<tr class="separator:ga25c52a344740f51d8818182e5f4ba2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cec916e46fb9e000b119f70d645f5fa"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga1cec916e46fb9e000b119f70d645f5fa">aci_gap_get_security_level</a> (uint16_t Connection_Handle, uint8_t *Security_Mode, uint8_t *Security_Level)</td></tr>
<tr class="memdesc:ga1cec916e46fb9e000b119f70d645f5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to get the current security settings of the device.  <a href="group___g_a_p___functions.html#ga1cec916e46fb9e000b119f70d645f5fa">More...</a><br /></td></tr>
<tr class="separator:ga1cec916e46fb9e000b119f70d645f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d12352d4290eab988acdc90e3da93c"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gad4d12352d4290eab988acdc90e3da93c">aci_gap_set_event_mask</a> (uint16_t GAP_Evt_Mask)</td></tr>
<tr class="memdesc:gad4d12352d4290eab988acdc90e3da93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It allows masking events from the GAP. The default configuration is all the events masked.  <a href="group___g_a_p___functions.html#gad4d12352d4290eab988acdc90e3da93c">More...</a><br /></td></tr>
<tr class="separator:gad4d12352d4290eab988acdc90e3da93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcca966aeb617fb6c63d6bc400a9037b"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gafcca966aeb617fb6c63d6bc400a9037b">aci_gap_configure_whitelist</a> (void)</td></tr>
<tr class="memdesc:gafcca966aeb617fb6c63d6bc400a9037b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add addresses of bonded devices into the controller's whitelist. The command will return an error if there are no devices in the database or if it was unable to add the device into the whitelist.  <a href="group___g_a_p___functions.html#gafcca966aeb617fb6c63d6bc400a9037b">More...</a><br /></td></tr>
<tr class="separator:gafcca966aeb617fb6c63d6bc400a9037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1b1aca7489a846f3aaa25cdb9db180"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a> (uint16_t Connection_Handle, uint8_t Reason)</td></tr>
<tr class="memdesc:ga7c1b1aca7489a846f3aaa25cdb9db180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command the controller to terminate the connection. A <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event will be generated when the link is disconnected. It is important to leave an 100 ms blank window before sending any new command (including system hardware reset), since immediately after <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event, system could save important information in non volatile memory.  <a href="group___g_a_p___functions.html#ga7c1b1aca7489a846f3aaa25cdb9db180">More...</a><br /></td></tr>
<tr class="separator:ga7c1b1aca7489a846f3aaa25cdb9db180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1909183f16d7de9676a54bab51838569"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga1909183f16d7de9676a54bab51838569">aci_gap_clear_security_db</a> (void)</td></tr>
<tr class="memdesc:ga1909183f16d7de9676a54bab51838569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the security database. All the devices in the security database will be removed.  <a href="group___g_a_p___functions.html#ga1909183f16d7de9676a54bab51838569">More...</a><br /></td></tr>
<tr class="separator:ga1909183f16d7de9676a54bab51838569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f91fc19683eb9f6ed8d217648b0c82"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga76f91fc19683eb9f6ed8d217648b0c82">aci_gap_allow_rebond</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga76f91fc19683eb9f6ed8d217648b0c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the security manager to complete the pairing procedure and re- bond with the master. This command should be given by the application when it receives the ACI_GAP_BOND_LOST_EVENT if it wants the re- bonding to happen successfully. If this command is not given on receiving the event, the bonding procedure will timeout.  <a href="group___g_a_p___functions.html#ga76f91fc19683eb9f6ed8d217648b0c82">More...</a><br /></td></tr>
<tr class="separator:ga76f91fc19683eb9f6ed8d217648b0c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96490c0e5a8d2f3c345b4992e477e403"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga96490c0e5a8d2f3c345b4992e477e403">aci_gap_start_limited_discovery_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:ga96490c0e5a8d2f3c345b4992e477e403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the limited discovery procedure. The controller is commanded to start active scanning. When this procedure is started, only the devices in limited discoverable mode are returned to the upper layers. The procedure is terminated when either the upper layers issue a command to terminate the procedure by issuing the command <a class="el" href="group___g_a_p___functions.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x01 or a timeout happens. When the procedure is terminated due to any of the above reasons, <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is returned with the procedure code set to 0x01. The device found when the procedure is ongoing is returned to the upper layers through the event <a class="el" href="group___h_c_i___l_e__meta__events.html#ga07c3c6ecbaf3113c2161d825e9e03941">hci_le_advertising_report_event</a>.  <a href="group___g_a_p___functions.html#ga96490c0e5a8d2f3c345b4992e477e403">More...</a><br /></td></tr>
<tr class="separator:ga96490c0e5a8d2f3c345b4992e477e403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed8d0c8a1a23ca240dee0fb895d31df"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gaaed8d0c8a1a23ca240dee0fb895d31df">aci_gap_start_general_discovery_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:gaaed8d0c8a1a23ca240dee0fb895d31df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the general discovery procedure. The controller is commanded to start active scanning. The procedure is terminated when either the upper layers issue a command to terminate the procedure by issuing the command <a class="el" href="group___g_a_p___functions.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x02 or a timeout happens. When the procedure is terminated due to any of the above reasons, <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is returned with the procedure code set to 0x02. The device found when the procedure is ongoing is returned to <a class="el" href="group___h_c_i___l_e__meta__events.html#ga07c3c6ecbaf3113c2161d825e9e03941">hci_le_advertising_report_event</a>.  <a href="group___g_a_p___functions.html#gaaed8d0c8a1a23ca240dee0fb895d31df">More...</a><br /></td></tr>
<tr class="separator:gaaed8d0c8a1a23ca240dee0fb895d31df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7035c09d3063ca239c4ada8172dc25e"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gac7035c09d3063ca239c4ada8172dc25e">aci_gap_start_name_discovery_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:gac7035c09d3063ca239c4ada8172dc25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the name discovery procedure. A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and process connectable advertising packets only
       for the specified device". Once a connection is established, GATT procedure is started to read the device name characteristic. When the read is completed (successfully or unsuccessfully), a <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is given to the upper layer. The event also contains the name of the device if the device name was read successfully.  <a href="group___g_a_p___functions.html#gac7035c09d3063ca239c4ada8172dc25e">More...</a><br /></td></tr>
<tr class="separator:gac7035c09d3063ca239c4ada8172dc25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac95e16e25fa07dfc206eeafa1ab33c38"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gac95e16e25fa07dfc206eeafa1ab33c38">aci_gap_start_auto_connection_establish_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length, uint8_t Num_of_Whitelist_Entries, <a class="el" href="group___g_a_p___functions.html#gaff9cbd2d0a48039f2421db05f457bf0d">Whitelist_Entry_t</a> Whitelist_Entry[])</td></tr>
<tr class="memdesc:gac95e16e25fa07dfc206eeafa1ab33c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the auto connection establishment procedure. The devices specified are added to the white list of the controller and a LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "use whitelist to determine which
       advertiser to connect to". When a command is issued to terminate the procedure by upper layer, a LE_Create_Connection_Cancel call will be made to the controller by GAP. The procedure is terminated when either a connection is successfully established with one of the specified devices in the white list or the procedure is explicitly terminated by issuing the command <a class="el" href="group___g_a_p___functions.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x08. A <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is returned with the procedure code set to 0x08. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___functions.html#gac95e16e25fa07dfc206eeafa1ab33c38">More...</a><br /></td></tr>
<tr class="separator:gac95e16e25fa07dfc206eeafa1ab33c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e87838aa189db795d10a3c4f8e7b87"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga51e87838aa189db795d10a3c4f8e7b87">aci_gap_start_general_connection_establish_proc</a> (uint8_t LE_Scan_Type, uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Scanning_Filter_Policy, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:ga51e87838aa189db795d10a3c4f8e7b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a general connection establishment procedure. The host enables scanning in the controller with the scanner filter policy set to "accept all advertising packets" and from the scanning results, all the devices are sent to the upper layer using the event LE_Advertising_Report. The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a class="el" href="bluenrg__lp__gap__aci_8h.html#aeb9221c71a4a2b2e418f0968eaa43017">aci_gap_create_connection</a>. If privacy is enabled, then either a private resolvable address or a non resolvable address, based on the address type specified in the command is set as the scanner address but the gap create connection always uses a private resolvable address if the general connection establishment procedure is active. The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a class="el" href="group___g_a_p___functions.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x10. On completion of the procedure a <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is generated with the procedure code set to 0x10. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___functions.html#ga51e87838aa189db795d10a3c4f8e7b87">More...</a><br /></td></tr>
<tr class="separator:ga51e87838aa189db795d10a3c4f8e7b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6a383c19db7453b5d50e729b01fe6bc"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gab6a383c19db7453b5d50e729b01fe6bc">aci_gap_start_selective_connection_establish_proc</a> (uint8_t LE_Scan_Type, uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Scanning_Filter_Policy, uint8_t Filter_Duplicates, uint8_t Num_of_Whitelist_Entries, <a class="el" href="group___g_a_p___functions.html#gaff9cbd2d0a48039f2421db05f457bf0d">Whitelist_Entry_t</a> Whitelist_Entry[])</td></tr>
<tr class="memdesc:gab6a383c19db7453b5d50e729b01fe6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a selective connection establishment procedure. The GAP adds the specified device addresses into white list and enables scanning in the controller with the scanner filter policy set to "accept packets only
       from devices in whitelist". All the devices found are sent to the upper layer by the event <a class="el" href="group___h_c_i___l_e__meta__events.html#ga07c3c6ecbaf3113c2161d825e9e03941">hci_le_advertising_report_event</a>. The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a class="el" href="bluenrg__lp__gap__aci_8h.html#aeb9221c71a4a2b2e418f0968eaa43017">aci_gap_create_connection</a>. On completion of the procedure a <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is generated with the procedure code set to 0x20. The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a class="el" href="group___g_a_p___functions.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x20. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___functions.html#gab6a383c19db7453b5d50e729b01fe6bc">More...</a><br /></td></tr>
<tr class="separator:gab6a383c19db7453b5d50e729b01fe6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d8d5792788d6cc511c36e1eddabf3d"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gab5d8d5792788d6cc511c36e1eddabf3d">aci_gap_create_connection</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:gab5d8d5792788d6cc511c36e1eddabf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the direct connection establishment procedure. A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and process
       connectable advertising packets only for the specified device". The procedure can be terminated explicitly by the upper layer by issuing the command <a class="el" href="group___g_a_p___functions.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a>. When a command is issued to terminate the procedure by upper layer, a <a class="el" href="bluenrg__lp__hci__le_8h.html#a2b2e81b045a7be0ce2eb41b5b5f7b7c2">hci_le_create_connection_cancel</a> call will be made to the controller by GAP. On termination of the procedure, a <a class="el" href="group___h_c_i___l_e__meta__events.html#gaca8160d0515ff237c4c8f4db8e45c77a">hci_le_connection_complete_event</a> event is returned. The procedure can be explicitly terminated by the upper layer by issuing the command <a class="el" href="group___g_a_p___functions.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure_code set to 0x40. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___functions.html#gab5d8d5792788d6cc511c36e1eddabf3d">More...</a><br /></td></tr>
<tr class="separator:gab5d8d5792788d6cc511c36e1eddabf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39804c69a0cdbd3579b0d3be400665b1"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> (uint8_t Procedure_Code)</td></tr>
<tr class="memdesc:ga39804c69a0cdbd3579b0d3be400665b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the specified GATT procedure. An <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is returned with the procedure code set to the corresponding procedure.  <a href="group___g_a_p___functions.html#ga39804c69a0cdbd3579b0d3be400665b1">More...</a><br /></td></tr>
<tr class="separator:ga39804c69a0cdbd3579b0d3be400665b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga261529d70c766ecd28e9b1464ffb9cce"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga261529d70c766ecd28e9b1464ffb9cce">aci_gap_start_connection_update</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:ga261529d70c766ecd28e9b1464ffb9cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the connection update procedure (only when role is Master). A <a class="el" href="bluenrg__lp__hci__le_8h.html#a0b1c0e2aede814f82bab64c843710eb8">hci_le_connection_update</a> is called. On completion of the procedure, an <a class="el" href="group___h_c_i___l_e__meta__events.html#ga40b3b0abeb955daefb6b3a860d11e0e9">hci_le_connection_update_complete_event</a> event is returned to the upper layer.  <a href="group___g_a_p___functions.html#ga261529d70c766ecd28e9b1464ffb9cce">More...</a><br /></td></tr>
<tr class="separator:ga261529d70c766ecd28e9b1464ffb9cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf52ca818096a284d69d24d3d214f418d"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gaf52ca818096a284d69d24d3d214f418d">aci_gap_send_pairing_req</a> (uint16_t Connection_Handle, uint8_t Force_Rebond)</td></tr>
<tr class="memdesc:gaf52ca818096a284d69d24d3d214f418d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the SM pairing request to start a pairing process. The authentication requirements and IO capabilities should be set before issuing this command using the <a class="el" href="group___g_a_p___functions.html#gaf7e39b68644bdc0149ea9270427715cd">aci_gap_set_io_capability</a> and <a class="el" href="bluenrg__lp__gap__aci_8h.html#a93db72dc4b21ebd8ad8462e85714286a">aci_gap_set_authentication_requirement</a> commands. A <a class="el" href="group___a_c_i___g_a_p__events.html#gadc74352ad6c26c693df1390109c55923">aci_gap_pairing_complete_event</a> event is returned after the pairing process is completed.  <a href="group___g_a_p___functions.html#gaf52ca818096a284d69d24d3d214f418d">More...</a><br /></td></tr>
<tr class="separator:gaf52ca818096a284d69d24d3d214f418d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3d4c1303999072f00bbd0440968165"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga4c3d4c1303999072f00bbd0440968165">aci_gap_resolve_private_addr</a> (uint8_t Address[6], uint8_t Actual_Address[6])</td></tr>
<tr class="memdesc:ga4c3d4c1303999072f00bbd0440968165"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command tries to resolve the address provided with the IRKs present in its database. If the address is resolved successfully with any one of the IRKs present in the database, it returns success and also the corresponding public/static random address stored with the IRK in the database.  <a href="group___g_a_p___functions.html#ga4c3d4c1303999072f00bbd0440968165">More...</a><br /></td></tr>
<tr class="separator:ga4c3d4c1303999072f00bbd0440968165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a02945421ae32a96d2f2d90b99e6ed7"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga4a02945421ae32a96d2f2d90b99e6ed7">aci_gap_set_broadcast_mode</a> (uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Advertising_Type, uint8_t Own_Address_Type, uint8_t Adv_Data_Length, uint8_t Adv_Data[], uint8_t Num_of_Whitelist_Entries, <a class="el" href="group___g_a_p___functions.html#gaff9cbd2d0a48039f2421db05f457bf0d">Whitelist_Entry_t</a> Whitelist_Entry[])</td></tr>
<tr class="memdesc:ga4a02945421ae32a96d2f2d90b99e6ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command puts the device into broadcast mode. A privacy enabled device uses either a resolvable private address or a non-resolvable private address as specified in the Own_Addr_Type parameter of the command.  <a href="group___g_a_p___functions.html#ga4a02945421ae32a96d2f2d90b99e6ed7">More...</a><br /></td></tr>
<tr class="separator:ga4a02945421ae32a96d2f2d90b99e6ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4943804581004fc2ce3e53a27b891918"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga4943804581004fc2ce3e53a27b891918">aci_gap_start_observation_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t LE_Scan_Type, uint8_t Own_Address_Type, uint8_t Filter_Duplicates, uint8_t Scanning_Filter_Policy)</td></tr>
<tr class="memdesc:ga4943804581004fc2ce3e53a27b891918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an Observation procedure, when the device is in Observer Role. The host enables scanning in the controller. The advertising reports are sent to the upper layer using standard LE Advertising Report Event. (See Bluetooth Core v4.1, Vol. 2, part E, Ch. 7.7.65.2, LE Advertising Report Event). If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___functions.html#ga4943804581004fc2ce3e53a27b891918">More...</a><br /></td></tr>
<tr class="separator:ga4943804581004fc2ce3e53a27b891918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae335dd4a298252d5735926e31d762041"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gae335dd4a298252d5735926e31d762041">aci_gap_get_bonded_devices</a> (uint8_t *Num_of_Addresses, <a class="el" href="group___g_a_p___functions.html#ga160729332d2312d81c6e81c0f3fb44bb">Bonded_Device_Entry_t</a> Bonded_Device_Entry[])</td></tr>
<tr class="memdesc:gae335dd4a298252d5735926e31d762041"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command gets the list of the devices which are bonded. It returns the number of addresses and the corresponding address types and values. The maximum number of devices that can be returned is MAX_NUM_BONDED_DEVICES (12).  <a href="group___g_a_p___functions.html#gae335dd4a298252d5735926e31d762041">More...</a><br /></td></tr>
<tr class="separator:gae335dd4a298252d5735926e31d762041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2d88d5dcb1f6dd4f154e29840c96b1"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#gadf2d88d5dcb1f6dd4f154e29840c96b1">aci_gap_is_device_bonded</a> (uint8_t Peer_Address_Type, uint8_t Peer_Address[6])</td></tr>
<tr class="memdesc:gadf2d88d5dcb1f6dd4f154e29840c96b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command finds whether the device, whose address is specified in the command, is bonded. If the device is using a resolvable private address and it has been bonded, then the command will return BLE_STATUS_SUCCESS.  <a href="group___g_a_p___functions.html#gadf2d88d5dcb1f6dd4f154e29840c96b1">More...</a><br /></td></tr>
<tr class="separator:gadf2d88d5dcb1f6dd4f154e29840c96b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ae1db71ecec2ba7f9dd2992185d935"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga53ae1db71ecec2ba7f9dd2992185d935">aci_gap_numeric_comparison_value_confirm_yesno</a> (uint16_t Connection_Handle, uint8_t Confirm_Yes_No)</td></tr>
<tr class="memdesc:ga53ae1db71ecec2ba7f9dd2992185d935"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command allows the User to validate/confirm or not the Numeric Comparison value showed through the ACI_GAP_Numeric_Comparison_Value_Event.  <a href="group___g_a_p___functions.html#ga53ae1db71ecec2ba7f9dd2992185d935">More...</a><br /></td></tr>
<tr class="separator:ga53ae1db71ecec2ba7f9dd2992185d935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e97953f93b91e6a94efe65088733ed"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga22e97953f93b91e6a94efe65088733ed">aci_gap_passkey_input</a> (uint16_t Connection_Handle, uint8_t Input_Type)</td></tr>
<tr class="memdesc:ga22e97953f93b91e6a94efe65088733ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command permits to signal to the Stack the input type detected during Passkey input.  <a href="group___g_a_p___functions.html#ga22e97953f93b91e6a94efe65088733ed">More...</a><br /></td></tr>
<tr class="separator:ga22e97953f93b91e6a94efe65088733ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6d91556b0bc974ff8668befbae3424"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga6c6d91556b0bc974ff8668befbae3424">aci_gap_get_oob_data</a> (uint8_t OOB_Data_Type, uint8_t *Address_Type, uint8_t Address[6], uint8_t *OOB_Data_Len, uint8_t OOB_Data[16])</td></tr>
<tr class="memdesc:ga6c6d91556b0bc974ff8668befbae3424"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is sent by the User to get (i.e. to extract from the Stack) the OOB data generated by the Stack itself. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager to require the local OOB data (hence without user interaction) to be sent via OOB to the remote peer candidate device. The requested OOB data are returned in response to the incoming command. The OOB data are not generated on the fly, but they are already available in the Stack.  <a href="group___g_a_p___functions.html#ga6c6d91556b0bc974ff8668befbae3424">More...</a><br /></td></tr>
<tr class="separator:ga6c6d91556b0bc974ff8668befbae3424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0894787f7dd5af1e4f1a7ae1d3844f77"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga0894787f7dd5af1e4f1a7ae1d3844f77">aci_gap_set_oob_data</a> (uint8_t Device_Type, uint8_t Address_Type, uint8_t Address[6], uint8_t OOB_Data_Type, uint8_t OOB_Data_Len, uint8_t OOB_Data[16])</td></tr>
<tr class="memdesc:ga0894787f7dd5af1e4f1a7ae1d3844f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is sent (by the User) to input the OOB data arrived via OOB communication. It may be sent to set either the OOB Authentication data of the Local device, or the data received via OOB by the Remote peer candidate device. It can be used with OOB_Data_Len set to 0 to generate OOB authentication data for Secure Connections. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager when receiving the OOB data (hence without user interaction). Since the BLE stack v 2.x implementation supports just one entry for the Remote peer candidate list containing the OOB data, at every command invocation the data existing in that entry are overwritten.  <a href="group___g_a_p___functions.html#ga0894787f7dd5af1e4f1a7ae1d3844f77">More...</a><br /></td></tr>
<tr class="separator:ga0894787f7dd5af1e4f1a7ae1d3844f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963958c8154358b7364eaf639f2c4480"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga963958c8154358b7364eaf639f2c4480">aci_gap_add_devices_to_resolving_list</a> (uint8_t Num_of_Resolving_list_Entries, <a class="el" href="group___g_a_p___functions.html#gaffeede0f2a7aab6ac6d59f2e08a35fda">Whitelist_Identity_Entry_t</a> Whitelist_Identity_Entry[], uint8_t Clear_Resolving_List)</td></tr>
<tr class="memdesc:ga963958c8154358b7364eaf639f2c4480"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to add one device to the list of address translations used to resolve Resolvable Private Addresses in the Controller.  <a href="group___g_a_p___functions.html#ga963958c8154358b7364eaf639f2c4480">More...</a><br /></td></tr>
<tr class="separator:ga963958c8154358b7364eaf639f2c4480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e986dc4f7bc786707d4102acc3826ab"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___functions.html#ga5e986dc4f7bc786707d4102acc3826ab">aci_gap_remove_bonded_device</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6])</td></tr>
<tr class="memdesc:ga5e986dc4f7bc786707d4102acc3826ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to remove a specified device from the bonding table.  <a href="group___g_a_p___functions.html#ga5e986dc4f7bc786707d4102acc3826ab">More...</a><br /></td></tr>
<tr class="separator:ga5e986dc4f7bc786707d4102acc3826ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for external uC - BlueNRG-x in network coprocessor mode (gap_aci) Autogenerated files, do not edit!! </p>
<dl class="section author"><dt>Author</dt><dd>AMG - RF Application team </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>Copyright (c) 2020 STMicroelectronics. All rights reserved.</p>
<p>This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component. If no LICENSE file comes with this software, it is provided AS-IS. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 3 2023 17:27:27 for FP-SNS-DATALOG2 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
