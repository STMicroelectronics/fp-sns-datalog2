<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FP-SNS-DATALOG2: Middlewares/ST/BlueNRG-2/hci/bluenrg1_events.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FP-SNS-DATALOG2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_18d39804a75e1fcb1deadc3198692f5c.html">Middlewares</a></li><li class="navelem"><a class="el" href="dir_0d4e7aba86dbe6d2cd1e6eea82503c8e.html">ST</a></li><li class="navelem"><a class="el" href="dir_2e42254e94167f8ce9b060f4cb1c5ee1.html">BlueNRG-2</a></li><li class="navelem"><a class="el" href="dir_c8c007cd6abdfb56f124f6299fabcc47.html">hci</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bluenrg1_events.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Source file for external uC - BlueNRG-x in network coprocessor mode (Event callbacks) Autogenerated files, do not edit!!  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="bluenrg1__events_8h_source.html">bluenrg1_events.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2369482e556142d063d96633a030e8cd"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a2369482e556142d063d96633a030e8cd">hci_disconnection_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a2369482e556142d063d96633a030e8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Disconnection Complete event occurs when a connection is terminated. The status parameter indicates if the disconnection was successful or not. The reason parameter indicates the reason for the disconnection if the disconnection was successful. If the disconnection was not successful, the value of the reason parameter can be ignored by the Host. For example, this can be the case if the Host has issued the Disconnect command and there was a parameter error, or the command was not presently allowed, or a Connection_Handle that didn't correspond to a connection was given.  <a href="bluenrg1__events_8c.html#a2369482e556142d063d96633a030e8cd">More...</a><br /></td></tr>
<tr class="separator:a2369482e556142d063d96633a030e8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faa6b989d310e22cd46fdf0c8ab138d"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a0faa6b989d310e22cd46fdf0c8ab138d">hci_encryption_change_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a0faa6b989d310e22cd46fdf0c8ab138d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Encryption Change event is used to indicate that the change of the encryption mode has been completed. The Connection_Handle will be a Connection_Handle for an ACL connection. The Encryption_Enabled event parameter specifies the new Encryption_Enabled parameter for the Connection_Handle specified by the Connection_Handle event parameter. This event will occur on both devices to notify the Hosts when Encryption has changed for the specified Connection_Handle between two devices. Note: This event shall not be generated if encryption is paused or resumed; during a role switch, for example. The meaning of the Encryption_Enabled parameter depends on whether the Host has indicated support for Secure Connections in the Secure_Connections_Host_Support parameter. When Secure_Connections_Host_Support is 'disabled' or the Connection_Handle refers to an LE link, the Controller shall only use Encryption_Enabled values 0x00 (OFF) and 0x01 (ON). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.8)  <a href="bluenrg1__events_8c.html#a0faa6b989d310e22cd46fdf0c8ab138d">More...</a><br /></td></tr>
<tr class="separator:a0faa6b989d310e22cd46fdf0c8ab138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72922573641c68b7a6003089a4e0c206"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a72922573641c68b7a6003089a4e0c206">hci_read_remote_version_information_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a72922573641c68b7a6003089a4e0c206"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Read Remote Version Information Complete event is used to indicate the completion of the process obtaining the version information of the remote Controller specified by the Connection_Handle event parameter. The Connection_Handle shall be for an ACL connection. The Version event parameter defines the specification version of the LE Controller. The Manufacturer_Name event parameter indicates the manufacturer of the remote Controller. The Subversion event parameter is controlled by the manufacturer and is implementation dependent. The Subversion event parameter defines the various revisions that each version of the Bluetooth hardware will go through as design processes change and errors are fixed. This allows the software to determine what Bluetooth hardware is being used and, if necessary, to work around various bugs in the hardware. When the Connection_Handle is associated with an LE-U logical link, the Version event parameter shall be Link Layer VersNr parameter, the Manufacturer_Name event parameter shall be the CompId parameter, and the Subversion event parameter shall be the SubVersNr parameter. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.12)  <a href="bluenrg1__events_8c.html#a72922573641c68b7a6003089a4e0c206">More...</a><br /></td></tr>
<tr class="separator:a72922573641c68b7a6003089a4e0c206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c911320c095086d11eb6ba23f2d6d18"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a0c911320c095086d11eb6ba23f2d6d18">hci_hardware_error_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a0c911320c095086d11eb6ba23f2d6d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Hardware Error event is used to indicate some implementation specific type of hardware failure for the controller. This event is used to notify the Host that a hardware failure has occurred in the Controller.  <a href="bluenrg1__events_8c.html#a0c911320c095086d11eb6ba23f2d6d18">More...</a><br /></td></tr>
<tr class="separator:a0c911320c095086d11eb6ba23f2d6d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806a75f6cb0ae6accfaefaed6a74c132"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a806a75f6cb0ae6accfaefaed6a74c132">hci_number_of_completed_packets_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a806a75f6cb0ae6accfaefaed6a74c132"><td class="mdescLeft">&#160;</td><td class="mdescRight">'The Number Of Completed Packets event is used by the Controller to indicate to the Host how many HCI Data Packets have been completed (transmitted or flushed) for each Connection_Handle since the previous Number Of Completed Packets event was sent to the Host. This means that the corresponding buffer space has been freed in the Controller. Based on this information, and the HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_- Data_Packets return parameter of the Read_Buffer_Size command, the Host can determine for which Connection_Handles the following HCI Data Packets should be sent to the Controller. The Number Of Completed Packets event must not be sent before the corresponding Connection Complete event. While the Controller has HCI data packets in its buffer, it must keep sending the Number Of Completed Packets event to the Host at least periodically, until it finally reports that all the pending ACL Data Packets have been transmitted or flushed.  <a href="bluenrg1__events_8c.html#a806a75f6cb0ae6accfaefaed6a74c132">More...</a><br /></td></tr>
<tr class="separator:a806a75f6cb0ae6accfaefaed6a74c132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d381695aef2b7a8b85d309a18176ee"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a93d381695aef2b7a8b85d309a18176ee">hci_data_buffer_overflow_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a93d381695aef2b7a8b85d309a18176ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">'This event is used to indicate that the Controller's data buffers have been overflowed. This can occur if the Host has sent more packets than allowed. The Link_Type parameter is used to indicate that the overflow was caused by ACL data.  <a href="bluenrg1__events_8c.html#a93d381695aef2b7a8b85d309a18176ee">More...</a><br /></td></tr>
<tr class="separator:a93d381695aef2b7a8b85d309a18176ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c106b9812c2ebfeefb3eb5b8a92856"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ae9c106b9812c2ebfeefb3eb5b8a92856">hci_encryption_key_refresh_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ae9c106b9812c2ebfeefb3eb5b8a92856"><td class="mdescLeft">&#160;</td><td class="mdescRight">'The Encryption Key Refresh Complete event is used to indicate to the Host that the encryption key was refreshed on the given Connection_Handle any time encryption is paused and then resumed. If the Encryption Key Refresh Complete event was generated due to an encryption pause and resume operation embedded within a change connection link key procedure, the Encryption Key Refresh Complete event shall be sent prior to the Change Connection Link Key Complete event. If the Encryption Key Refresh Complete event was generated due to an encryption pause and resume operation embedded within a role switch procedure, the Encryption Key Refresh Complete event shall be sent prior to the Role Change event.  <a href="bluenrg1__events_8c.html#ae9c106b9812c2ebfeefb3eb5b8a92856">More...</a><br /></td></tr>
<tr class="separator:ae9c106b9812c2ebfeefb3eb5b8a92856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec8698a845f19d4f59cb3abe2119736"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#adec8698a845f19d4f59cb3abe2119736">aci_blue_initialized_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:adec8698a845f19d4f59cb3abe2119736"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event inform the application that the network coprocessor has been reset. If the reason code is a system crash, a following event <a class="el" href="group___a_c_i___h_a_l__events.html#gaa1f48559e8378e39aea921a28e1e7d84">aci_blue_crash_info_event</a> will provide more information regarding the system crash details.  <a href="bluenrg1__events_8c.html#adec8698a845f19d4f59cb3abe2119736">More...</a><br /></td></tr>
<tr class="separator:adec8698a845f19d4f59cb3abe2119736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2ceb5d05ec0632b2dd62bbf6bf7d07"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a9a2ceb5d05ec0632b2dd62bbf6bf7d07">aci_blue_events_lost_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a9a2ceb5d05ec0632b2dd62bbf6bf7d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when an overflow occurs in the event queue read by the external microcontroller. This is normally caused when the external microcontroller does not read pending events. The returned bitmap indicates which event has been lost. Please note that one bit set to 1 indicates one or more occurrences of the particular events. The event ACI_BLUE_EVENTS_LOST_EVENT cannot be lost and it will inserted in the event queue as soon as a position is freed in the event queue. This event should not happen under normal operating condition where external microcontroller promptly reads events signaled by IRQ pin. It is provided to detected unexpected behavior of the external microcontroller or to allow application to recover situations where critical events are lost.  <a href="bluenrg1__events_8c.html#a9a2ceb5d05ec0632b2dd62bbf6bf7d07">More...</a><br /></td></tr>
<tr class="separator:a9a2ceb5d05ec0632b2dd62bbf6bf7d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063c472df9bedee46d9dbdfeeae8dd9a"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a063c472df9bedee46d9dbdfeeae8dd9a">aci_blue_crash_info_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a063c472df9bedee46d9dbdfeeae8dd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is given to the application after the <a class="el" href="group___a_c_i___h_a_l__events.html#ga8feeb9351544a3a2b5a1a02a6561e666">aci_blue_initialized_event</a> when a system crash is detected. This events returns system crash information for debugging purposes. Information reported are useful to understand the root cause of the crash.  <a href="bluenrg1__events_8c.html#a063c472df9bedee46d9dbdfeeae8dd9a">More...</a><br /></td></tr>
<tr class="separator:a063c472df9bedee46d9dbdfeeae8dd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f6c7d04f30f7f65b13ac009a5b316d"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#aa7f6c7d04f30f7f65b13ac009a5b316d">aci_hal_end_of_radio_activity_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:aa7f6c7d04f30f7f65b13ac009a5b316d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the device completes a radio activity and provide information when a new radio activity will be performed. Information provided includes type of radio activity and absolute time in system ticks when a new radio activity is schedule, if any. Application can use this information to schedule user activities synchronous to selected radio activities. A command <a class="el" href="group___h_a_l___functions.html#ga120ca17ceac401485f6281f2037126b0">aci_hal_set_radio_activity_mask</a> is provided to enable radio activity events of user interests, by default no events are enabled. User should take into account that enabling radio events in application with intense radio activity could lead to a fairly high rate of events generated. Application use cases includes synchronizing notification with connection interval, switching antenna at the end of advertising or performing flash erase operation while radio is idle.  <a href="bluenrg1__events_8c.html#aa7f6c7d04f30f7f65b13ac009a5b316d">More...</a><br /></td></tr>
<tr class="separator:aa7f6c7d04f30f7f65b13ac009a5b316d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb6e12aef64dfa55897b7279aac1785"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#aacb6e12aef64dfa55897b7279aac1785">aci_hal_scan_req_report_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:aacb6e12aef64dfa55897b7279aac1785"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is reported to the application after a scan request is received and a scan reponse is scheduled to be transmitted.  <a href="bluenrg1__events_8c.html#aacb6e12aef64dfa55897b7279aac1785">More...</a><br /></td></tr>
<tr class="separator:aacb6e12aef64dfa55897b7279aac1785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5efbe6e0b3198ba3c0050925ed5adc"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#aee5efbe6e0b3198ba3c0050925ed5adc">aci_hal_fw_error_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:aee5efbe6e0b3198ba3c0050925ed5adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated to report firmware error informations. After this event with error type equal to either 0x01, 0x02 or 0x3, it is recommended to disconnect the link (handle is reported in Data field).  <a href="bluenrg1__events_8c.html#aee5efbe6e0b3198ba3c0050925ed5adc">More...</a><br /></td></tr>
<tr class="separator:aee5efbe6e0b3198ba3c0050925ed5adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aa391c2b9c6efa8539a05b522d28f7"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ae7aa391c2b9c6efa8539a05b522d28f7">aci_gap_limited_discoverable_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ae7aa391c2b9c6efa8539a05b522d28f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated by the controller when the limited discoverable mode ends due to timeout. The timeout is 180 seconds.  <a href="bluenrg1__events_8c.html#ae7aa391c2b9c6efa8539a05b522d28f7">More...</a><br /></td></tr>
<tr class="separator:ae7aa391c2b9c6efa8539a05b522d28f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bb71c3ffa7fdf96740c5f7c2a6531e"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ae6bb71c3ffa7fdf96740c5f7c2a6531e">aci_gap_pairing_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ae6bb71c3ffa7fdf96740c5f7c2a6531e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the pairing process has completed successfully or a pairing procedure timeout has occurred or the pairing has failed. This is to notify the application that we have paired with a remote device so that it can take further actions or to notify that a timeout has occurred so that the upper layer can decide to disconnect the link.  <a href="bluenrg1__events_8c.html#ae6bb71c3ffa7fdf96740c5f7c2a6531e">More...</a><br /></td></tr>
<tr class="separator:ae6bb71c3ffa7fdf96740c5f7c2a6531e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96b6152dbc3a6950e8007e70ee51ba9"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ae96b6152dbc3a6950e8007e70ee51ba9">aci_gap_pass_key_req_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ae96b6152dbc3a6950e8007e70ee51ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated by the Security manager to the application when a passkey is required for pairing. When this event is received, the application has to respond with the <a class="el" href="group___g_a_p___functions.html#gab5acbb617b13a0880a76d8f063153e6f">aci_gap_pass_key_resp</a> command.  <a href="bluenrg1__events_8c.html#ae96b6152dbc3a6950e8007e70ee51ba9">More...</a><br /></td></tr>
<tr class="separator:ae96b6152dbc3a6950e8007e70ee51ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4226aa8d6d28748738e0a34a29bad5d9"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a4226aa8d6d28748738e0a34a29bad5d9">aci_gap_authorization_req_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a4226aa8d6d28748738e0a34a29bad5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated by the Security manager to the application when the application has set that authorization is required for reading/writing of attributes. This event will be generated as soon as the pairing is complete. When this event is received, <a class="el" href="group___g_a_p___functions.html#ga14f00c7d04afae40779a36b27684f840">aci_gap_authorization_resp</a> command should be used to respond by the application.  <a href="bluenrg1__events_8c.html#a4226aa8d6d28748738e0a34a29bad5d9">More...</a><br /></td></tr>
<tr class="separator:a4226aa8d6d28748738e0a34a29bad5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a0d9fd061f2a3d2a80b7d555bc5532"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a46a0d9fd061f2a3d2a80b7d555bc5532">aci_gap_slave_security_initiated_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a46a0d9fd061f2a3d2a80b7d555bc5532"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the slave security request is successfully sent to the master.  <a href="bluenrg1__events_8c.html#a46a0d9fd061f2a3d2a80b7d555bc5532">More...</a><br /></td></tr>
<tr class="separator:a46a0d9fd061f2a3d2a80b7d555bc5532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533cad9b5ab5cf49ad567b3d8893dc71"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a533cad9b5ab5cf49ad567b3d8893dc71">aci_gap_bond_lost_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a533cad9b5ab5cf49ad567b3d8893dc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated on the slave when a ACI_GAP_SLAVE_SECURITY_REQUEST is called to reestablish the bond with a master but the master has lost the bond. When this event is received, the upper layer has to issue the ACI_GAP_ALLOW_REBOND command in order to allow the slave to continue the pairing process with the master. On the master this event is raised when ACI_GAP_SEND_PAIRING_REQUEST is called to reestablish a bond with a slave but the slave has lost the bond. In order to create a new bond the master has to launch ACI_GAP_SEND_PAIRING_REQUEST with force_rebond set to 1.  <a href="bluenrg1__events_8c.html#a533cad9b5ab5cf49ad567b3d8893dc71">More...</a><br /></td></tr>
<tr class="separator:a533cad9b5ab5cf49ad567b3d8893dc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bd958daa2446360e31a4801d7b4414"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ad6bd958daa2446360e31a4801d7b4414">aci_gap_proc_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ad6bd958daa2446360e31a4801d7b4414"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is sent by the GAP to the upper layers when a procedure previously started has been terminated by the upper layer or has completed for any other reason.  <a href="bluenrg1__events_8c.html#ad6bd958daa2446360e31a4801d7b4414">More...</a><br /></td></tr>
<tr class="separator:ad6bd958daa2446360e31a4801d7b4414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3613cb6f1119b786229635ef41b2b73"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#af3613cb6f1119b786229635ef41b2b73">aci_gap_addr_not_resolved_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:af3613cb6f1119b786229635ef41b2b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is sent only by a privacy enabled Peripheral. The event is sent to the upper layers when the peripheral is unsuccessful in resolving the resolvable address of the peer device after connecting to it.  <a href="bluenrg1__events_8c.html#af3613cb6f1119b786229635ef41b2b73">More...</a><br /></td></tr>
<tr class="separator:af3613cb6f1119b786229635ef41b2b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e270aa620178190406653b6e1452866"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a3e270aa620178190406653b6e1452866">aci_gap_numeric_comparison_value_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a3e270aa620178190406653b6e1452866"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is sent only during SC v.4.2 Pairing, when Numeric Comparison Association model is selected, in order to show the Numeric Value generated, and to ask for Confirmation to the User. When this event is received, the application has to respond with the <a class="el" href="group___g_a_p___functions.html#ga53ae1db71ecec2ba7f9dd2992185d935">aci_gap_numeric_comparison_value_confirm_yesno</a> command.  <a href="bluenrg1__events_8c.html#a3e270aa620178190406653b6e1452866">More...</a><br /></td></tr>
<tr class="separator:a3e270aa620178190406653b6e1452866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33c62ff5bb568eeede0c0d345952f0c"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ab33c62ff5bb568eeede0c0d345952f0c">aci_gap_keypress_notification_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ab33c62ff5bb568eeede0c0d345952f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is sent only during SC v.4.2 Pairing, when Keypress Notifications are supported, in order to show the input type signalled by the peer device, having Keyboard only I/O capabilities. When this event is received, no action is required to the User.  <a href="bluenrg1__events_8c.html#ab33c62ff5bb568eeede0c0d345952f0c">More...</a><br /></td></tr>
<tr class="separator:ab33c62ff5bb568eeede0c0d345952f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fadd3fac1c528b6becb12f93666916a"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a4fadd3fac1c528b6becb12f93666916a">aci_l2cap_connection_update_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a4fadd3fac1c528b6becb12f93666916a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the master responds to the connection update request packet with a connection update response packet.  <a href="bluenrg1__events_8c.html#a4fadd3fac1c528b6becb12f93666916a">More...</a><br /></td></tr>
<tr class="separator:a4fadd3fac1c528b6becb12f93666916a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad600ea8ba6ebf88f886803715ae5d515"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ad600ea8ba6ebf88f886803715ae5d515">aci_l2cap_proc_timeout_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ad600ea8ba6ebf88f886803715ae5d515"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the master does not respond to the connection update request packet with a connection update response packet or a command reject packet within 30 seconds.  <a href="bluenrg1__events_8c.html#ad600ea8ba6ebf88f886803715ae5d515">More...</a><br /></td></tr>
<tr class="separator:ad600ea8ba6ebf88f886803715ae5d515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bb92d4ae66d9aa15a7a588a2e080e6"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a31bb92d4ae66d9aa15a7a588a2e080e6">aci_l2cap_connection_update_req_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a31bb92d4ae66d9aa15a7a588a2e080e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The event is given by the L2CAP layer when a connection update request is received from the slave. The upper layer which receives this event has to respond by sending a <a class="el" href="group___l2_c_a_p___functions.html#gaa603559ff3b65676a6d85aaf762dd2f3">aci_l2cap_connection_parameter_update_resp</a> command.  <a href="bluenrg1__events_8c.html#a31bb92d4ae66d9aa15a7a588a2e080e6">More...</a><br /></td></tr>
<tr class="separator:a31bb92d4ae66d9aa15a7a588a2e080e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e60bad27a5e41bc08cbcab01ffa13b7"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a0e60bad27a5e41bc08cbcab01ffa13b7">aci_l2cap_command_reject_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a0e60bad27a5e41bc08cbcab01ffa13b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the master responds to the connection update request packet with a command reject packet.  <a href="bluenrg1__events_8c.html#a0e60bad27a5e41bc08cbcab01ffa13b7">More...</a><br /></td></tr>
<tr class="separator:a0e60bad27a5e41bc08cbcab01ffa13b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d97db4d0e2789bb3524041445cdf2b4"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a5d97db4d0e2789bb3524041445cdf2b4">aci_gatt_attribute_modified_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a5d97db4d0e2789bb3524041445cdf2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated to the application by the GATT server when a client modifies any attribute on the server, as consequence of one of the following GATT procedures: - write without response - signed write without response - write characteristic value - write long characteristic value - reliable write.  <a href="bluenrg1__events_8c.html#a5d97db4d0e2789bb3524041445cdf2b4">More...</a><br /></td></tr>
<tr class="separator:a5d97db4d0e2789bb3524041445cdf2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de3b0874efd82d4b6287176e91cba47"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a6de3b0874efd82d4b6287176e91cba47">aci_gatt_proc_timeout_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a6de3b0874efd82d4b6287176e91cba47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated by the client/server to the application on a GATT timeout (30 seconds). This is a critical event that should not happen during normal operating conditions. It is an indication of either a major disruption in the communication link or a mistake in the application which does not provide a reply to GATT procedures. After this event, the GATT channel is closed and no more GATT communication can be performed. The applications is exptected to issue an <a class="el" href="group___g_a_p___functions.html#ga7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a> to disconnect from the peer device. It is important to leave an 100 ms blank window before sending the <a class="el" href="group___g_a_p___functions.html#ga7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a>, since immediately after this event, system could save important information in non volatile memory.  <a href="bluenrg1__events_8c.html#a6de3b0874efd82d4b6287176e91cba47">More...</a><br /></td></tr>
<tr class="separator:a6de3b0874efd82d4b6287176e91cba47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64219344572342b2b0936b877a1bbfb0"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a64219344572342b2b0936b877a1bbfb0">aci_att_exchange_mtu_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a64219344572342b2b0936b877a1bbfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to an Exchange MTU request (local or from the peer). See <a class="el" href="group___g_a_t_t___functions.html#gac0a88b448970051ddc62b190cdef4797">aci_gatt_exchange_config</a>.  <a href="bluenrg1__events_8c.html#a64219344572342b2b0936b877a1bbfb0">More...</a><br /></td></tr>
<tr class="separator:a64219344572342b2b0936b877a1bbfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dfd5564ca0e6128ef05ca7fe57c21e"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a70dfd5564ca0e6128ef05ca7fe57c21e">aci_att_find_info_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a70dfd5564ca0e6128ef05ca7fe57c21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a Find Information Request. See <a class="el" href="group___g_a_t_t___functions.html#ga5c370a4835c2aa0caa7e0f7c7895be23">aci_att_find_info_req</a> and Find Information Response in Bluetooth Core v4.1 spec.  <a href="bluenrg1__events_8c.html#a70dfd5564ca0e6128ef05ca7fe57c21e">More...</a><br /></td></tr>
<tr class="separator:a70dfd5564ca0e6128ef05ca7fe57c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4515d24579ee7b19db48ff3f58447947"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a4515d24579ee7b19db48ff3f58447947">aci_att_find_by_type_value_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a4515d24579ee7b19db48ff3f58447947"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a <a class="el" href="group___g_a_t_t___functions.html#ga5e1bde76a4d586c0461ff6881eab9bba">aci_att_find_by_type_value_req</a>.  <a href="bluenrg1__events_8c.html#a4515d24579ee7b19db48ff3f58447947">More...</a><br /></td></tr>
<tr class="separator:a4515d24579ee7b19db48ff3f58447947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e568de8cce1bf4a5b9838b2cba7e77"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a72e568de8cce1bf4a5b9838b2cba7e77">aci_att_read_by_type_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a72e568de8cce1bf4a5b9838b2cba7e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a <a class="el" href="group___g_a_t_t___functions.html#gaaaf1a025c614e23f766c7575f719475d">aci_att_read_by_type_req</a>. See <a class="el" href="group___g_a_t_t___functions.html#gab67180282b008b0d40cb593a6ebca7cc">aci_gatt_find_included_services</a> and <a class="el" href="group___g_a_t_t___functions.html#ga2200e46345c7ef9f11d30028bf51b229">aci_gatt_disc_all_char_desc</a>.  <a href="bluenrg1__events_8c.html#a72e568de8cce1bf4a5b9838b2cba7e77">More...</a><br /></td></tr>
<tr class="separator:a72e568de8cce1bf4a5b9838b2cba7e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4ea6b0309aeb3730a611c138e2891e"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#aed4ea6b0309aeb3730a611c138e2891e">aci_att_read_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:aed4ea6b0309aeb3730a611c138e2891e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a Read Request. See <a class="el" href="group___g_a_t_t___functions.html#gabdff31530e011daa69a42c6f37af4c25">aci_gatt_read_char_value</a>.  <a href="bluenrg1__events_8c.html#aed4ea6b0309aeb3730a611c138e2891e">More...</a><br /></td></tr>
<tr class="separator:aed4ea6b0309aeb3730a611c138e2891e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebbffc3d4f8c24a9db8aad0724bb19b"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a8ebbffc3d4f8c24a9db8aad0724bb19b">aci_att_read_blob_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a8ebbffc3d4f8c24a9db8aad0724bb19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event can be generated during a read long characteristic value procedure. See <a class="el" href="group___g_a_t_t___functions.html#ga638eb79e8871f992e629f38653c2f044">aci_gatt_read_long_char_value</a>.  <a href="bluenrg1__events_8c.html#a8ebbffc3d4f8c24a9db8aad0724bb19b">More...</a><br /></td></tr>
<tr class="separator:a8ebbffc3d4f8c24a9db8aad0724bb19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfc7f9c005974617d1b2a76167dbc91"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a4bfc7f9c005974617d1b2a76167dbc91">aci_att_read_multiple_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a4bfc7f9c005974617d1b2a76167dbc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a Read Multiple Request.  <a href="bluenrg1__events_8c.html#a4bfc7f9c005974617d1b2a76167dbc91">More...</a><br /></td></tr>
<tr class="separator:a4bfc7f9c005974617d1b2a76167dbc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2820a92523a80f3c0a5c2e99edc806"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a5a2820a92523a80f3c0a5c2e99edc806">aci_att_read_by_group_type_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a5a2820a92523a80f3c0a5c2e99edc806"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a Read By Group Type Request. See <a class="el" href="group___g_a_t_t___functions.html#gadf6202c7e05533beb408eb0f89946269">aci_gatt_disc_all_primary_services</a>.  <a href="bluenrg1__events_8c.html#a5a2820a92523a80f3c0a5c2e99edc806">More...</a><br /></td></tr>
<tr class="separator:a5a2820a92523a80f3c0a5c2e99edc806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d4024147eddb7b9c6555fffe5fa6d1"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a16d4024147eddb7b9c6555fffe5fa6d1">aci_att_prepare_write_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a16d4024147eddb7b9c6555fffe5fa6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a <a class="el" href="group___g_a_t_t___functions.html#ga537b7754909badb3f536d286bac970fd">aci_att_prepare_write_req</a>.  <a href="bluenrg1__events_8c.html#a16d4024147eddb7b9c6555fffe5fa6d1">More...</a><br /></td></tr>
<tr class="separator:a16d4024147eddb7b9c6555fffe5fa6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a5b4f6552d2539862969c223a274bc"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ae5a5b4f6552d2539862969c223a274bc">aci_att_exec_write_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ae5a5b4f6552d2539862969c223a274bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to an Execute Write Request.  <a href="bluenrg1__events_8c.html#ae5a5b4f6552d2539862969c223a274bc">More...</a><br /></td></tr>
<tr class="separator:ae5a5b4f6552d2539862969c223a274bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bd43ba482145259b6cccdce207ccf4"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#aa6bd43ba482145259b6cccdce207ccf4">aci_gatt_indication_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:aa6bd43ba482145259b6cccdce207ccf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when an indication is received from the server.  <a href="bluenrg1__events_8c.html#aa6bd43ba482145259b6cccdce207ccf4">More...</a><br /></td></tr>
<tr class="separator:aa6bd43ba482145259b6cccdce207ccf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b2798f17ed03710594433b66c9b772"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a13b2798f17ed03710594433b66c9b772">aci_gatt_notification_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a13b2798f17ed03710594433b66c9b772"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a notification is received from the server.  <a href="bluenrg1__events_8c.html#a13b2798f17ed03710594433b66c9b772">More...</a><br /></td></tr>
<tr class="separator:a13b2798f17ed03710594433b66c9b772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf0e739ce4ed16825359aec75c6497d"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#aecf0e739ce4ed16825359aec75c6497d">aci_gatt_proc_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:aecf0e739ce4ed16825359aec75c6497d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a GATT client procedure completes either with error or successfully.  <a href="bluenrg1__events_8c.html#aecf0e739ce4ed16825359aec75c6497d">More...</a><br /></td></tr>
<tr class="separator:aecf0e739ce4ed16825359aec75c6497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb396f958c5de3c5d9033b5f8fa8431a"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#afb396f958c5de3c5d9033b5f8fa8431a">aci_gatt_error_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:afb396f958c5de3c5d9033b5f8fa8431a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when an Error Response is received from the server. The error response can be given by the server at the end of one of the GATT discovery procedures. This does not mean that the procedure ended with an error, but this error event is part of the procedure itself.  <a href="bluenrg1__events_8c.html#afb396f958c5de3c5d9033b5f8fa8431a">More...</a><br /></td></tr>
<tr class="separator:afb396f958c5de3c5d9033b5f8fa8431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fca4cdb2f25028f3b2b4d23230c8ae"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#af2fca4cdb2f25028f3b2b4d23230c8ae">aci_gatt_disc_read_char_by_uuid_resp_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:af2fca4cdb2f25028f3b2b4d23230c8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event can be generated during a "Discover Characteristics By
       UUID" procedure or a "Read using Characteristic UUID" procedure. The attribute value will be a service declaration as defined in Bluetooth Core v4.1spec (vol.3, Part G, ch. 3.3.1), when a "Discover
       Characteristics By UUID" has been started. It will be the value of the Characteristic if a* "Read using Characteristic UUID" has been performed.  <a href="bluenrg1__events_8c.html#af2fca4cdb2f25028f3b2b4d23230c8ae">More...</a><br /></td></tr>
<tr class="separator:af2fca4cdb2f25028f3b2b4d23230c8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7cb68b559096742d4f356cd4fa5362"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#aca7cb68b559096742d4f356cd4fa5362">aci_gatt_write_permit_req_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:aca7cb68b559096742d4f356cd4fa5362"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is given to the application when a write request, write command or signed write command is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added. When this event is received, the application has to check whether the value being requested for write can be allowed to be written and respond with the command <a class="el" href="group___g_a_t_t___functions.html#ga602ae12a56126b7e76ae1270e9f21d64">aci_gatt_write_resp</a>. The details of the parameters of the command can be found. Based on the response from the application, the attribute value will be modified by the stack. If the write is rejected by the application, then the value of the attribute will not be modified. In case of a write REQ, an error response will be sent to the client, with the error code as specified by the application. In case of write/signed write commands, no response is sent to the client but the attribute is not modified.  <a href="bluenrg1__events_8c.html#aca7cb68b559096742d4f356cd4fa5362">More...</a><br /></td></tr>
<tr class="separator:aca7cb68b559096742d4f356cd4fa5362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f57030be21159a1bf88f06c385f291"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a07f57030be21159a1bf88f06c385f291">aci_gatt_read_permit_req_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a07f57030be21159a1bf88f06c385f291"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is given to the application when a read request or read blob request is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added. On receiving this event, the application can update the value of the handle if it desires and when done, it has to send the <a class="el" href="group___g_a_t_t___functions.html#ga5661814b590763c2753b6aa177d87e00">aci_gatt_allow_read</a> command to indicate to the stack that it can send the response to the client.  <a href="bluenrg1__events_8c.html#a07f57030be21159a1bf88f06c385f291">More...</a><br /></td></tr>
<tr class="separator:a07f57030be21159a1bf88f06c385f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a73e9b30edcb6dc1f0dbb3397ff543"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#af8a73e9b30edcb6dc1f0dbb3397ff543">aci_gatt_read_multi_permit_req_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:af8a73e9b30edcb6dc1f0dbb3397ff543"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is given to the application when a read multiple request or read by type request is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added. On receiving this event, the application can update the values of the handles if it desires and when done, it has to send the <a class="el" href="group___g_a_t_t___functions.html#ga5661814b590763c2753b6aa177d87e00">aci_gatt_allow_read</a> command to indicate to the stack that it can send the response to the client.  <a href="bluenrg1__events_8c.html#af8a73e9b30edcb6dc1f0dbb3397ff543">More...</a><br /></td></tr>
<tr class="separator:af8a73e9b30edcb6dc1f0dbb3397ff543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708f54c693a4151ae1e20c33ac158496"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a708f54c693a4151ae1e20c33ac158496">aci_gatt_tx_pool_available_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a708f54c693a4151ae1e20c33ac158496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each time BLE FW stack raises the error code ble_status_insufficient_resources (0x64), the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga709cad02cfa0756751380fce49915688">aci_gatt_tx_pool_available_event</a> event is generated as soon as the available buffer size is greater than maximum ATT MTU (on stack versions below v2.1 this event is generated when at least 2 packets with MTU of 23 bytes are available).  <a href="bluenrg1__events_8c.html#a708f54c693a4151ae1e20c33ac158496">More...</a><br /></td></tr>
<tr class="separator:a708f54c693a4151ae1e20c33ac158496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f617f2f5ebc0f5c00c4f30b000c651"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a28f617f2f5ebc0f5c00c4f30b000c651">aci_gatt_server_confirmation_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a28f617f2f5ebc0f5c00c4f30b000c651"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the client has sent the confirmation to a previously sent indication.  <a href="bluenrg1__events_8c.html#a28f617f2f5ebc0f5c00c4f30b000c651">More...</a><br /></td></tr>
<tr class="separator:a28f617f2f5ebc0f5c00c4f30b000c651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5337cf008b52c6519b0c19f3d4c84f5"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#af5337cf008b52c6519b0c19f3d4c84f5">aci_gatt_prepare_write_permit_req_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:af5337cf008b52c6519b0c19f3d4c84f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is given to the application when a prepare write request is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added. When this event is received, the application has to check whether the value being requested for write can be allowed to be written and respond with the command <a class="el" href="group___g_a_t_t___functions.html#ga602ae12a56126b7e76ae1270e9f21d64">aci_gatt_write_resp</a>. Based on the response from the application, the attribute value will be modified by the stack. If the write is rejected by the application, then the value of the attribute will not be modified and an error response will be sent to the client, with the error code as specified by the application.  <a href="bluenrg1__events_8c.html#af5337cf008b52c6519b0c19f3d4c84f5">More...</a><br /></td></tr>
<tr class="separator:af5337cf008b52c6519b0c19f3d4c84f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0930fb688df3373e0d0684ce32a9a2b5"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a0930fb688df3373e0d0684ce32a9a2b5">hci_le_connection_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a0930fb688df3373e0d0684ce32a9a2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Connection Complete event indicates to both of the Hosts forming the connection that a new connection has been created. Upon the creation of the connection a Connection_Handle shall be assigned by the Controller, and passed to the Host in this event. If the connection establishment fails this event shall be provided to the Host that had issued the LE_Create_Connection command. This event indicates to the Host which issued a LE_Create_Connection command and received a Command Status event if the connection establishment failed or was successful. The Master_Clock_Accuracy parameter is only valid for a slave. On a master, this parameter shall be set to 0x00.  <a href="bluenrg1__events_8c.html#a0930fb688df3373e0d0684ce32a9a2b5">More...</a><br /></td></tr>
<tr class="separator:a0930fb688df3373e0d0684ce32a9a2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99f91727983bea5f3f202bd5f39b3b7"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ad99f91727983bea5f3f202bd5f39b3b7">hci_le_advertising_report_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ad99f91727983bea5f3f202bd5f39b3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Advertising Report event indicates that a Bluetooth device or multiple Bluetooth devices have responded to an active scan or received some information during a passive scan. The Controller may queue these advertising reports and send information from multiple devices in one LE Advertising Report event.  <a href="bluenrg1__events_8c.html#ad99f91727983bea5f3f202bd5f39b3b7">More...</a><br /></td></tr>
<tr class="separator:ad99f91727983bea5f3f202bd5f39b3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef68fd95518b65fccbe741aa84c8f5ce"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#aef68fd95518b65fccbe741aa84c8f5ce">hci_le_connection_update_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:aef68fd95518b65fccbe741aa84c8f5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Connection Update Complete event is used to indicate that the Controller process to update the connection has completed. On a slave, if no connection parameters are updated, then this event shall not be issued. On a master, this event shall be issued if the Connection_Update command was sent.  <a href="bluenrg1__events_8c.html#aef68fd95518b65fccbe741aa84c8f5ce">More...</a><br /></td></tr>
<tr class="separator:aef68fd95518b65fccbe741aa84c8f5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420e0e1bbf2b924b2c4cbb96a3902797"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a420e0e1bbf2b924b2c4cbb96a3902797">hci_le_read_remote_used_features_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a420e0e1bbf2b924b2c4cbb96a3902797"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Read Remote Used Features Complete event is used to indicate the completion of the process of the Controller obtaining the used features of the remote Bluetooth device specified by the Connection_Handle event parameter.  <a href="bluenrg1__events_8c.html#a420e0e1bbf2b924b2c4cbb96a3902797">More...</a><br /></td></tr>
<tr class="separator:a420e0e1bbf2b924b2c4cbb96a3902797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a5b73fc583d0d2e76f0a766afa212c"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ab6a5b73fc583d0d2e76f0a766afa212c">hci_le_long_term_key_request_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ab6a5b73fc583d0d2e76f0a766afa212c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Long Term Key Request event indicates that the master device is attempting to encrypt or re-encrypt the link and is requesting the Long Term Key from the Host. (See [Vol 6] Part B, Section 5.1.3).  <a href="bluenrg1__events_8c.html#ab6a5b73fc583d0d2e76f0a766afa212c">More...</a><br /></td></tr>
<tr class="separator:ab6a5b73fc583d0d2e76f0a766afa212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84ae9335590a5c01faab11557990f87"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ad84ae9335590a5c01faab11557990f87">hci_le_data_length_change_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ad84ae9335590a5c01faab11557990f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Data Length Change event notifies the Host of a change to either the maximum Payload length or the maximum transmission time of Data Channel PDUs in either direction. The values reported are the maximum that will actually be used on the connection following the change.  <a href="bluenrg1__events_8c.html#ad84ae9335590a5c01faab11557990f87">More...</a><br /></td></tr>
<tr class="separator:ad84ae9335590a5c01faab11557990f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deaff03cdbeaf4a28122c57b2fc6ee0"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a9deaff03cdbeaf4a28122c57b2fc6ee0">hci_le_read_local_p256_public_key_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a9deaff03cdbeaf4a28122c57b2fc6ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when local P-256 key generation is complete.  <a href="bluenrg1__events_8c.html#a9deaff03cdbeaf4a28122c57b2fc6ee0">More...</a><br /></td></tr>
<tr class="separator:a9deaff03cdbeaf4a28122c57b2fc6ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac757ade1ef22b92ef429f28c18706f3c"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#ac757ade1ef22b92ef429f28c18706f3c">hci_le_generate_dhkey_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:ac757ade1ef22b92ef429f28c18706f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event indicates that LE Diffie Hellman key generation has been completed by the Controller.  <a href="bluenrg1__events_8c.html#ac757ade1ef22b92ef429f28c18706f3c">More...</a><br /></td></tr>
<tr class="separator:ac757ade1ef22b92ef429f28c18706f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14492afe9ee2c0c111b4403eabb3c45c"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a14492afe9ee2c0c111b4403eabb3c45c">hci_le_enhanced_connection_complete_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a14492afe9ee2c0c111b4403eabb3c45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Enhanced Connection Complete event indicates to both of the Hosts forming the connection that a new connection has been created. Upon the creation of the connection a Connection_Handle shall be assigned by the Controller, and passed to the Host in this event. If the connection establishment fails, this event shall be provided to the Host that had issued the LE_Create_Connection command. If this event is unmasked and LE Connection Complete event is unmasked, only the LE Enhanced Connection Complete event is sent when a new connection has been completed. This event indicates to the Host that issued a LE_Create_Connection command and received a Command Status event if the connection establishment failed or was successful. The Master_Clock_Accuracy parameter is only valid for a slave. On a master, this parameter shall be set to 0x00.  <a href="bluenrg1__events_8c.html#a14492afe9ee2c0c111b4403eabb3c45c">More...</a><br /></td></tr>
<tr class="separator:a14492afe9ee2c0c111b4403eabb3c45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b21b3059cb9bad3b557e9dc1985e53f"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__events_8c.html#a2b21b3059cb9bad3b557e9dc1985e53f">hci_le_direct_advertising_report_event_process</a> (uint8_t *buffer_in)</td></tr>
<tr class="memdesc:a2b21b3059cb9bad3b557e9dc1985e53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Direct Advertising Report event indicates that directed advertisements have been received where the advertiser is using a resolvable private address for the InitA field in the ADV_DIRECT_IND PDU and the Scanning_Filter_Policy is equal to 0x02 or 0x03, see HCI_LE_Set_Scan_Parameters. Direct_Address_Type and Direct_Addres is the address the directed advertisements are being directed to. Address_Type and Address is the address of the advertiser sending the directed advertisements.  <a href="bluenrg1__events_8c.html#a2b21b3059cb9bad3b557e9dc1985e53f">More...</a><br /></td></tr>
<tr class="separator:a2b21b3059cb9bad3b557e9dc1985e53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a17ca214cb7bd63535339e13d01f644d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structhci__command__table__type__s.html">hci_events_table_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hci_events_table</b> [7]</td></tr>
<tr class="separator:a17ca214cb7bd63535339e13d01f644d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e16f66ac2f5a573ea8b995c00b3395"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structhci__command__table__type__s.html">hci_le_meta_events_table_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hci_le_meta_events_table</b> [10]</td></tr>
<tr class="separator:a14e16f66ac2f5a573ea8b995c00b3395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6458c11c34aac2aeb180dc35bd8e0a9"><td class="memItemLeft" align="right" valign="top"><a id="af6458c11c34aac2aeb180dc35bd8e0a9"></a>
const <a class="el" href="structhci__command__table__type__s.html">hci_vendor_specific_events_table_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hci_vendor_specific_events_table</b> [43]</td></tr>
<tr class="separator:af6458c11c34aac2aeb180dc35bd8e0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Source file for external uC - BlueNRG-x in network coprocessor mode (Event callbacks) Autogenerated files, do not edit!! </p>
<dl class="section author"><dt>Author</dt><dd>AMG - RF Application team </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>Copyright (c) 2020 STMicroelectronics. All rights reserved.</p>
<p>This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component. If no LICENSE file comes with this software, it is provided AS-IS. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a64219344572342b2b0936b877a1bbfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64219344572342b2b0936b877a1bbfb0">&#9670;&nbsp;</a></span>aci_att_exchange_mtu_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_exchange_mtu_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated in response to an Exchange MTU request (local or from the peer). See <a class="el" href="group___g_a_t_t___functions.html#gac0a88b448970051ddc62b190cdef4797">aci_gatt_exchange_config</a>. </p>
<p>This event is generated in response to an Exchange MTU request (local or from the peer). See <a class="el" href="bluenrg__lp__gatt__aci_8c.html#a3089d94aa7df2578d0f5e6f4a136be3e" title="Performs an ATT MTU exchange procedure. When the ATT MTU exchange procedure is completed,...">aci_gatt_clt_exchange_config()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Server_RX_MTU</td><td>ATT_MTU value agreed between server and client </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5a5b4f6552d2539862969c223a274bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a5b4f6552d2539862969c223a274bc">&#9670;&nbsp;</a></span>aci_att_exec_write_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_exec_write_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated in response to an Execute Write Request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4515d24579ee7b19db48ff3f58447947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4515d24579ee7b19db48ff3f58447947">&#9670;&nbsp;</a></span>aci_att_find_by_type_value_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_find_by_type_value_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated in response to a <a class="el" href="group___g_a_t_t___functions.html#ga5e1bde76a4d586c0461ff6881eab9bba">aci_att_find_by_type_value_req</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Num_of_Handle_Pair</td><td>Number of attribute, group handle pairs </td></tr>
    <tr><td class="paramname">Attribute_Group_Handle_Pair</td><td>See <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa7d3f04dd801a11540ccce79c936adfe">Attribute_Group_Handle_Pair_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70dfd5564ca0e6128ef05ca7fe57c21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dfd5564ca0e6128ef05ca7fe57c21e">&#9670;&nbsp;</a></span>aci_att_find_info_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_find_info_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated in response to a Find Information Request. See <a class="el" href="group___g_a_t_t___functions.html#ga5c370a4835c2aa0caa7e0f7c7895be23">aci_att_find_info_req</a> and Find Information Response in Bluetooth Core v4.1 spec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Format</td><td>Format of the hanndle-uuid pairs </td></tr>
    <tr><td class="paramname">Event_Data_Length</td><td>Length of Handle_UUID_Pair in octets </td></tr>
    <tr><td class="paramname">Handle_UUID_Pair</td><td>A sequence of handle-uuid pairs. if format=1, each pair is:[2 octets for handle, 2 octets for UUIDs], if format=2, each pair is:[2 octets for handle, 16 octets for UUIDs] </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16d4024147eddb7b9c6555fffe5fa6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d4024147eddb7b9c6555fffe5fa6d1">&#9670;&nbsp;</a></span>aci_att_prepare_write_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_prepare_write_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated in response to a <a class="el" href="group___g_a_t_t___functions.html#ga537b7754909badb3f536d286bac970fd">aci_att_prepare_write_req</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Attribute_Handle</td><td>The handle of the attribute to be written </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the first octet to be written. </td></tr>
    <tr><td class="paramname">Part_Attribute_Value_Length</td><td>Length of Part_Attribute_Value in octets </td></tr>
    <tr><td class="paramname">Part_Attribute_Value</td><td>The value of the attribute to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ebbffc3d4f8c24a9db8aad0724bb19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebbffc3d4f8c24a9db8aad0724bb19b">&#9670;&nbsp;</a></span>aci_att_read_blob_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_read_blob_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event can be generated during a read long characteristic value procedure. See <a class="el" href="group___g_a_t_t___functions.html#ga638eb79e8871f992e629f38653c2f044">aci_gatt_read_long_char_value</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Event_Data_Length</td><td>Length of following data </td></tr>
    <tr><td class="paramname">Attribute_Value</td><td>Part of the attribute value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a2820a92523a80f3c0a5c2e99edc806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2820a92523a80f3c0a5c2e99edc806">&#9670;&nbsp;</a></span>aci_att_read_by_group_type_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_read_by_group_type_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated in response to a Read By Group Type Request. See <a class="el" href="group___g_a_t_t___functions.html#gadf6202c7e05533beb408eb0f89946269">aci_gatt_disc_all_primary_services</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Attribute_Data_Length</td><td>The size of each attribute data </td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of Attribute_Data_List in octets </td></tr>
    <tr><td class="paramname">Attribute_Data_List</td><td>Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of attribute handle, end group handle, attribute value tuples: [2 octets for Attribute Handle, 2 octets End Group Handle, (Attribute_Data_Length - 4 octets) for Attribute Value] </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72e568de8cce1bf4a5b9838b2cba7e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e568de8cce1bf4a5b9838b2cba7e77">&#9670;&nbsp;</a></span>aci_att_read_by_type_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_read_by_type_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated in response to a <a class="el" href="group___g_a_t_t___functions.html#gaaaf1a025c614e23f766c7575f719475d">aci_att_read_by_type_req</a>. See <a class="el" href="group___g_a_t_t___functions.html#gab67180282b008b0d40cb593a6ebca7cc">aci_gatt_find_included_services</a> and <a class="el" href="group___g_a_t_t___functions.html#ga2200e46345c7ef9f11d30028bf51b229">aci_gatt_disc_all_char_desc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Handle_Value_Pair_Length</td><td>The size of each attribute handle-value pair </td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of Handle_Value_Pair_Data in octets </td></tr>
    <tr><td class="paramname">Handle_Value_Pair_Data</td><td>Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of handle-value pairs: [2 octets for Attribute Handle, (Handle_Value_Pair_Length - 2 octets) for Attribute Value] </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bfc7f9c005974617d1b2a76167dbc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfc7f9c005974617d1b2a76167dbc91">&#9670;&nbsp;</a></span>aci_att_read_multiple_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_read_multiple_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated in response to a Read Multiple Request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Event_Data_Length</td><td>Length of following data </td></tr>
    <tr><td class="paramname">Set_Of_Values</td><td>A set of two or more values. A concatenation of attribute values for each of the attribute handles in the request in the order that they were requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed4ea6b0309aeb3730a611c138e2891e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4ea6b0309aeb3730a611c138e2891e">&#9670;&nbsp;</a></span>aci_att_read_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_att_read_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated in response to a Read Request. See <a class="el" href="group___g_a_t_t___functions.html#gabdff31530e011daa69a42c6f37af4c25">aci_gatt_read_char_value</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Event_Data_Length</td><td>Length of following data </td></tr>
    <tr><td class="paramname">Attribute_Value</td><td>The value of the attribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a063c472df9bedee46d9dbdfeeae8dd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063c472df9bedee46d9dbdfeeae8dd9a">&#9670;&nbsp;</a></span>aci_blue_crash_info_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_blue_crash_info_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is given to the application after the <a class="el" href="group___a_c_i___h_a_l__events.html#ga8feeb9351544a3a2b5a1a02a6561e666">aci_blue_initialized_event</a> when a system crash is detected. This events returns system crash information for debugging purposes. Information reported are useful to understand the root cause of the crash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Crash_Type</td><td>Crash type Values:<ul>
<li>0x00: Assert failed</li>
<li>0x01: NMI fault</li>
<li>0x02: Hard fault </li>
</ul>
</td></tr>
    <tr><td class="paramname">SP</td><td>Stack pointer </td></tr>
    <tr><td class="paramname">R0</td><td>Register R0 </td></tr>
    <tr><td class="paramname">R1</td><td>Register R1 </td></tr>
    <tr><td class="paramname">R2</td><td>Register R2 </td></tr>
    <tr><td class="paramname">R3</td><td>Register R3 </td></tr>
    <tr><td class="paramname">R12</td><td>Register R12 </td></tr>
    <tr><td class="paramname">LR</td><td>Link register </td></tr>
    <tr><td class="paramname">PC</td><td>Program counter where crash occurred </td></tr>
    <tr><td class="paramname">xPSR</td><td>xPSR register </td></tr>
    <tr><td class="paramname">Debug_Data_Length</td><td>Length of Debug_Data field </td></tr>
    <tr><td class="paramname">Debug_Data</td><td>Debug data </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a2ceb5d05ec0632b2dd62bbf6bf7d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2ceb5d05ec0632b2dd62bbf6bf7d07">&#9670;&nbsp;</a></span>aci_blue_events_lost_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_blue_events_lost_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when an overflow occurs in the event queue read by the external microcontroller. This is normally caused when the external microcontroller does not read pending events. The returned bitmap indicates which event has been lost. Please note that one bit set to 1 indicates one or more occurrences of the particular events. The event ACI_BLUE_EVENTS_LOST_EVENT cannot be lost and it will inserted in the event queue as soon as a position is freed in the event queue. This event should not happen under normal operating condition where external microcontroller promptly reads events signaled by IRQ pin. It is provided to detected unexpected behavior of the external microcontroller or to allow application to recover situations where critical events are lost. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Lost_Events</td><td>Bitmap of lost events. Each bit indicates one or more occurrences of the specific event. Flags:<ul>
<li>0x0000000000000001: HCI_DISCONNECTION_COMPLETE_EVENT</li>
<li>0x0000000000000002: HCI_ENCRYPTION_CHANGE_EVENT</li>
<li>0x0000000000000004: HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT</li>
<li>0x0000000000000008: HCI_COMMAND_COMPLETE_EVENT</li>
<li>0x0000000000000010: HCI_COMMAND_STATUS_EVENT</li>
<li>0x0000000000000020: HCI_HARDWARE_ERROR_EVENT</li>
<li>0x0000000000000040: HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT</li>
<li>0x0000000000000080: HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT</li>
<li>0x0000000000000100: ACI_BLUE_INITIALIZED_EVENT</li>
<li>0x0000000000000200: ACI_GAP_LIMITED_DISCOVERABLE_EVENT</li>
<li>0x0000000000000400: ACI_GAP_PAIRING_COMPLETE_EVENT</li>
<li>0x0000000000000800: ACI_GAP_PASS_KEY_REQ_EVENT</li>
<li>0x0000000000001000: ACI_GAP_AUTHORIZATION_REQ_EVENT</li>
<li>0x0000000000002000: ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT</li>
<li>0x0000000000004000: ACI_GAP_BOND_LOST_EVENT</li>
<li>0x0000000000008000: ACI_GAP_PROC_COMPLETE_EVENT</li>
<li>0x0000000000010000: ACI_GAP_ADDR_NOT_RESOLVED_EVENT</li>
<li>0x0000000000020000: ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</li>
<li>0x0000000000040000: ACI_L2CAP_PROC_TIMEOUT_EVENT</li>
<li>0x0000000000080000: ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</li>
<li>0x0000000000100000: ACI_GATT_ATTRIBUTE_MODIFIED_EVENT</li>
<li>0x0000000000200000: ACI_GATT_PROC_TIMEOUT_EVENT</li>
<li>0x0000000000400000: ACI_ATT_EXCHANGE_MTU_RESP_EVENT</li>
<li>0x0000000000800000: ACI_ATT_FIND_INFO_RESP_EVENT</li>
<li>0x0000000001000000: ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</li>
<li>0x0000000002000000: ACI_ATT_READ_BY_TYPE_RESP_EVENT</li>
<li>0x0000000004000000: ACI_ATT_READ_RESP_EVENT</li>
<li>0x0000000008000000: ACI_ATT_READ_BLOB_RESP_EVENT</li>
<li>0x0000000010000000: ACI_ATT_READ_MULTIPLE_RESP_EVENT</li>
<li>0x0000000020000000: ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</li>
<li>0x0000000040000000: ACI_ATT_WRITE_RESP_EVENT</li>
<li>0x0000000080000000: ACI_ATT_PREPARE_WRITE_RESP_EVENT</li>
<li>0x0000000100000000: ACI_ATT_EXEC_WRITE_RESP_EVENT</li>
<li>0x0000000200000000: ACI_GATT_INDICATION_EVENT</li>
<li>0x0000000400000000: ACI_GATT_NOTIFICATION_EVENT</li>
<li>0x0000000800000000: ACI_GATT_PROC_COMPLETE_EVENT</li>
<li>0x0000001000000000: ACI_GATT_ERROR_RESP_EVENT</li>
<li>0x0000002000000000: ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</li>
<li>0x0000004000000000: ACI_GATT_WRITE_PERMIT_REQ_EVENT</li>
<li>0x0000008000000000: ACI_GATT_READ_PERMIT_REQ_EVENT</li>
<li>0x0000010000000000: ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</li>
<li>0x0000020000000000: ACI_GATT_TX_POOL_AVAILABLE_EVENT</li>
<li>0x0000040000000000: ACI_GATT_SERVER_CONFIRMATION_EVENT</li>
<li>0x0000080000000000: ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT</li>
<li>0x0000100000000000: HCI_LE_CONNECTION_COMPLETE_EVENT</li>
<li>0x0000200000000000: HCI_LE_ADVERTISING_REPORT_EVENT</li>
<li>0x0000400000000000: HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</li>
<li>0x0000800000000000: HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT</li>
<li>0x0001000000000000: HCI_LE_LONG_TERM_KEY_REQUEST_EVENT</li>
<li>0x0002000000000000: HCI_LE_DATA_LENGTH_CHANGE_EVENT</li>
<li>0x0004000000000000: HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT</li>
<li>0x0008000000000000: HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT</li>
<li>0x0010000000000000: HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</li>
<li>0x0020000000000000: HCI_LE_DIRECT_ADVERTISING_REPORT_EVENT</li>
<li>0x0040000000000000: ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT</li>
<li>0x0080000000000000: ACI_GAP_KEYPRESS_NOTIFICATION_EVENT </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adec8698a845f19d4f59cb3abe2119736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec8698a845f19d4f59cb3abe2119736">&#9670;&nbsp;</a></span>aci_blue_initialized_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_blue_initialized_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event inform the application that the network coprocessor has been reset. If the reason code is a system crash, a following event <a class="el" href="group___a_c_i___h_a_l__events.html#gaa1f48559e8378e39aea921a28e1e7d84">aci_blue_crash_info_event</a> will provide more information regarding the system crash details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Reason_Code</td><td>Reason code describing why device was reset and in which mode is operating (Updater or Normal mode) Values:<ul>
<li>0x01: Firmware started properly</li>
<li>0x02: Updater mode entered with ACI command</li>
<li>0x03: Updater mode entered due to bad Blue Flag</li>
<li>0x04: Updater mode entered due to IRQ pin</li>
<li>0x05: System reset due to watchdog</li>
<li>0x06: System reset due to lockup</li>
<li>0x07: System reset due to brownout reset</li>
<li>0x08: System reset due to crash</li>
<li>0x09: System reset due to ECC error </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Reason_Code</td><td>Reason code describing why device was reset and in which mode is operating (Updater or Normal mode) Values:<ul>
<li>0x01: Firmware started properly</li>
<li>0x02: Updater mode entered with ACI command</li>
<li>0x03: Updater mode entered due to bad Blue Flag</li>
<li>0x04: Updater mode entered due to boot pin</li>
<li>0x05: System reset due to watchdog</li>
<li>0x06: System reset due to lockup</li>
<li>0x07: System reset due to brownout reset</li>
<li>0x08: System reset due to crash</li>
<li>0x09: System reset due to ECC error </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3613cb6f1119b786229635ef41b2b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3613cb6f1119b786229635ef41b2b73">&#9670;&nbsp;</a></span>aci_gap_addr_not_resolved_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_addr_not_resolved_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is sent only by a privacy enabled Peripheral. The event is sent to the upper layers when the peripheral is unsuccessful in resolving the resolvable address of the peer device after connecting to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle for which the private address could not be resolved with any of the stored IRK's. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4226aa8d6d28748738e0a34a29bad5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4226aa8d6d28748738e0a34a29bad5d9">&#9670;&nbsp;</a></span>aci_gap_authorization_req_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_authorization_req_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated by the Security manager to the application when the application has set that authorization is required for reading/writing of attributes. This event will be generated as soon as the pairing is complete. When this event is received, <a class="el" href="group___g_a_p___functions.html#ga14f00c7d04afae40779a36b27684f840">aci_gap_authorization_resp</a> command should be used to respond by the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle for which authorization has been requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a533cad9b5ab5cf49ad567b3d8893dc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533cad9b5ab5cf49ad567b3d8893dc71">&#9670;&nbsp;</a></span>aci_gap_bond_lost_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_bond_lost_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated on the slave when a ACI_GAP_SLAVE_SECURITY_REQUEST is called to reestablish the bond with a master but the master has lost the bond. When this event is received, the upper layer has to issue the ACI_GAP_ALLOW_REBOND command in order to allow the slave to continue the pairing process with the master. On the master this event is raised when ACI_GAP_SEND_PAIRING_REQUEST is called to reestablish a bond with a slave but the slave has lost the bond. In order to create a new bond the master has to launch ACI_GAP_SEND_PAIRING_REQUEST with force_rebond set to 1. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab33c62ff5bb568eeede0c0d345952f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33c62ff5bb568eeede0c0d345952f0c">&#9670;&nbsp;</a></span>aci_gap_keypress_notification_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_keypress_notification_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is sent only during SC v.4.2 Pairing, when Keypress Notifications are supported, in order to show the input type signalled by the peer device, having Keyboard only I/O capabilities. When this event is received, no action is required to the User. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the underlying Pairing </td></tr>
    <tr><td class="paramname">Notification_Type</td><td>Type of Keypress input notified/signaled by peer device Values:<ul>
<li>0x00: PASSKEY_ENTRY_STARTED</li>
<li>0x01: PASSKEY_DIGIT_ENTERED</li>
<li>0x02: PASSKEY_DIGIT_ERASED</li>
<li>0x03: PASSKEY_CLEARED</li>
<li>0x04: PASSKEY_ENTRY_COMPLETED </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7aa391c2b9c6efa8539a05b522d28f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7aa391c2b9c6efa8539a05b522d28f7">&#9670;&nbsp;</a></span>aci_gap_limited_discoverable_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_limited_discoverable_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated by the controller when the limited discoverable mode ends due to timeout. The timeout is 180 seconds. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e270aa620178190406653b6e1452866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e270aa620178190406653b6e1452866">&#9670;&nbsp;</a></span>aci_gap_numeric_comparison_value_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_numeric_comparison_value_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is sent only during SC v.4.2 Pairing, when Numeric Comparison Association model is selected, in order to show the Numeric Value generated, and to ask for Confirmation to the User. When this event is received, the application has to respond with the <a class="el" href="group___g_a_p___functions.html#ga53ae1db71ecec2ba7f9dd2992185d935">aci_gap_numeric_comparison_value_confirm_yesno</a> command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the underlying Pairing </td></tr>
    <tr><td class="paramname">Numeric_Value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6bb71c3ffa7fdf96740c5f7c2a6531e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bb71c3ffa7fdf96740c5f7c2a6531e">&#9670;&nbsp;</a></span>aci_gap_pairing_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_pairing_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when the pairing process has completed successfully or a pairing procedure timeout has occurred or the pairing has failed. This is to notify the application that we have paired with a remote device so that it can take further actions or to notify that a timeout has occurred so that the upper layer can decide to disconnect the link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle on which the pairing procedure completed </td></tr>
    <tr><td class="paramname">Status</td><td>Pairing status. If 0x02, see Reason code. Values:<ul>
<li>0x00: Success</li>
<li>0x01: Timeout</li>
<li>0x02: Pairing Failed</li>
<li>0x03: Encryption failed, LTK missing on local device</li>
<li>0x04: Encryption failed, LTK missing on peer device</li>
<li>0x05: Encryption not supported by remote device </li>
</ul>
</td></tr>
    <tr><td class="paramname">Reason</td><td>Pairing reason error code. Valid if Status is 0x02. Values:<ul>
<li>0x00</li>
<li>0x01: PASSKEY_ENTRY_FAILED</li>
<li>0x02: OOB_NOT_AVAILABLE</li>
<li>0x03: AUTH_REQ_CANNOT_BE_MET</li>
<li>0x04: CONFIRM_VALUE_FAILED</li>
<li>0x05: PAIRING_NOT_SUPPORTED</li>
<li>0x06: INSUFF_ENCRYPTION_KEY_SIZE</li>
<li>0x07: CMD_NOT_SUPPORTED</li>
<li>0x08: UNSPECIFIED_REASON</li>
<li>0x09: VERY_EARLY_NEXT_ATTEMPT</li>
<li>0x0A: SM_INVALID_PARAMS</li>
<li>0x0B: SMP_SC_DHKEY_CHECK_FAILED</li>
<li>0x0C: SMP_SC_NUMCOMPARISON_FAILED </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle on which the pairing procedure completed </td></tr>
    <tr><td class="paramname">Status</td><td>Pairing status. If 0x02, see Reason code. Values:<ul>
<li>0x00: Success</li>
<li>0x01: Timeout</li>
<li>0x02: Pairing Failed</li>
<li>0x03: Encryption failed, LTK missing on local device</li>
<li>0x04: Encryption failed, LTK missing on peer device</li>
<li>0x05: Encryption not supported by remote device </li>
</ul>
</td></tr>
    <tr><td class="paramname">Reason</td><td>Pairing reason error code Values:<ul>
<li>0x00</li>
<li>0x01: PASSKEY_ENTRY_FAILED</li>
<li>0x02: OOB_NOT_AVAILABLE</li>
<li>0x03: AUTH_REQ_CANNOT_BE_MET</li>
<li>0x04: CONFIRM_VALUE_FAILED</li>
<li>0x05: PAIRING_NOT_SUPPORTED</li>
<li>0x06: INSUFF_ENCRYPTION_KEY_SIZE</li>
<li>0x07: CMD_NOT_SUPPORTED</li>
<li>0x08: UNSPECIFIED_REASON</li>
<li>0x09: VERY_EARLY_NEXT_ATTEMPT</li>
<li>0x0A: SM_INVALID_PARAMS</li>
<li>0x0B: SMP_SC_DHKEY_CHECK_FAILED</li>
<li>0x0C: SMP_SC_NUMCOMPARISON_FAILED </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae96b6152dbc3a6950e8007e70ee51ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96b6152dbc3a6950e8007e70ee51ba9">&#9670;&nbsp;</a></span>aci_gap_pass_key_req_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_pass_key_req_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated by the Security manager to the application when a passkey is required for pairing. When this event is received, the application has to respond with the <a class="el" href="group___g_a_p___functions.html#gab5acbb617b13a0880a76d8f063153e6f">aci_gap_pass_key_resp</a> command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle for which the passkey has been requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6bd958daa2446360e31a4801d7b4414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bd958daa2446360e31a4801d7b4414">&#9670;&nbsp;</a></span>aci_gap_proc_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_proc_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is sent by the GAP to the upper layers when a procedure previously started has been terminated by the upper layer or has completed for any other reason. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Procedure_Code</td><td>Terminated procedure. Values:<ul>
<li>0x01: GAP_LIMITED_DISCOVERY_PROC_BIT</li>
<li>0x02: GAP_GENERAL_DISCOVERY_PROC_BIT</li>
<li>0x04: GAP_NAME_DISCOVERY_PROC_BIT</li>
<li>0x08: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC_BIT</li>
<li>0x10: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC_BIT</li>
<li>0x20: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC_BIT</li>
<li>0x40: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC_BIT</li>
<li>0x80: GAP_OBSERVATION_PROC_BIT </li>
</ul>
</td></tr>
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of Data in octets </td></tr>
    <tr><td class="paramname">Data</td><td>Procedure Specific Data: - For Name Discovery Procedure: the name of the peer device if the procedure completed successfully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Procedure_Code</td><td>Code identifying the procedure. Values:<ul>
<li>0x00: GAP_LIMITED_DISCOVERY_PROC</li>
<li>0x01: GAP_GENERAL_DISCOVERY_PROC</li>
<li>0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC</li>
<li>0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC</li>
<li>0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC</li>
<li>0x05: GAP_OBSERVATION_PROC</li>
<li>0x06: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC</li>
<li>0x07: GAP_NAME_DISCOVERY_PROC </li>
</ul>
</td></tr>
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of Data in octets </td></tr>
    <tr><td class="paramname">Data</td><td>Procedure Specific Data: - For Name Discovery Procedure: the name of the peer device if the procedure completed successfully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46a0d9fd061f2a3d2a80b7d555bc5532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a0d9fd061f2a3d2a80b7d555bc5532">&#9670;&nbsp;</a></span>aci_gap_slave_security_initiated_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_slave_security_initiated_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when the slave security request is successfully sent to the master. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d97db4d0e2789bb3524041445cdf2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d97db4d0e2789bb3524041445cdf2b4">&#9670;&nbsp;</a></span>aci_gatt_attribute_modified_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_attribute_modified_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated to the application by the GATT server when a client modifies any attribute on the server, as consequence of one of the following GATT procedures: - write without response - signed write without response - write characteristic value - write long characteristic value - reliable write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>The connection handle which modified the attribute. </td></tr>
    <tr><td class="paramname">Attr_Handle</td><td>Handle of the attribute that was modified. </td></tr>
    <tr><td class="paramname">Offset</td><td>SoC mode: the offset is never used and it is always 0. Network coprocessor mode: - Bits 0-14: offset of the reported value inside the attribute. - Bit 15: if the entire value of the attribute does not fit inside a single ACI_GATT_ATTRIBUTE_MODIFIED_EVENT event, this bit is set to 1 to notify that other ACI_GATT_ATTRIBUTE_MODIFIED_EVENT events will follow to report the remaining value. </td></tr>
    <tr><td class="paramname">Attr_Data_Length</td><td>Length of Attr_Data in octets </td></tr>
    <tr><td class="paramname">Attr_Data</td><td>The modified value </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2fca4cdb2f25028f3b2b4d23230c8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fca4cdb2f25028f3b2b4d23230c8ae">&#9670;&nbsp;</a></span>aci_gatt_disc_read_char_by_uuid_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_disc_read_char_by_uuid_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event can be generated during a "Discover Characteristics By
       UUID" procedure or a "Read using Characteristic UUID" procedure. The attribute value will be a service declaration as defined in Bluetooth Core v4.1spec (vol.3, Part G, ch. 3.3.1), when a "Discover
       Characteristics By UUID" has been started. It will be the value of the Characteristic if a* "Read using Characteristic UUID" has been performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Attribute_Handle</td><td>The handle of the attribute </td></tr>
    <tr><td class="paramname">Attribute_Value_Length</td><td>Length of Attribute_Value in octets </td></tr>
    <tr><td class="paramname">Attribute_Value</td><td>The attribute value will be a service declaration as defined in Bluetooth Core v4.0 spec (vol.3, Part G, ch. 3.3.1), when a "Discover Characteristics By UUID" has been started. It will be the value of the Characteristic if a "Read using Characteristic UUID" has been performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb396f958c5de3c5d9033b5f8fa8431a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb396f958c5de3c5d9033b5f8fa8431a">&#9670;&nbsp;</a></span>aci_gatt_error_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_error_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when an Error Response is received from the server. The error response can be given by the server at the end of one of the GATT discovery procedures. This does not mean that the procedure ended with an error, but this error event is part of the procedure itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Req_Opcode</td><td>The request that generated this error response </td></tr>
    <tr><td class="paramname">Attribute_Handle</td><td>The attribute handle that generated this error response </td></tr>
    <tr><td class="paramname">Error_Code</td><td>The reason why the request has generated an error response (ATT error codes) Values:<ul>
<li>0x01: Invalid handle</li>
<li>0x02: Read not permitted</li>
<li>0x03: Write not permitted</li>
<li>0x04: Invalid PDU</li>
<li>0x05: Insufficient authentication</li>
<li>0x06: Request not supported</li>
<li>0x07: Invalid offset</li>
<li>0x08: Insufficient authorization</li>
<li>0x09: Prepare queue full</li>
<li>0x0A: Attribute not found</li>
<li>0x0B: Attribute not long</li>
<li>0x0C: Insufficient encryption key size</li>
<li>0x0D: Invalid attribute value length</li>
<li>0x0E: Unlikely error</li>
<li>0x0F: Insufficient encryption</li>
<li>0x10: Unsupported group type</li>
<li>0x11: Insufficient resources </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6bd43ba482145259b6cccdce207ccf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bd43ba482145259b6cccdce207ccf4">&#9670;&nbsp;</a></span>aci_gatt_indication_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_indication_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when an indication is received from the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Attribute_Handle</td><td>The handle of the attribute </td></tr>
    <tr><td class="paramname">Attribute_Value_Length</td><td>Length of Attribute_Value in octets </td></tr>
    <tr><td class="paramname">Attribute_Value</td><td>The current value of the attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13b2798f17ed03710594433b66c9b772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b2798f17ed03710594433b66c9b772">&#9670;&nbsp;</a></span>aci_gatt_notification_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_notification_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a notification is received from the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Attribute_Handle</td><td>The handle of the attribute </td></tr>
    <tr><td class="paramname">Attribute_Value_Length</td><td>Length of Attribute_Value in octets </td></tr>
    <tr><td class="paramname">Attribute_Value</td><td>The current value of the attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5337cf008b52c6519b0c19f3d4c84f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5337cf008b52c6519b0c19f3d4c84f5">&#9670;&nbsp;</a></span>aci_gatt_prepare_write_permit_req_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_prepare_write_permit_req_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is given to the application when a prepare write request is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added. When this event is received, the application has to check whether the value being requested for write can be allowed to be written and respond with the command <a class="el" href="group___g_a_t_t___functions.html#ga602ae12a56126b7e76ae1270e9f21d64">aci_gatt_write_resp</a>. Based on the response from the application, the attribute value will be modified by the stack. If the write is rejected by the application, then the value of the attribute will not be modified and an error response will be sent to the client, with the error code as specified by the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Handle of the connection on which there was the request to write the attribute </td></tr>
    <tr><td class="paramname">Attribute_Handle</td><td>The handle of the attribute </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset from which the prepare write has been requested </td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of Data field </td></tr>
    <tr><td class="paramname">Data</td><td>The data that the client has requested to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecf0e739ce4ed16825359aec75c6497d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf0e739ce4ed16825359aec75c6497d">&#9670;&nbsp;</a></span>aci_gatt_proc_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_proc_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when a GATT client procedure completes either with error or successfully. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Error_Code</td><td>Indicates whether the procedure completed with an error or was successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6de3b0874efd82d4b6287176e91cba47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de3b0874efd82d4b6287176e91cba47">&#9670;&nbsp;</a></span>aci_gatt_proc_timeout_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_proc_timeout_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated by the client/server to the application on a GATT timeout (30 seconds). This is a critical event that should not happen during normal operating conditions. It is an indication of either a major disruption in the communication link or a mistake in the application which does not provide a reply to GATT procedures. After this event, the GATT channel is closed and no more GATT communication can be performed. The applications is exptected to issue an <a class="el" href="group___g_a_p___functions.html#ga7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a> to disconnect from the peer device. It is important to leave an 100 ms blank window before sending the <a class="el" href="group___g_a_p___functions.html#ga7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a>, since immediately after this event, system could save important information in non volatile memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle on which the GATT procedure has timed out </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8a73e9b30edcb6dc1f0dbb3397ff543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a73e9b30edcb6dc1f0dbb3397ff543">&#9670;&nbsp;</a></span>aci_gatt_read_multi_permit_req_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_read_multi_permit_req_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is given to the application when a read multiple request or read by type request is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added. On receiving this event, the application can update the values of the handles if it desires and when done, it has to send the <a class="el" href="group___g_a_t_t___functions.html#ga5661814b590763c2753b6aa177d87e00">aci_gatt_allow_read</a> command to indicate to the stack that it can send the response to the client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Handle of the connection which requested to read the attribute </td></tr>
    <tr><td class="paramname">Number_of_Handles</td><td></td></tr>
    <tr><td class="paramname">Handle_Item</td><td>See <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga50684286f0c17b2f52ceb01a13bbc6f5">Handle_Item_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07f57030be21159a1bf88f06c385f291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f57030be21159a1bf88f06c385f291">&#9670;&nbsp;</a></span>aci_gatt_read_permit_req_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_read_permit_req_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is given to the application when a read request or read blob request is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added. On receiving this event, the application can update the value of the handle if it desires and when done, it has to send the <a class="el" href="group___g_a_t_t___functions.html#ga5661814b590763c2753b6aa177d87e00">aci_gatt_allow_read</a> command to indicate to the stack that it can send the response to the client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the response </td></tr>
    <tr><td class="paramname">Attribute_Handle</td><td>The handle of the attribute </td></tr>
    <tr><td class="paramname">Offset</td><td>Contains the offset from which the read has been requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28f617f2f5ebc0f5c00c4f30b000c651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f617f2f5ebc0f5c00c4f30b000c651">&#9670;&nbsp;</a></span>aci_gatt_server_confirmation_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_server_confirmation_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when the client has sent the confirmation to a previously sent indication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the event </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a708f54c693a4151ae1e20c33ac158496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708f54c693a4151ae1e20c33ac158496">&#9670;&nbsp;</a></span>aci_gatt_tx_pool_available_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_tx_pool_available_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each time BLE FW stack raises the error code ble_status_insufficient_resources (0x64), the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga709cad02cfa0756751380fce49915688">aci_gatt_tx_pool_available_event</a> event is generated as soon as the available buffer size is greater than maximum ATT MTU (on stack versions below v2.1 this event is generated when at least 2 packets with MTU of 23 bytes are available). </p>
<p>Each time BLE FW stack raises the error code ble_status_insufficient_resources, <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga709cad02cfa0756751380fce49915688" title="Each time BLE FW stack raises the error code ble_status_insufficient_resources, aci_gatt_tx_pool_avai...">aci_gatt_tx_pool_available_event()</a> is generated as soon as the available buffer size is greater than maximum ATT MTU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle related to the request </td></tr>
    <tr><td class="paramname">Available_Buffers</td><td>Not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca7cb68b559096742d4f356cd4fa5362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7cb68b559096742d4f356cd4fa5362">&#9670;&nbsp;</a></span>aci_gatt_write_permit_req_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gatt_write_permit_req_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is given to the application when a write request, write command or signed write command is received by the server from the client. This event will be given to the application only if the event bit for this event generation is set when the characteristic was added. When this event is received, the application has to check whether the value being requested for write can be allowed to be written and respond with the command <a class="el" href="group___g_a_t_t___functions.html#ga602ae12a56126b7e76ae1270e9f21d64">aci_gatt_write_resp</a>. The details of the parameters of the command can be found. Based on the response from the application, the attribute value will be modified by the stack. If the write is rejected by the application, then the value of the attribute will not be modified. In case of a write REQ, an error response will be sent to the client, with the error code as specified by the application. In case of write/signed write commands, no response is sent to the client but the attribute is not modified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Handle of the connection on which there was the request to write the attribute </td></tr>
    <tr><td class="paramname">Attribute_Handle</td><td>The handle of the attribute </td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of Data field </td></tr>
    <tr><td class="paramname">Data</td><td>The data that the client has requested to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7f6c7d04f30f7f65b13ac009a5b316d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f6c7d04f30f7f65b13ac009a5b316d">&#9670;&nbsp;</a></span>aci_hal_end_of_radio_activity_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_hal_end_of_radio_activity_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when the device completes a radio activity and provide information when a new radio activity will be performed. Information provided includes type of radio activity and absolute time in system ticks when a new radio activity is schedule, if any. Application can use this information to schedule user activities synchronous to selected radio activities. A command <a class="el" href="group___h_a_l___functions.html#ga120ca17ceac401485f6281f2037126b0">aci_hal_set_radio_activity_mask</a> is provided to enable radio activity events of user interests, by default no events are enabled. User should take into account that enabling radio events in application with intense radio activity could lead to a fairly high rate of events generated. Application use cases includes synchronizing notification with connection interval, switching antenna at the end of advertising or performing flash erase operation while radio is idle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Last_State</td><td>Completed radio events Values:<ul>
<li>0x00: Idle</li>
<li>0x01: Advertising</li>
<li>0x02: Connection event slave</li>
<li>0x03: Scanning</li>
<li>0x04: Connection request</li>
<li>0x05: Connection event master</li>
<li>0x06: TX test mode</li>
<li>0x07: RX test mode </li>
</ul>
</td></tr>
    <tr><td class="paramname">Next_State</td><td>Incoming radio events Values:<ul>
<li>0x00: Idle</li>
<li>0x01: Advertising</li>
<li>0x02: Connection event slave</li>
<li>0x03: Scanning</li>
<li>0x04: Connection request</li>
<li>0x05: Connection event master</li>
<li>0x06: TX test mode</li>
<li>0x07: RX test mode </li>
</ul>
</td></tr>
    <tr><td class="paramname">Next_State_SysTime</td><td>32bit absolute current time expressed in internal time units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee5efbe6e0b3198ba3c0050925ed5adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5efbe6e0b3198ba3c0050925ed5adc">&#9670;&nbsp;</a></span>aci_hal_fw_error_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_hal_fw_error_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated to report firmware error informations. After this event with error type equal to either 0x01, 0x02 or 0x3, it is recommended to disconnect the link (handle is reported in Data field). </p>
<p>This event is generated to report firmware error informations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FW_Error_Type</td><td>Errore code identifying the type of error that has occurred. Values:<ul>
<li>0x01: HAL_FW_L2CAP_RECOMBINATION_ERROR</li>
<li>0x02: HAL_FW_GATT_UNEXPECTED_RESPONSE_ERROR</li>
<li>0x03: HAL_FW_GATT_SEQUENTIAL_PROTOCOL_ERROR </li>
</ul>
</td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of Data in octets </td></tr>
    <tr><td class="paramname">Data</td><td>If FW_Error_Type is 0x01, 0x02 or 0x03, this parameter contains the connection handle where the abnormal condition has occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FW_Error_Type</td><td>Errore code identifying the type of error that has occurred. Values:<ul>
<li>0x01: HAL_FW_L2CAP_RECOMBINATION_ERROR</li>
<li>0x02: HAL_FW_GATT_UNEXPECTED_RESPONSE_ERROR</li>
<li>0x03: HAL_FW_GATT_SEQUENTIAL_PROTOCOL_ERROR</li>
<li>0x04: HAL_FW_BONDING_DB_FULL_PAIRING_ERROR</li>
<li>0x05: HAL_FW_BONDING_DB_FULL_GATTSERVICE_ERROR </li>
</ul>
</td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of Data in octets </td></tr>
    <tr><td class="paramname">Data</td><td>The error event info. If FW_Error_Type is 0x01, 0x02 or 0x03, this parameter contains the connection handle where the abnormal condition has occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacb6e12aef64dfa55897b7279aac1785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb6e12aef64dfa55897b7279aac1785">&#9670;&nbsp;</a></span>aci_hal_scan_req_report_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_hal_scan_req_report_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is reported to the application after a scan request is received and a scan reponse is scheduled to be transmitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RSSI</td><td>N Size: 1 Octet (signed integer) Units: dBm Values:<ul>
<li>127: RSSI not available</li>
<li>-127 ... 20 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address_Type</td><td>0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity Address (Corresponds to Resolved Private Address) 0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Public Identity Address</li>
<li>0x03: Random (Static) Identity Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address</td><td>Public Device Address or Random Device Address of the peer device </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e60bad27a5e41bc08cbcab01ffa13b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e60bad27a5e41bc08cbcab01ffa13b7">&#9670;&nbsp;</a></span>aci_l2cap_command_reject_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_l2cap_command_reject_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when the master responds to the connection update request packet with a command reject packet. </p>
<p>This event is generated when the master rejects a L2CAP request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle referring to the COS Channel where the Disconnection has been received. </td></tr>
    <tr><td class="paramname">Identifier</td><td>This is the identifier which associate the request to the response. </td></tr>
    <tr><td class="paramname">Reason</td><td>Reason </td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of following data </td></tr>
    <tr><td class="paramname">Data</td><td>Data field associated with Reason </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Handle identifying the connection. </td></tr>
    <tr><td class="paramname">Identifier</td><td>This is the identifier which associates the request to the response. </td></tr>
    <tr><td class="paramname">Reason</td><td>Reason </td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of following data </td></tr>
    <tr><td class="paramname">Data</td><td>Data field associated with Reason </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31bb92d4ae66d9aa15a7a588a2e080e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bb92d4ae66d9aa15a7a588a2e080e6">&#9670;&nbsp;</a></span>aci_l2cap_connection_update_req_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_l2cap_connection_update_req_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The event is given by the L2CAP layer when a connection update request is received from the slave. The upper layer which receives this event has to respond by sending a <a class="el" href="group___l2_c_a_p___functions.html#gaa603559ff3b65676a6d85aaf762dd2f3">aci_l2cap_connection_parameter_update_resp</a> command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Handle of the connection related to this L2CAP procedure. </td></tr>
    <tr><td class="paramname">Identifier</td><td>This is the identifier which associate the request to the response. </td></tr>
    <tr><td class="paramname">L2CAP_Length</td><td>Length of the L2CAP connection update request. </td></tr>
    <tr><td class="paramname">Interval_Min</td><td>Minimum value for the connection event interval. This shall be less than or equal to Conn_Interval_Max. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Interval_Max</td><td>Maximum value for the connection event interval. This shall be greater than or equal to Conn_Interval_Min. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Slave_Latency</td><td>Slave latency for the connection in number of connection events. Values:<ul>
<li>0x0000 ... 0x01F3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Timeout_Multiplier</td><td>Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms. Values:<ul>
<li>10 (100 ms) ... 3200 (32000 ms) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Handle of the connection related to this L2CAP procedure. </td></tr>
    <tr><td class="paramname">Identifier</td><td>This is the identifier which associates the request to the response. </td></tr>
    <tr><td class="paramname">L2CAP_Length</td><td>Length of the L2CAP connection update request. </td></tr>
    <tr><td class="paramname">Interval_Min</td><td>Minimum value for the connection event interval. This shall be less than or equal to Conn_Interval_Max. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Interval_Max</td><td>Maximum value for the connection event interval. This shall be greater than or equal to Conn_Interval_Min. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Slave_Latency</td><td>Slave latency for the connection in number of connection events. Values:<ul>
<li>0x0000 ... 0x01F3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Timeout_Multiplier</td><td>Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms. Values:<ul>
<li>10 (100 ms) ... 3200 (32000 ms) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fadd3fac1c528b6becb12f93666916a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fadd3fac1c528b6becb12f93666916a">&#9670;&nbsp;</a></span>aci_l2cap_connection_update_resp_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_l2cap_connection_update_resp_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when the master responds to the connection update request packet with a connection update response packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle referring to the COS Channel where the Disconnection has been received. </td></tr>
    <tr><td class="paramname">Result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad600ea8ba6ebf88f886803715ae5d515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad600ea8ba6ebf88f886803715ae5d515">&#9670;&nbsp;</a></span>aci_l2cap_proc_timeout_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_l2cap_proc_timeout_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when the master does not respond to the connection update request packet with a connection update response packet or a command reject packet within 30 seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Handle of the connection related to this L2CAP procedure. </td></tr>
    <tr><td class="paramname">Data_Length</td><td>Length of following data </td></tr>
    <tr><td class="paramname">Data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93d381695aef2b7a8b85d309a18176ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d381695aef2b7a8b85d309a18176ee">&#9670;&nbsp;</a></span>hci_data_buffer_overflow_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_data_buffer_overflow_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'This event is used to indicate that the Controller's data buffers have been overflowed. This can occur if the Host has sent more packets than allowed. The Link_Type parameter is used to indicate that the overflow was caused by ACL data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Link_Type</td><td>On wich type of channel overflow has occurred. Values:<ul>
<li>0x01: ACL Buffer Overflow </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Link_Type</td><td>On which type of channel overflow has occurred. Values:<ul>
<li>0x01: ACL Buffer Overflow </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2369482e556142d063d96633a030e8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2369482e556142d063d96633a030e8cd">&#9670;&nbsp;</a></span>hci_disconnection_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_disconnection_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Disconnection Complete event occurs when a connection is terminated. The status parameter indicates if the disconnection was successful or not. The reason parameter indicates the reason for the disconnection if the disconnection was successful. If the disconnection was not successful, the value of the reason parameter can be ignored by the Host. For example, this can be the case if the Host has issued the Disconnect command and there was a parameter error, or the command was not presently allowed, or a Connection_Handle that didn't correspond to a connection was given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Connection_Handle</td><td>Connection_Handle which was disconnected. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Reason</td><td>Reason for disconnection. See Error Codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0faa6b989d310e22cd46fdf0c8ab138d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0faa6b989d310e22cd46fdf0c8ab138d">&#9670;&nbsp;</a></span>hci_encryption_change_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_encryption_change_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Encryption Change event is used to indicate that the change of the encryption mode has been completed. The Connection_Handle will be a Connection_Handle for an ACL connection. The Encryption_Enabled event parameter specifies the new Encryption_Enabled parameter for the Connection_Handle specified by the Connection_Handle event parameter. This event will occur on both devices to notify the Hosts when Encryption has changed for the specified Connection_Handle between two devices. Note: This event shall not be generated if encryption is paused or resumed; during a role switch, for example. The meaning of the Encryption_Enabled parameter depends on whether the Host has indicated support for Secure Connections in the Secure_Connections_Host_Support parameter. When Secure_Connections_Host_Support is 'disabled' or the Connection_Handle refers to an LE link, the Controller shall only use Encryption_Enabled values 0x00 (OFF) and 0x01 (ON). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.8) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Encryption_Enabled</td><td>Link Level Encryption. Values:<ul>
<li>0x00: Link Level Encryption OFF</li>
<li>0x01: Link Level Encryption is ON with AES-CCM </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9c106b9812c2ebfeefb3eb5b8a92856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c106b9812c2ebfeefb3eb5b8a92856">&#9670;&nbsp;</a></span>hci_encryption_key_refresh_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_encryption_key_refresh_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'The Encryption Key Refresh Complete event is used to indicate to the Host that the encryption key was refreshed on the given Connection_Handle any time encryption is paused and then resumed. If the Encryption Key Refresh Complete event was generated due to an encryption pause and resume operation embedded within a change connection link key procedure, the Encryption Key Refresh Complete event shall be sent prior to the Change Connection Link Key Complete event. If the Encryption Key Refresh Complete event was generated due to an encryption pause and resume operation embedded within a role switch procedure, the Encryption Key Refresh Complete event shall be sent prior to the Role Change event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c911320c095086d11eb6ba23f2d6d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c911320c095086d11eb6ba23f2d6d18">&#9670;&nbsp;</a></span>hci_hardware_error_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_hardware_error_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Hardware Error event is used to indicate some implementation specific type of hardware failure for the controller. This event is used to notify the Host that a hardware failure has occurred in the Controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Hardware_Code</td><td>Hardware Error Event code. Error code 0x01 and 0x02 are errors generally caused by hardware issue on the PCB; another possible cause is a slow crystal startup. In the latter case, the HS_STARTUP_TIME in the device configuration needs to be tuned. Error code 0x03 indicates an internal error of the protocol stack. After this event is recommended to force device reset. Values:<ul>
<li>0x01: Radio state error</li>
<li>0x02: Timer overrun error</li>
<li>0x03: Internal queue overflow error </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Hardware_Code</td><td>Error code 0x01 and 0x02 are errors generally caused by hardware issue on the PCB; another possible cause is a slow crystal startup. In the latter case, the HS_STARTUP_TIME in the device configuration needs to be tuned. Error code 0x03 indicates an internal error of the protocol stack. This event with error code 0x04 is raised when a radio interrupt is served late. This usually happens when interrupts are disabled for too long time or when a flash operation is performed. Stack will try to recover the situation, so there is normally no need to reset the device. However this condition should be avoided as much as possible. Error code 0x05 is raised when an error happens during a TX transaction. After this event is received with error code 0x00, 0x01, 0x02 or 0x03, it is recommended to force a device reset. Values:<ul>
<li>0x00: Generic HW error</li>
<li>0x01: Radio state error</li>
<li>0x02: Timer overrun error</li>
<li>0x03: Internal queue overflow error</li>
<li>0x04: Late Radio ISR</li>
<li>0x05: TX Error </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad99f91727983bea5f3f202bd5f39b3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99f91727983bea5f3f202bd5f39b3b7">&#9670;&nbsp;</a></span>hci_le_advertising_report_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_advertising_report_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The LE Advertising Report event indicates that a Bluetooth device or multiple Bluetooth devices have responded to an active scan or received some information during a passive scan. The Controller may queue these advertising reports and send information from multiple devices in one LE Advertising Report event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Num_Reports</td><td>Number of responses in this event. Values:<ul>
<li>0x01 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Report</td><td>See <a class="el" href="group___h_c_i___l_e__meta__events.html#gaeaba192fd8b8a358e63295ac6ab370e9">Advertising_Report_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0930fb688df3373e0d0684ce32a9a2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0930fb688df3373e0d0684ce32a9a2b5">&#9670;&nbsp;</a></span>hci_le_connection_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_connection_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The LE Connection Complete event indicates to both of the Hosts forming the connection that a new connection has been created. Upon the creation of the connection a Connection_Handle shall be assigned by the Controller, and passed to the Host in this event. If the connection establishment fails this event shall be provided to the Host that had issued the LE_Create_Connection command. This event indicates to the Host which issued a LE_Create_Connection command and received a Command Status event if the connection establishment failed or was successful. The Master_Clock_Accuracy parameter is only valid for a slave. On a master, this parameter shall be set to 0x00. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle to be used to identify the connection with the peer device. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Role</td><td>Role of the local device in the connection. Values:<ul>
<li>0x00: Master</li>
<li>0x01: Slave </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address_Type</td><td>The address type of the peer device. Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address</td><td>Public Device Address or Random Device Address of the peer device </td></tr>
    <tr><td class="paramname">Conn_Interval</td><td>Connection interval used on this connection. Time = N * 1.25 msec Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Latency</td><td>Slave latency for the connection in number of connection events. Values:<ul>
<li>0x0000 ... 0x01F3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Supervision_Timeout</td><td>Supervision timeout for the LE Link. It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2. Time = N * 10 msec. Values:<ul>
<li>0x000A (100 ms) ... 0x0C80 (32000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Master_Clock_Accuracy</td><td>Master clock accuracy. Only valid for a slave. Values:<ul>
<li>0x00: 500 ppm</li>
<li>0x01: 250 ppm</li>
<li>0x02: 150 ppm</li>
<li>0x03: 100 ppm</li>
<li>0x04: 75 ppm</li>
<li>0x05: 50 ppm</li>
<li>0x06: 30 ppm</li>
<li>0x07: 20 ppm </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef68fd95518b65fccbe741aa84c8f5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef68fd95518b65fccbe741aa84c8f5ce">&#9670;&nbsp;</a></span>hci_le_connection_update_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_connection_update_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The LE Connection Update Complete event is used to indicate that the Controller process to update the connection has completed. On a slave, if no connection parameters are updated, then this event shall not be issued. On a master, this event shall be issued if the Connection_Update command was sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle to be used to identify the connection with the peer device. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Interval</td><td>Connection interval used on this connection. Time = N * 1.25 msec Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Latency</td><td>Slave latency for the connection in number of connection events. Values:<ul>
<li>0x0000 ... 0x01F3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Supervision_Timeout</td><td>Supervision timeout for the LE Link. It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2. Time = N * 10 msec. Values:<ul>
<li>0x000A (100 ms) ... 0x0C80 (32000 ms) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad84ae9335590a5c01faab11557990f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84ae9335590a5c01faab11557990f87">&#9670;&nbsp;</a></span>hci_le_data_length_change_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_data_length_change_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The LE Data Length Change event notifies the Host of a change to either the maximum Payload length or the maximum transmission time of Data Channel PDUs in either direction. The values reported are the maximum that will actually be used on the connection following the change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection_Handle to be used to identify a connection. </td></tr>
    <tr><td class="paramname">MaxTxOctets</td><td>The maximum number of payload octets in a Link Layer Data Channel PDU that the local Controller will send on this connection (connEffectiveMaxTxOctets defined in [Vol 6] Part B, Section 4.5.10). Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for future use) </td></tr>
    <tr><td class="paramname">MaxTxTime</td><td>The maximum time that the local Controller will take to send a Link Layer Data Channel PDU on this connection (connEffectiveMaxTx- Time defined in [Vol 6] Part B, Section 4.5.10). Range 0x0148-0x0848 (0x0000 - 0x0127 and 0x0849 - 0xFFFF Reserved for future use) </td></tr>
    <tr><td class="paramname">MaxRxOctets</td><td>The maximum number of payload octets in a Link Layer Data Channel PDU that the local controller expects to receive on this connection (connEfectiveMaxRxOctets defined in [Vol 6] Part B, Section 4.5.10). Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for future use) </td></tr>
    <tr><td class="paramname">MaxRxTime</td><td>The maximum time that the local Controller expects to take to receive a Link Layer Data Channel PDU on this connection (connEffectiveMax-RxTime defined in [Vol 6] Part B, Section 4.5.10). Range 0x0148-0x0848 (0x0000 - 0x0127 and 0x0849 - 0xFFFF Reserved for future use) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b21b3059cb9bad3b557e9dc1985e53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b21b3059cb9bad3b557e9dc1985e53f">&#9670;&nbsp;</a></span>hci_le_direct_advertising_report_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_direct_advertising_report_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The LE Direct Advertising Report event indicates that directed advertisements have been received where the advertiser is using a resolvable private address for the InitA field in the ADV_DIRECT_IND PDU and the Scanning_Filter_Policy is equal to 0x02 or 0x03, see HCI_LE_Set_Scan_Parameters. Direct_Address_Type and Direct_Addres is the address the directed advertisements are being directed to. Address_Type and Address is the address of the advertiser sending the directed advertisements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Num_Reports</td><td>Number of responses in this event. Values:<ul>
<li>0x01 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Direct_Advertising_Report</td><td>See <a class="el" href="group___h_c_i___l_e__meta__events.html#ga05beaefb4c0e6bdc639da516b4d58ed3">Direct_Advertising_Report_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14492afe9ee2c0c111b4403eabb3c45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14492afe9ee2c0c111b4403eabb3c45c">&#9670;&nbsp;</a></span>hci_le_enhanced_connection_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_enhanced_connection_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The LE Enhanced Connection Complete event indicates to both of the Hosts forming the connection that a new connection has been created. Upon the creation of the connection a Connection_Handle shall be assigned by the Controller, and passed to the Host in this event. If the connection establishment fails, this event shall be provided to the Host that had issued the LE_Create_Connection command. If this event is unmasked and LE Connection Complete event is unmasked, only the LE Enhanced Connection Complete event is sent when a new connection has been completed. This event indicates to the Host that issued a LE_Create_Connection command and received a Command Status event if the connection establishment failed or was successful. The Master_Clock_Accuracy parameter is only valid for a slave. On a master, this parameter shall be set to 0x00. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle to be used to identify the connection with the peer device. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Role</td><td>Role of the local device in the connection. Values:<ul>
<li>0x00: Master</li>
<li>0x01: Slave </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address_Type</td><td>0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity Address (Corresponds to Resolved Private Address) 0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Public Identity Address</li>
<li>0x03: Random (Static) Identity Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address</td><td>Public Device Address, Random Device Address, Public Identity Address or Random (static) Identity Address of the device to be connected. </td></tr>
    <tr><td class="paramname">Local_Resolvable_Private_Address</td><td>Resolvable Private Address being used by the local device for this connection. This is only valid when the Own_Address_Type is set to 0x02 or 0x03. For other Own_Address_Type values, the Controller shall return all zeros. </td></tr>
    <tr><td class="paramname">Peer_Resolvable_Private_Address</td><td>Resolvable Private Address being used by the peer device for this connection. This is only valid for Peer_Address_Type 0x02 and 0x03. For other Peer_Address_Type values, the Controller shall return all zeros. </td></tr>
    <tr><td class="paramname">Conn_Interval</td><td>Connection interval used on this connection. Time = N * 1.25 msec Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Latency</td><td>Slave latency for the connection in number of connection events. Values:<ul>
<li>0x0000 ... 0x01F3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Supervision_Timeout</td><td>Supervision timeout for the LE Link. It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2. Time = N * 10 msec. Values:<ul>
<li>0x000A (100 ms) ... 0x0C80 (32000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Master_Clock_Accuracy</td><td>Master clock accuracy. Only valid for a slave. Values:<ul>
<li>0x00: 500 ppm</li>
<li>0x01: 250 ppm</li>
<li>0x02: 150 ppm</li>
<li>0x03: 100 ppm</li>
<li>0x04: 75 ppm</li>
<li>0x05: 50 ppm</li>
<li>0x06: 30 ppm</li>
<li>0x07: 20 ppm </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac757ade1ef22b92ef429f28c18706f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac757ade1ef22b92ef429f28c18706f3c">&#9670;&nbsp;</a></span>hci_le_generate_dhkey_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_generate_dhkey_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event indicates that LE Diffie Hellman key generation has been completed by the Controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">DHKey</td><td>Diffie Hellman Key </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6a5b73fc583d0d2e76f0a766afa212c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a5b73fc583d0d2e76f0a766afa212c">&#9670;&nbsp;</a></span>hci_le_long_term_key_request_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_long_term_key_request_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The LE Long Term Key Request event indicates that the master device is attempting to encrypt or re-encrypt the link and is requesting the Long Term Key from the Host. (See [Vol 6] Part B, Section 5.1.3). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle to be used to identify the connection with the peer device. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Random_Number</td><td>64-bit random number </td></tr>
    <tr><td class="paramname">Encrypted_Diversifier</td><td>16-bit encrypted diversifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9deaff03cdbeaf4a28122c57b2fc6ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9deaff03cdbeaf4a28122c57b2fc6ee0">&#9670;&nbsp;</a></span>hci_le_read_local_p256_public_key_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_read_local_p256_public_key_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is generated when local P-256 key generation is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Local_P256_Public_Key</td><td>Local P-256 public key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a420e0e1bbf2b924b2c4cbb96a3902797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420e0e1bbf2b924b2c4cbb96a3902797">&#9670;&nbsp;</a></span>hci_le_read_remote_used_features_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_le_read_remote_used_features_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The LE Read Remote Used Features Complete event is used to indicate the completion of the process of the Controller obtaining the used features of the remote Bluetooth device specified by the Connection_Handle event parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle to be used to identify the connection with the peer device. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Features</td><td>Bit Mask List of used LE features. For details see LE Link Layer specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a806a75f6cb0ae6accfaefaed6a74c132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806a75f6cb0ae6accfaefaed6a74c132">&#9670;&nbsp;</a></span>hci_number_of_completed_packets_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_number_of_completed_packets_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'The Number Of Completed Packets event is used by the Controller to indicate to the Host how many HCI Data Packets have been completed (transmitted or flushed) for each Connection_Handle since the previous Number Of Completed Packets event was sent to the Host. This means that the corresponding buffer space has been freed in the Controller. Based on this information, and the HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_- Data_Packets return parameter of the Read_Buffer_Size command, the Host can determine for which Connection_Handles the following HCI Data Packets should be sent to the Controller. The Number Of Completed Packets event must not be sent before the corresponding Connection Complete event. While the Controller has HCI data packets in its buffer, it must keep sending the Number Of Completed Packets event to the Host at least periodically, until it finally reports that all the pending ACL Data Packets have been transmitted or flushed. </p>
<p>The Number Of Completed Packets event is used by the Controller to indicate to the Host how many HCI Data Packets have been completed (transmitted or flushed) for each Connection_Handle since the previous Number Of Completed Packets event was sent to the Host. This means that the corresponding buffer space has been freed in the Controller. Based on this information, and the HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_- Data_Packets return parameter of the Read_Buffer_Size command, the Host can determine for which Connection_Handles the following HCI Data Packets should be sent to the Controller. The Number Of Completed Packets event must not be sent before the corresponding Connection Complete event. While the Controller has HCI data packets in its buffer, it must keep sending the Number Of Completed Packets event to the Host at least periodically, until it finally reports that all the pending ACL Data Packets have been transmitted or flushed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Number_of_Handles</td><td>The number of Connection_Handles and Num_HCI_Data_Packets parameters pairs contained in this event </td></tr>
    <tr><td class="paramname">Handle_Packets_Pair_Entry</td><td>See <a class="el" href="group___h_c_i__events.html#ga16150a7d63b2a57db32fa49bf6824d78">Handle_Packets_Pair_Entry_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72922573641c68b7a6003089a4e0c206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72922573641c68b7a6003089a4e0c206">&#9670;&nbsp;</a></span>hci_read_remote_version_information_complete_event_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus hci_read_remote_version_information_complete_event_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Read Remote Version Information Complete event is used to indicate the completion of the process obtaining the version information of the remote Controller specified by the Connection_Handle event parameter. The Connection_Handle shall be for an ACL connection. The Version event parameter defines the specification version of the LE Controller. The Manufacturer_Name event parameter indicates the manufacturer of the remote Controller. The Subversion event parameter is controlled by the manufacturer and is implementation dependent. The Subversion event parameter defines the various revisions that each version of the Bluetooth hardware will go through as design processes change and errors are fixed. This allows the software to determine what Bluetooth hardware is being used and, if necessary, to work around various bugs in the hardware. When the Connection_Handle is associated with an LE-U logical link, the Version event parameter shall be Link Layer VersNr parameter, the Manufacturer_Name event parameter shall be the CompId parameter, and the Subversion event parameter shall be the SubVersNr parameter. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.12) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>For standard error codes see Bluetooth specification, Vol. 2, part D. For proprietary error code refer to Error codes section </td></tr>
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Version</td><td>Version of the Current LMP in the remote Controller </td></tr>
    <tr><td class="paramname">Manufacturer_Name</td><td>Manufacturer Name of the remote Controller </td></tr>
    <tr><td class="paramname">Subversion</td><td>Subversion of the LMP in the remote Controller </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a17ca214cb7bd63535339e13d01f644d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ca214cb7bd63535339e13d01f644d8">&#9670;&nbsp;</a></span>hci_events_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structhci__command__table__type__s.html">hci_events_table_type</a> hci_events_table[7]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">{</div>
<div class="line">  </div>
<div class="line">  {0x0005, <a class="code" href="bluenrg1__events_8c.html#a2369482e556142d063d96633a030e8cd">hci_disconnection_complete_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0008, <a class="code" href="bluenrg1__events_8c.html#a0faa6b989d310e22cd46fdf0c8ab138d">hci_encryption_change_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x000c, <a class="code" href="bluenrg1__events_8c.html#a72922573641c68b7a6003089a4e0c206">hci_read_remote_version_information_complete_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0010, <a class="code" href="bluenrg1__events_8c.html#a0c911320c095086d11eb6ba23f2d6d18">hci_hardware_error_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0013, <a class="code" href="bluenrg1__events_8c.html#a806a75f6cb0ae6accfaefaed6a74c132">hci_number_of_completed_packets_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x001a, <a class="code" href="bluenrg1__events_8c.html#a93d381695aef2b7a8b85d309a18176ee">hci_data_buffer_overflow_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0030, <a class="code" href="bluenrg1__events_8c.html#ae9c106b9812c2ebfeefb3eb5b8a92856">hci_encryption_key_refresh_complete_event_process</a>}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a14e16f66ac2f5a573ea8b995c00b3395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e16f66ac2f5a573ea8b995c00b3395">&#9670;&nbsp;</a></span>hci_le_meta_events_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structhci__command__table__type__s.html">hci_le_meta_events_table_type</a> hci_le_meta_events_table[10]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">{</div>
<div class="line">  </div>
<div class="line">  {0x0001, <a class="code" href="bluenrg1__events_8c.html#a0930fb688df3373e0d0684ce32a9a2b5">hci_le_connection_complete_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0002, <a class="code" href="bluenrg1__events_8c.html#ad99f91727983bea5f3f202bd5f39b3b7">hci_le_advertising_report_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0003, <a class="code" href="bluenrg1__events_8c.html#aef68fd95518b65fccbe741aa84c8f5ce">hci_le_connection_update_complete_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0004, <a class="code" href="bluenrg1__events_8c.html#a420e0e1bbf2b924b2c4cbb96a3902797">hci_le_read_remote_used_features_complete_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0005, <a class="code" href="bluenrg1__events_8c.html#ab6a5b73fc583d0d2e76f0a766afa212c">hci_le_long_term_key_request_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0007, <a class="code" href="bluenrg1__events_8c.html#ad84ae9335590a5c01faab11557990f87">hci_le_data_length_change_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0008, <a class="code" href="bluenrg1__events_8c.html#a9deaff03cdbeaf4a28122c57b2fc6ee0">hci_le_read_local_p256_public_key_complete_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x0009, <a class="code" href="bluenrg1__events_8c.html#ac757ade1ef22b92ef429f28c18706f3c">hci_le_generate_dhkey_complete_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x000a, <a class="code" href="bluenrg1__events_8c.html#a14492afe9ee2c0c111b4403eabb3c45c">hci_le_enhanced_connection_complete_event_process</a>},</div>
<div class="line">  </div>
<div class="line">  {0x000b, <a class="code" href="bluenrg1__events_8c.html#a2b21b3059cb9bad3b557e9dc1985e53f">hci_le_direct_advertising_report_event_process</a>}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<div class="ttc" id="abluenrg1__events_8c_html_a0faa6b989d310e22cd46fdf0c8ab138d"><div class="ttname"><a href="bluenrg1__events_8c.html#a0faa6b989d310e22cd46fdf0c8ab138d">hci_encryption_change_event_process</a></div><div class="ttdeci">tBleStatus hci_encryption_change_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The Encryption Change event is used to indicate that the change of the encryption mode has been compl...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:274</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a72922573641c68b7a6003089a4e0c206"><div class="ttname"><a href="bluenrg1__events_8c.html#a72922573641c68b7a6003089a4e0c206">hci_read_remote_version_information_complete_event_process</a></div><div class="ttdeci">tBleStatus hci_read_remote_version_information_complete_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The Read Remote Version Information Complete event is used to indicate the completion of the process ...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:317</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_ae9c106b9812c2ebfeefb3eb5b8a92856"><div class="ttname"><a href="bluenrg1__events_8c.html#ae9c106b9812c2ebfeefb3eb5b8a92856">hci_encryption_key_refresh_complete_event_process</a></div><div class="ttdeci">tBleStatus hci_encryption_key_refresh_complete_event_process(uint8_t *buffer_in)</div><div class="ttdoc">'The Encryption Key Refresh Complete event is used to indicate to the Host that the encryption key wa...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:447</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a2369482e556142d063d96633a030e8cd"><div class="ttname"><a href="bluenrg1__events_8c.html#a2369482e556142d063d96633a030e8cd">hci_disconnection_complete_event_process</a></div><div class="ttdeci">tBleStatus hci_disconnection_complete_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The Disconnection Complete event occurs when a connection is terminated. The status parameter indicat...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:232</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_ad84ae9335590a5c01faab11557990f87"><div class="ttname"><a href="bluenrg1__events_8c.html#ad84ae9335590a5c01faab11557990f87">hci_le_data_length_change_event_process</a></div><div class="ttdeci">tBleStatus hci_le_data_length_change_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The LE Data Length Change event notifies the Host of a change to either the maximum Payload length or...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:1991</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_ac757ade1ef22b92ef429f28c18706f3c"><div class="ttname"><a href="bluenrg1__events_8c.html#ac757ade1ef22b92ef429f28c18706f3c">hci_le_generate_dhkey_complete_event_process</a></div><div class="ttdeci">tBleStatus hci_le_generate_dhkey_complete_event_process(uint8_t *buffer_in)</div><div class="ttdoc">This event indicates that LE Diffie Hellman key generation has been completed by the Controller.</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:2035</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a420e0e1bbf2b924b2c4cbb96a3902797"><div class="ttname"><a href="bluenrg1__events_8c.html#a420e0e1bbf2b924b2c4cbb96a3902797">hci_le_read_remote_used_features_complete_event_process</a></div><div class="ttdeci">tBleStatus hci_le_read_remote_used_features_complete_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The LE Read Remote Used Features Complete event is used to indicate the completion of the process of ...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:1922</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a9deaff03cdbeaf4a28122c57b2fc6ee0"><div class="ttname"><a href="bluenrg1__events_8c.html#a9deaff03cdbeaf4a28122c57b2fc6ee0">hci_le_read_local_p256_public_key_complete_event_process</a></div><div class="ttdeci">tBleStatus hci_le_read_local_p256_public_key_complete_event_process(uint8_t *buffer_in)</div><div class="ttdoc">This event is generated when local P-256 key generation is complete.</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:2014</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a0c911320c095086d11eb6ba23f2d6d18"><div class="ttname"><a href="bluenrg1__events_8c.html#a0c911320c095086d11eb6ba23f2d6d18">hci_hardware_error_event_process</a></div><div class="ttdeci">tBleStatus hci_hardware_error_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The Hardware Error event is used to indicate some implementation specific type of hardware failure fo...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:350</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_ad99f91727983bea5f3f202bd5f39b3b7"><div class="ttname"><a href="bluenrg1__events_8c.html#ad99f91727983bea5f3f202bd5f39b3b7">hci_le_advertising_report_event_process</a></div><div class="ttdeci">tBleStatus hci_le_advertising_report_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The LE Advertising Report event indicates that a Bluetooth device or multiple Bluetooth devices have ...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:1833</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a93d381695aef2b7a8b85d309a18176ee"><div class="ttname"><a href="bluenrg1__events_8c.html#a93d381695aef2b7a8b85d309a18176ee">hci_data_buffer_overflow_event_process</a></div><div class="ttdeci">tBleStatus hci_data_buffer_overflow_event_process(uint8_t *buffer_in)</div><div class="ttdoc">'This event is used to indicate that the Controller's data buffers have been overflowed....</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:416</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_ab6a5b73fc583d0d2e76f0a766afa212c"><div class="ttname"><a href="bluenrg1__events_8c.html#ab6a5b73fc583d0d2e76f0a766afa212c">hci_le_long_term_key_request_event_process</a></div><div class="ttdeci">tBleStatus hci_le_long_term_key_request_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The LE Long Term Key Request event indicates that the master device is attempting to encrypt or re-en...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:1948</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_aef68fd95518b65fccbe741aa84c8f5ce"><div class="ttname"><a href="bluenrg1__events_8c.html#aef68fd95518b65fccbe741aa84c8f5ce">hci_le_connection_update_complete_event_process</a></div><div class="ttdeci">tBleStatus hci_le_connection_update_complete_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The LE Connection Update Complete event is used to indicate that the Controller process to update the...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:1891</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a14492afe9ee2c0c111b4403eabb3c45c"><div class="ttname"><a href="bluenrg1__events_8c.html#a14492afe9ee2c0c111b4403eabb3c45c">hci_le_enhanced_connection_complete_event_process</a></div><div class="ttdeci">tBleStatus hci_le_enhanced_connection_complete_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The LE Enhanced Connection Complete event indicates to both of the Hosts forming the connection that ...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:2117</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a2b21b3059cb9bad3b557e9dc1985e53f"><div class="ttname"><a href="bluenrg1__events_8c.html#a2b21b3059cb9bad3b557e9dc1985e53f">hci_le_direct_advertising_report_event_process</a></div><div class="ttdeci">tBleStatus hci_le_direct_advertising_report_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The LE Direct Advertising Report event indicates that directed advertisements have been received wher...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:2154</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a806a75f6cb0ae6accfaefaed6a74c132"><div class="ttname"><a href="bluenrg1__events_8c.html#a806a75f6cb0ae6accfaefaed6a74c132">hci_number_of_completed_packets_event_process</a></div><div class="ttdeci">tBleStatus hci_number_of_completed_packets_event_process(uint8_t *buffer_in)</div><div class="ttdoc">'The Number Of Completed Packets event is used by the Controller to indicate to the Host how many HCI...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:383</div></div>
<div class="ttc" id="abluenrg1__events_8c_html_a0930fb688df3373e0d0684ce32a9a2b5"><div class="ttname"><a href="bluenrg1__events_8c.html#a0930fb688df3373e0d0684ce32a9a2b5">hci_le_connection_complete_event_process</a></div><div class="ttdeci">tBleStatus hci_le_connection_complete_event_process(uint8_t *buffer_in)</div><div class="ttdoc">The LE Connection Complete event indicates to both of the Hosts forming the connection that a new con...</div><div class="ttdef"><b>Definition:</b> bluenrg1_events.c:1801</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 3 2023 17:27:27 for FP-SNS-DATALOG2 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
