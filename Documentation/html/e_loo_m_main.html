<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FP-SNS-DATALOG2: eLooM framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FP-SNS-DATALOG2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">eLooM framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#eloom_overview">Overview</a><ul><li class="level2"><a href="#eloom_fw_architecture_sec">Firmware architecture</a></li>
</ul>
</li>
<li class="level1"><a href="#eloom_sys_init">System initialization</a><ul><li class="level2"><a href="#eloom_applicatrion_context">The Application Context</a></li>
<li class="level2"><a href="#eloom_task_hw_init">Task&#39;s hardware initialization</a></li>
<li class="level2"><a href="#eloom_task_sw_init">Task creation and software resources initialization.</a></li>
<li class="level2"><a href="#eloom_app_init">Other application specific initialization</a></li>
<li class="level2"><a href="#eloom_init_command_loop">INIT task command loop</a></li>
</ul>
</li>
<li class="level1"><a href="#eloom_power_management">Power Management</a><ul><li class="level2"><a href="#eloom_power_mode_implementation">Power Mode switch implementation</a></li>
<li class="level2"><a href="#eloom_power_mode_pmclass">Managed task classification during the PM transaction</a></li>
<li class="level2"><a href="#eloom_power_mode_other">Other considerations on the low power mode</a></li>
</ul>
</li>
<li class="level1"><a href="#eloom_error_simple">Error Management</a><ul><li class="level2"><a href="#error_generic">Simple support</a></li>
<li class="level2"><a href="#eloom_error_advanced">Advanced support</a></li>
<li class="level2"><a href="#eloom_error_wwdg">AppErrorManager and the WWDG</a></li>
</ul>
</li>
<li class="level1"><a href="#eloom_cube_integration">eLooM and STM32Cube</a><ul><li class="level2"><a href="#eloom_cube_mx">How to use STM32CubeMX in the eLooM development workflow</a></li>
<li class="level2"><a href="#eloom_cube_irq">eLooM objects and STM32 HAL callbacks</a></li>
</ul>
</li>
<li class="level1"><a href="#eloom_rtos">Support for different RTOS</a><ul><li class="level2"><a href="#eloom_basesrv">eLooM base services</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="eloom_overview"></a>
Overview</h1>
<p>The framework as been designed for embedded low power applications powered by STM32 with the purpose of:</p><ul>
<li>To make the firmware modular and easy to reuse. This improve the time to market.</li>
<li>To optimize the tradeoff between memory footprint and performance.</li>
<li>To let the developer focus on his application.</li>
<li>To answer the question "how to do, with STM32?".</li>
</ul>
<p>The design started with the analysis of many embedded applications. We can image the firmware as a set of concurrent tasks, where each task uses one or more services that, in turn, use one or more drivers. In this way a task export one or more features of the application.</p>
<p><a class="anchor" id="eloom_fig20"></a></p><div class="image">
<img src="20_embedded_app.png" alt="" width="400px"/>
<div class="caption">
Fig.20 - Anatomy of an embedded application</div></div>
<p>The above image leads us to the final idea: the framework manages a set of tasks (we called it <b>Managed Task</b>) defined by the application, in order to implements the following features:</p><ul>
<li>System initialization: at startup the system initializes all hardware resources as well as the software ones used by the Managed Tasks.</li>
<li>Power management: the system coordinates the Managed Tasks to switch from a state to the other of a Power Mode State Machine defined by the application.</li>
<li>Error management: the system handle the errors reported by a Managed Task and it checks that all Managed Tasks are working fine.</li>
</ul>
<h2><a class="anchor" id="eloom_fw_architecture_sec"></a>
Firmware architecture</h2>
<p>We focused on a design pattern that allow us to split the generic algorithms, that we need to implement the features described in the previous section, from the application specific data. This is done by introducing a special task, the <b>INIT</b> task, that is the first task to start and the one with the highest priority. It interacts with three other objects as displayed in <a class="el" href="e_loo_m_main.html#eloom_fig21">Fig.21</a>:</p>
<p><a class="anchor" id="eloom_fig21"></a></p><div class="image">
<img src="21_fw_architecture_idea.png" alt=""/>
<div class="caption">
Fig.21 - INIT task diagram</div></div>
<ul>
<li>The <a class="el" href="_application_context_8h.html#a7592228ea4590b51b4fce8ecc5a66b93">ApplicationContext</a> is a set of <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a>. The INIT task uses the <a class="el" href="_application_context_8h.html#a7592228ea4590b51b4fce8ecc5a66b93">ApplicationContext</a> in order to be aware of the system functionality, to initialize the system and to provides support during a transaction in the Power Mode State Machine.</li>
<li>The <a class="el" href="_i_application_error_delegate_8h.html#a105ef6c94544adf17ae430dd98a75312">IApplicationErrorDelegate</a> (IAED) defines an interface for the error management. The application can implement this interface, and in this case the INIT task delegates the error management to this application defined object (the Application Error Manager or <b>AEM</b>). This means that it forwards all error events to the AEM. For more information see the section <a class="el" href="e_loo_m_main.html#eloom_error_simple">Error Management</a>.</li>
<li>The <a class="el" href="_i_app_power_mode_helper_8h.html#af5ed379247d45f94120092b40ed6b0c9">IAppPowerModeHelper</a> defines an interface for the Power Mode transaction. If the application does not implement this interface, then the framework instantiates a default implementation (<a class="el" href="_sys_def_power_mode_helper_8h.html#ab6f96f63d2ff9615a5413e4125ee5a94">SysDefPowerModeHelper</a>). In this way there is always a power mode helper object (<b>APMH</b>).</li>
</ul>
<p>This three objects are grouped together in a private structure of type <a class="el" href="sysinit_8c.html#a783b807f4eaea763c7395e8e16d1b29d">System</a> and there is only one instance - <a class="el" href="sysinit_8c.html#ad28577ec9f62dc024643e33df83858cb">s_xTheSystem</a> - that is not directly accessible by the application.</p>
<p>While this is a very important part of the framework, <a class="el" href="e_loo_m_main.html#eloom_fig01">Fig.1</a> displays the whole firmware architecture: a soft real-time multitasking system designed in multiple layers.</p>
<p><a class="anchor" id="eloom_fig01"></a></p><div class="image">
<img src="1_fw_architecture.png" alt="" width="900px"/>
<div class="caption">
Fig.1 - Firmware architecture</div></div>
<h1><a class="anchor" id="eloom_sys_init"></a>
System initialization</h1>
<p>After the reset the system must be initialized in order to perform the normal operation. This is done in different steps. At the beginning the <a class="el" href="sysinit_8h.html#ac3b910fc43881c8992a62ea38736a8e6">SysInit()</a> is executed. This function is in charge of to perform the early initialization of the hardware:</p><ul>
<li>Initialize the Flash interface</li>
<li>Initialize the clock three</li>
<li>Initialize the clock used by the STM32 HAL (by default set to 1ms)</li>
<li>Configure all PINs in analog mode in order to reduce the power consumption - <a class="el" href="sysinit_8c.html#a1f7982c3a6d9ac68ca031c7449b6fd51" title="Power Configuration.">SystemPower_Config()</a>. The PINs used by the application will be configured later by the application tasks.</li>
<li>Initialize the basic error subsystem.</li>
<li>If the application supports the BOOT IF, then system check if it requires a jump to another application otherwise it proceeds with the normal initialization.</li>
<li>Create the INIT task</li>
</ul>
<p>Part of this initialization code is provided by the standard functions HAL_Init() and <a class="el" href="sysinit_8c.html#a70af21c671abfcc773614a9a4f63d920" title="System Clock Configuration.">SystemClock_Config()</a>. At this point the scheduler (FreeRTOS or ThreadX) is started and the control pass to the INIT task that is, with the IDLE task and the Timer Service Daemon task, the only available task and the one with the highest priority. The INIT task is in charge of to complete the system initialization before entering its commands loop.</p>
<h2><a class="anchor" id="eloom_applicatrion_context"></a>
The Application Context</h2>
<p>A multitasking system is defined by one or more user defined application tasks that implement the application features. The framework abstracts this concept in the <a class="el" href="_application_context_8h.html#a7592228ea4590b51b4fce8ecc5a66b93">ApplicationContext</a> class, that is a set of task objects implementing the <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a> abstract class or one of the its subclass. Each application task must implements the the <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a> interface, and so it defines a common API between the application tasks and the system. It is through this interface that the INIT task manages the application tasks.</p>
<p>Before allocating the <a class="el" href="_application_context_8h.html#a7592228ea4590b51b4fce8ecc5a66b93">ApplicationContext</a>, the INIT task allocate and initialize the other two objects (see <a class="el" href="e_loo_m_main.html#eloom_fig21">Fig.21</a>), the Application Power Mode Helper and the Application Error Delegate. in this way the Managed Tasks can use all the services provided by by the framework.</p>
<p>The INIT task allocates the <a class="el" href="_application_context_8h.html#a7592228ea4590b51b4fce8ecc5a66b93">ApplicationContext</a> and then it calls the <a class="el" href="sysinit_8h.html#ae4794131d796c57eeb711511870325b4">SysLoadApplicationContext()</a> function to allows the application to add the its Managed Tasks to the <a class="el" href="_application_context_8h.html#a7592228ea4590b51b4fce8ecc5a66b93">ApplicationContext</a>. This function is defined as <code>weak</code> in the framework and the application must define its own implementation. In a typical example this function is defined in the App.c file.</p>
<h2><a class="anchor" id="eloom_task_hw_init"></a>
Task's hardware initialization</h2>
<p>After the <a class="el" href="sysinit_8h.html#ae4794131d796c57eeb711511870325b4">SysLoadApplicationContext()</a> is executed the INIT task is aware of all application tasks and it can continue with the system initialization. The next step is to complete the hardware initialization. For each <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a> the INIT task calls the <a class="el" href="_a_managed_task__vtbl_8h.html#acdeb2880befe6dabbadda75fe249ba2d">AMTHardwareInit()</a> function. This function is overloaded and used by an application task object in order to initialize the task specific hardware.</p>
<p>At this moment the hardware of the MCU is initialized, all the peripherals are ready to be used, but usually they are not started yet. This will be done later in the application task control loop or in the <a class="el" href="_a_managed_task__vtbl_8h.html#adee054d10151e6e701446db9ef2f71d8">AMTOnEnterTaskControlLoop()</a> function, after the task creation.</p>
<h2><a class="anchor" id="eloom_task_sw_init"></a>
Task creation and software resources initialization.</h2>
<p>The next step in the initialization process is to create and initialize the software resources used by the application tasks. Once again the INIT task iterates between the <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a> and it calls the function <a class="el" href="_a_managed_task__vtbl_8h.html#a5b9496501cafa6f22080fecbd8be8c88">AMTOnCreateTask()</a>. This function is overloaded and used by an application task object in order to initialize the task specific software resources and to provide to the INIT task all the parameters needed to instantiate a native RTOS task. These parameters include:</p><ul>
<li>The task control loop function.</li>
<li>The task name: a string to identify the task in a RTOS aware debugger.</li>
<li>The task stack depth expressed in WORD (32 bit).</li>
<li>Optional task's parameters.</li>
<li>The task priority.</li>
</ul>
<h2><a class="anchor" id="eloom_app_init"></a>
Other application specific initialization</h2>
<p>At this point the system is almost initialized and ready to run: all the drivers are initialized, all the application task objects are ready. Before giving the control to the application tasks, the INIT task calls the <code>weak</code> function <a class="el" href="sysinit_8h.html#aa78cf2180b6deac337e5b038455a66d4">SysOnStartApplication()</a>. This optional function can be defined by the application in order to make other initialization stuff after all application task objects have been initialized, and before the system runs. This process is displayed in the sequence diagram of <a class="el" href="e_loo_m_main.html#eloom_fig02">Fig.2</a>.</p>
<p><a class="anchor" id="eloom_fig02"></a></p><div class="image">
<img src="2_system_init_diagram.png" alt="" width="1000px"/>
<div class="caption">
Fig.2 - System Initialization sequence diagram</div></div>
<p>Note: the startup process described in this section is, usually, done in few ms.</p>
<h2><a class="anchor" id="eloom_init_command_loop"></a>
INIT task command loop</h2>
<p>After the system initialization is done, the INIT task gives the control to the application tasks, and it enters a command loop. In this loop the INIT task is suspended waiting for a system command invoked by other tasks or Interrupt Service Routine (ISR). An example of system command is the power management command that can be used by the application through the <a class="el" href="syslowpower_8h.html#acef8e54332eaec8d36babd180fe8c5a2">SysPostPowerModeEvent()</a> function. This function sends a power mode event to the INIT task. The INIT task manages the event, and in case it does switch the system to a different power mode. Another type of command is the error command. The application uses the function <a class="el" href="syserror_8h.html#ad84c4110eef1b8d73a6ce9ee53382b92">SysPostErrorEvent()</a> to notify the system when an error occurs. We will see later that the error management is done in two steps, the error notification first, and then the error recovery.</p>
<p>It is important to note that, while the framework defines the API and the syntax of a <a class="el" href="sysevent_8h.html#a39607b2b3e92a9bf584ee36bae1e2182">SysEvent</a>, the actual value of the event is defined by the application. This design choice, used also for the power mode state machine implementation, gives flexibility because each application has its own characteristics.</p>
<h1><a class="anchor" id="eloom_power_management"></a>
Power Management</h1>
<p>A low power application should take advantage of many way to reduce the power consumption thanks to the STM32 low power mode. The main idea is to put the MCU core in low power mode and to stop the peripherals clock as soon as possible.</p>
<p>But every application has its own characteristics and different requirements, and this can be modeled using a state machine where:</p><ul>
<li>Each state (Power Mode State) describes a particular configuration of the system (the MCU state, which features are enabled, etc.)</li>
<li>Each transaction represents the event (<a class="el" href="sysevent_8h.html#a39607b2b3e92a9bf584ee36bae1e2182">SysEvent</a>) that triggers the transaction.</li>
</ul>
<p>To implement the power mode state machine, the INIT task interacts with the application provided Power Mode Helper object, that implements the <a class="el" href="_i_app_power_mode_helper_8h.html#af5ed379247d45f94120092b40ed6b0c9">IAppPowerModeHelper</a> interface.</p>
<p>The framework provides a default implementation of the Power Mode Helper interface that is the <a class="el" href="_sys_def_power_mode_helper_8h.html#ab6f96f63d2ff9615a5413e4125ee5a94">SysDefPowerModeHelper</a>. The application can provides its own object by defining the <code>weak</code> function <a class="el" href="sysinit_8h.html#a8ff2e6d7d60241839935aeb38d797a28">SysGetPowerModeHelper()</a>. The default implementation defines a state machine with 2 states RUN and SLEEP_1. It is displayed in <a class="el" href="e_loo_m_main.html#eloom_fig05">Fig.5</a> with the possible transactions, the events that trigger each transaction, and the power policy of each state.</p>
<p><a class="anchor" id="eloom_fig05"></a></p><div class="image">
<img src="5_pwr_management_1.png" alt=""/>
<div class="caption">
Fig.5 - Power Mode state machine</div></div>
<p>In <b>SLEEP_1</b> mode the power consumption is reduced thanks to the following actions:</p><ul>
<li>The MCU is in STOP2 (when available in the STM32 MCU).</li>
</ul>
<h2><a class="anchor" id="eloom_power_mode_implementation"></a>
Power Mode switch implementation</h2>
<p>Before entering a power mode all application tasks must be in a safe state: for example all driver operations should be completed, a task should complete one step of its control loop, etc. This is a three steps process as displayed in <a class="el" href="e_loo_m_main.html#eloom_fig12">Fig.12</a>:</p><ol type="1">
<li>Step 1: a T0 time a task signals an asynchronous event to the system through the <a class="el" href="syslowpower_8h.html#acef8e54332eaec8d36babd180fe8c5a2">SysPostPowerModeEvent()</a> function.</li>
<li>Step 2: a T1 time the INIT task works with the APMH to process the event and, if a power mode change is needed then it notifies the application tasks to be ready for the new power mode (<a class="el" href="_a_managed_task__vtbl_8h.html#a73cd3383558a964f9bbbf96f84500ffb">AMTDoEnterPowerMode()</a>). In this step the INIT task and the abstract class <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a> hide the complexity of the protocol implementation, so the developer can focus to just reconfigure a managed task and its resources for the new power mode.</li>
<li>Step 3: a T2 time the system resumes the execution in the new power mode.</li>
</ol>
<p><a class="anchor" id="eloom_fig12"></a></p><div class="image">
<img src="12_pwr_management_4.jpg" alt="" width="800px"/>
<div class="caption">
Fig.12 - Three steps process</div></div>
<p>As discussed in the section <a class="el" href="e_loo_m_main.html#eloom_init_command_loop">INIT task command loop</a> the INIT task is responsible to put the system in a specified power mode. When it receives a power mode related <a class="el" href="sysevent_8h.html#a39607b2b3e92a9bf584ee36bae1e2182">SysEvent</a> it takes the control over the system. The first step is to check with the APMH if a power mode transaction is needed. Two virtual function defined by the APMH are used:</p><ul>
<li><a class="el" href="_i_app_power_mode_helper__vtbl_8h.html#a3f23752db4a8f57d2ea2c2cbe8a80236">IapmhComputeNewPowerMode()</a></li>
<li><a class="el" href="_i_app_power_mode_helper__vtbl_8h.html#aed22757edc273df917beda28c9421efc">IapmhCheckPowerModeTransaction()</a></li>
</ul>
<p>In case the INIT task starts the transaction to a new power mode, it first notifies the <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a> that a new transaction is going to start by calling the virtual function <a class="el" href="_a_managed_task_ex__vtbl_8h.html#a176724874ae88d18d80425955e78bc39">AMTExOnEnterPowerMode()</a>. By overriding this method an application managed task can perform some action just before there transaction start. Normally these actions should be very short in order to keep the overall execution time of the power mode transaction as short as possible. As consequence, the system will feel more responsive.</p>
<p>Then the INIT task signals the application tasks the beginning of the power mode transaction by setting the <code>nPowerModeSwitchPending</code> bit of the task <a class="el" href="struct___a_managed_task.html#aa9919cc80e72e84beb33c83062a4da55">AManagedTask::m_xStatus</a> flag, then it forwards the request to the application tasks using the <a class="el" href="_a_managed_task__vtbl_8h.html#a73cd3383558a964f9bbbf96f84500ffb">AMTDoEnterPowerMode()</a> function, after checking the <code>nDelayPowerModeSwitch</code> of the <a class="el" href="struct___a_managed_task.html#aa9919cc80e72e84beb33c83062a4da55">AManagedTask::m_xStatus</a> flag. This flag is set by an application task to delay the power mode switch. It is responsibility of the <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a> to check the <code>nPowerModeSwitchPending</code> bit of the <a class="el" href="struct___a_managed_task.html#aa9919cc80e72e84beb33c83062a4da55">AManagedTask::m_xStatus</a> flag and reset the <code>nDelayPowerModeSwitch</code> bit when it has finished the current operation. This is implemented in the default control loop <a class="el" href="_a_managed_task_8h.html#a2166998aa548db9ee66dc0b86e46813a">AMTRun()</a>. Note that a managed task subclass does not need to worry about this implementation of the PM transaction, but it can focus on its own logic to reconfigure itself and, eventually, its low level driver by overriding the <a class="el" href="_a_managed_task__vtbl_8h.html#a73cd3383558a964f9bbbf96f84500ffb">AMTDoEnterPowerMode()</a>. The framework will call that entry point at the right moment. The behavior of the INIT task is summarized in the following flow chart.</p>
<p><a class="anchor" id="eloom_fig07"></a></p><div class="image">
<img src="7_pwr_management_2.png" alt=""/>
<div class="caption">
Fig.7</div></div>
<p>The control loop of the application tasks has to be implemented by taking into account the power management requirement of the system. Each task must contribute to the power efficiency of the system. The flow chart in <a class="el" href="e_loo_m_main.html#eloom_fig08">Fig.8</a> display a generic implementation.</p>
<p><a class="anchor" id="eloom_fig08"></a></p><div class="image">
<img src="8_pwr_management_3.png" alt=""/>
<div class="caption">
Fig.8</div></div>
<p>At the beginning of the control loop, the task checks if there is a power mode switch pending request (<a class="el" href="struct___a_managed_task.html#aa9919cc80e72e84beb33c83062a4da55">AManagedTask::m_xStatus</a> <code>nPowerModeSwitchPending</code>). In this case the task resets its power mode delay switch bit (<a class="el" href="struct___a_managed_task.html#aa9919cc80e72e84beb33c83062a4da55">AManagedTask::m_xStatus</a> <code>nDelayPowerModeSwitch</code>) and it suspends itself waiting for the INIT task to complete the power mode switch. Otherwise (<a class="el" href="struct___a_managed_task.html#aa9919cc80e72e84beb33c83062a4da55">AManagedTask::m_xStatus</a> <code>nPowerModeSwitchPending == 0</code>) the task set the power mode delay switch bit (<a class="el" href="struct___a_managed_task.html#aa9919cc80e72e84beb33c83062a4da55">AManagedTask::m_xStatus</a> <code>nDelayPowerModeSwitch = 1</code>), then it executes a step according to the active power mode, and, at the end of the step, it resets the power mode delay switch bit (<a class="el" href="struct___a_managed_task.html#aa9919cc80e72e84beb33c83062a4da55">AManagedTask::m_xStatus</a> <code>nDelayPowerModeSwitch = 0</code>).</p>
<h2><a class="anchor" id="eloom_power_mode_pmclass"></a>
Managed task classification during the PM transaction</h2>
<p>In a complex multitasking application, there can be dependencies between application tasks. This can be an issue during the a power mode transaction. Imagine that a task Ta depends on a task Tb. If Tb executes the PM transaction before Ta, then Ta could not work properly. For example it needs a service provide by Tb during its step execution, but Tb is suspended because it already did the PM transaction.</p>
<p>The framework provides a generic way to manage this issue. It defines three PM classes for a <a class="el" href="_a_managed_task_ex_8h.html#ad87736e39ee8628f90cabba1d7747236">AManagedTaskEx</a>:</p><ul>
<li>E_PM_CLASS_0</li>
<li>E_PM_CLASS_1</li>
<li>E_PM_CLASS_2</li>
</ul>
<p>An object of type <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a> belongs to E_PM_CLASS_0. The application can modify the PM class of an <a class="el" href="_a_managed_task_ex_8h.html#ad87736e39ee8628f90cabba1d7747236">AManagedTaskEx</a> by using the method <a class="el" href="_a_managed_task_ex__vtbl_8h.html#aed914e01a506a889c63580dcc86c5492">AMTExSetPMClass()</a>. This can be done once, for example during the task initialization (e.g. <a class="el" href="_a_managed_task__vtbl_8h.html#a5b9496501cafa6f22080fecbd8be8c88">AMTOnCreateTask()</a>) or also just before the PM transaction in the method <a class="el" href="_a_managed_task_ex__vtbl_8h.html#a176724874ae88d18d80425955e78bc39">AMTExOnEnterPowerMode()</a>. This feature provides the capability to configure the PM class for each task depending on the current PM transaction. When the INIT task executes a transaction to a new PM state, it will switch first all managed tasks belonging to E_PM_CLASS_0, then the managed task belonging to E_PM_CLASS_1 and, at the end, the managed task belonging to E_PM_CLASS_2.</p>
<h2><a class="anchor" id="eloom_power_mode_other"></a>
Other considerations on the low power mode</h2>
<p>Some others things are used in order to reduce the current consumption. During the system initialization the clock three must be configured according to the application requirement. We can use CubeMX for this purpose and copy&amp;paste the generated <a class="el" href="sysinit_8c.html#a70af21c671abfcc773614a9a4f63d920" title="System Clock Configuration.">SystemClock_Config()</a> function in the [APP_ROOT]/mx/Src/sysinit_mx.c file. <a class="el" href="sysinit_8c.html#a1f7982c3a6d9ac68ca031c7449b6fd51" title="Power Configuration.">SystemPower_Config()</a> is defined in the same file and it configures all not used pin of the MCU in analog input mode. It must be modified by the developer.</p>
<h1><a class="anchor" id="eloom_error_simple"></a>
Error Management</h1>
<h2><a class="anchor" id="error_generic"></a>
Simple support</h2>
<p>The system tracks the last error occurred in the Service Level layer and in the Low Level layer using a global 32 bits variable <a class="el" href="syserror_8c.html#aa436e1ff63f19c6e6be1ef65537ae213">g_nSysError</a> and a set of convenient macro to operate it. The macro are defined in the <a class="el" href="syserror_8h.html" title="Define the global error management API.">syserror.h</a> file. The application can defines its own error code in the apperror.h file starting from the value <code>APP_BASE_ERROR_CODE</code>. The generic and simple error support is completed by the function <a class="el" href="syserror_8h.html#ab65063c103375dd31c2aeec11572a92c">sys_error_handler()</a> that, at the moment, blocks the calling task, but it can be redefined by the application.</p>
<h2><a class="anchor" id="eloom_error_advanced"></a>
Advanced support</h2>
<p>In order to integrate the simple error support, the system provides a more structured, powerful and flexible design pattern to manage the errors. It is based on some interface as displayed in <a class="el" href="e_loo_m_main.html#eloom_fig10">Fig.10</a></p>
<p><a class="anchor" id="eloom_fig10"></a></p><div class="image">
<img src="10_error_class_diagram.png" alt="" width="1000px"/>
<div class="caption">
Fig.10</div></div>
<p>During the system initialization, the INIT task calls the <a class="el" href="sysinit_8h.html#aeb867760f6822701a13f42db516e88d8">SysGetErrorDelegate()</a> function in order to get a pointer to an object that implement the <a class="el" href="_i_application_error_delegate_8h.html#a105ef6c94544adf17ae430dd98a75312">IApplicationErrorDelegate</a> interface. The function is defined as <code>weak</code> so the application can provide its own errors manager delegate. The default Application Error Delegate (AED) does nothing, so the advanced error framework is disabled. The AED is initialized - <a class="el" href="_i_application_error_delegate_vtbl_8h.html#aafd0b24be482ec91db4f7d83d0afe964">IAEDInit()</a> - before the application context when the application managed tasks are created. This allows the application tasks to use the services provided by the AED during the initialization. In particular, if a task need to handle a critical error, it can implement the <a class="el" href="_i_error_first_responder_8h.html#ae77544a1cc2c9e0bcaf8b2ecd4989e6d">IErrFirstResponder</a> interface and register itself as an error first responder - <a class="el" href="_i_application_error_delegate_vtbl_8h.html#af477c7fa17047643475e7917557dc727">IAEDAddFirstResponder()</a> - of the AED. The first responders are objects activated as soon an error is detected. <a class="el" href="e_loo_m_main.html#eloom_fig11">Fig.11</a> displays how this error framework is integrated in the INIT control loop.</p>
<p><a class="anchor" id="eloom_fig11"></a></p><div class="image">
<img src="11_error_sequence.png" alt=""/>
<div class="caption">
Fig.11</div></div>
<p>When the system receives an event (1), it checks if it is a power mode event or an error event. In the latter case (2) the system notifies the AED before adding the event in the system event queue (4). The AED immediately forward the event to the first responder objects. This allows a quick reaction of the system to a critical error. To be effective, the first responder action should be quick and, moreover, the number of first responders are limited to <a class="el" href="_i_application_error_delegate_vtbl_8h.html#adfc0af92ac8ffbf26f6620459d1f2b72">IAEDGetMaxFirstResponderPriority()</a>. The first responder objects are activated from the one with highest priority, that is 0, to the one with the lowest priority. When the error event is asynchronously fetched from the system queue by the INIT task, it delegates the AEM to process the event (5). In this way the power mode loop is split from the error management loop. It is responsibility of the AEM to handle the error and to forward it to all application managed tasks (6). An application managed task receive an error event by implementing the <a class="el" href="_a_managed_task__vtbl_8h.html#acc9223cf5b8cbbae3b10b68aba3315e4">AMTHandleError()</a> function.</p>
<h2><a class="anchor" id="eloom_error_wwdg"></a>
AppErrorManager and the WWDG</h2>
<p>The AED is usually implemented by an AppErrorManager class (AEM). This class, other then implementing the <a class="el" href="_i_application_error_delegate_8h.html#a105ef6c94544adf17ae430dd98a75312">IApplicationErrorDelegate</a> interface, uses the STM32 System Watchdog peripheral (WDG) to automatically reset the system when an unexpected error occurs. The WWGD ISR generate a system error event with an application specific period in order to check if all managed tasks are still running. A managed task must call the <a class="el" href="_a_managed_task__vtbl_8h.html#a5afc8a90c65d8a9f0c2a53c5c86acf25">AMTNotifyIsStillRunning()</a> periodically to inform the system that it is working fine and prevent a system reset. This is usually done in the task control loop at the end of each step if no error is reported from the step execution. If a managed task has to do a long-lasting operation, then it should call the <a class="el" href="_a_managed_task__vtbl_8h.html#abaccaf90cccf4cfa3360116324744cb8">AMTResetAEDCounter()</a> in order to delay the WWDG reset.</p>
<h1><a class="anchor" id="eloom_cube_integration"></a>
eLooM and STM32Cube</h1>
<p>eLooM introduces modularity and makes complex firmware easy to port to different board and different MCU families. In a well designd eLooM applicatoin the code at <em>Application Layer</em>, <em>Services Layer</em> or the extensions to the <em>Event</em> layer is portable with zero or very few effort. Most of the effort is required at <em>Low Level API</em> to configure the peripheral drivers for the new board.</p>
<p><a class="anchor" id="eloom_fig13"></a></p><div class="image">
<img src="28_eloom_ll_and_mx.png" alt="" width="900px"/>
<div class="caption">
Fig.13</div></div>
<h2><a class="anchor" id="eloom_cube_mx"></a>
How to use STM32CubeMX in the eLooM development workflow</h2>
<p>eLooM takes advantage of the configuration and code generation capabilities of <a href="https://www.st.com/en/development-tools/stm32cubemx.html">STM32CubeMX</a>. In <a class="el" href="e_loo_m_main.html#eloom_fig13">Fig.13</a>, the application provided part, <b>MX driver</b>, contains the HAL initializatoin code generated by STM32CubeMX. In fact, in an eLooM project there is a folder named <b>mx</b> as displayed in <a class="el" href="e_loo_m_main.html#eloom_fig14">Fig.14</a></p>
<p><a class="anchor" id="eloom_fig14"></a></p><div class="image">
<img src="29_eloom_ll_and_mx_exmple.png" alt=""/>
<div class="caption">
Fig.14</div></div>
<p>Inside this folder there is the .ioc project file (NUCLEO-U575ZI-Q_eLooM_prj.ioc in the above example) that a developer can use to modify the IP configuration, and update the code. Not everything is automatic. The files <em>mx.h</em> and <em>mx.c</em> are not generated by STM32CubeMX, but they must be mantained by the developer. Those files define the structure containing the configuration parameters for each IP used in the application. They are linked to a managed task that control a specific subsystem, for example during the <a class="el" href="_application_context_8h.html#a7592228ea4590b51b4fce8ecc5a66b93">ApplicationContext</a> definition:</p>
<div class="fragment"><div class="line"><span class="comment">/* file: App.c */</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="syserror_8h.html#a741625c706792e23dae12c911c4513f9">sys_error_code_t</a> <a class="code" href="sysinit_8h.html#ae4794131d796c57eeb711511870325b4">SysLoadApplicationContext</a>(<a class="code" href="struct___application_context.html">ApplicationContext</a> *pAppContext)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_inc_2stm32u5xx__hal__conf_8h.html#a631dea7b230e600555f979c62af1de21">assert_param</a>(pAppContext != NULL);</div>
<div class="line">  <a class="code" href="syserror_8h.html#a741625c706792e23dae12c911c4513f9">sys_error_code_t</a> res = SYS_NO_ERROR_CODE;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Allocate the task objects */</span></div>
<div class="line">  <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#a2fa0296628c3939cbed09aa30072b6ec">spHelloWorldObj</a> = <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_inc_2_hello_world_task_8h.html#a724a6bce41efb6088d39f9c1ed5fb13e">HelloWorldTaskAlloc</a>(&amp;<a class="code" href="_n_u_c_l_e_o-_u575_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a1ac16d1ae236e4643f3b3a052c086356">MX_GPIO_LEDBlueInitParams</a>, &amp;<a class="code" href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a464015e7e594e5874bd1df7baa01431f">MX_GPIO_UBInitParams</a>);</div>
<div class="line">  spUsbCdcObj      = UsbCdcTaskAlloc();</div>
<div class="line">  spI2C1BusObj     = <a class="code" href="_i2_c_bus_task_8h.html#a43e6d8435fd3523d5394fc1cfb2cb112">I2CBusTaskAlloc</a>(&amp;<a class="code" href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#aa8f33cd3593fec0adc7f65bc14237d7b">MX_I2C1InitParams</a>);</div>
<div class="line">  <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#a48badb485d5e215e4ec3b9fb13998cf1">spISM330DHCXObj</a>  = <a class="code" href="_i_s_m330_d_h_c_x_task_8h.html#ae4d9736c9a3ae91edf943baf2215b56b">ISM330DHCXTaskAlloc</a>(&amp;<a class="code" href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a8bc228b159d80eca3cd31e519a4aa19d">MX_GPIO_INT1_DHCXInitParams</a>, NULL, NULL);</div>
<div class="line">  <a class="code" href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#a81a37c72b222dd62519ba64704eb9463">spIIS2DLPCObj</a>    = <a class="code" href="_i_i_s2_d_l_p_c_task_8h.html#aec1926412093738310c6f1f7d7dcbc7f">IIS2DLPCTaskAlloc</a>(&amp;<a class="code" href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a96a930b2fd263b30ea8d95c8054ce7a8">MX_GPIO_INT2_DLPCInitParams</a>, NULL);</div>
<div class="line">  <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#aacbfff880296c14d12cfb739ca59c03c">spIIS2MDCObj</a>     = <a class="code" href="_i_i_s2_m_d_c_task_8h.html#a7996f63f7d076b61d04299b4190303f0">IIS2MDCTaskAlloc</a>(&amp;<a class="code" href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a14712d8150bb383dfc03029dc2628600">MX_GPIO_DRDY_MDCInitParams</a>, NULL);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Add the task object to the context. */</span></div>
<div class="line">  res = <a class="code" href="_application_context_8h.html#a1b56c74bfbf66806ee37743fad3a03eb">ACAddTask</a>(pAppContext, <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#a2fa0296628c3939cbed09aa30072b6ec">spHelloWorldObj</a>);</div>
<div class="line">  res = <a class="code" href="_application_context_8h.html#a1b56c74bfbf66806ee37743fad3a03eb">ACAddTask</a>(pAppContext, (<a class="code" href="struct___a_managed_task.html">AManagedTask</a>*) spUsbCdcObj);</div>
<div class="line">  res = <a class="code" href="_application_context_8h.html#a1b56c74bfbf66806ee37743fad3a03eb">ACAddTask</a>(pAppContext, (<a class="code" href="struct___a_managed_task.html">AManagedTask</a>*) spI2C1BusObj);</div>
<div class="line">  res = <a class="code" href="_application_context_8h.html#a1b56c74bfbf66806ee37743fad3a03eb">ACAddTask</a>(pAppContext, (<a class="code" href="struct___a_managed_task.html">AManagedTask</a>*) <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#a48badb485d5e215e4ec3b9fb13998cf1">spISM330DHCXObj</a>);</div>
<div class="line">  res = <a class="code" href="_application_context_8h.html#a1b56c74bfbf66806ee37743fad3a03eb">ACAddTask</a>(pAppContext, (<a class="code" href="struct___a_managed_task.html">AManagedTask</a>*) <a class="code" href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#a81a37c72b222dd62519ba64704eb9463">spIIS2DLPCObj</a>);</div>
<div class="line">  res = <a class="code" href="_application_context_8h.html#a1b56c74bfbf66806ee37743fad3a03eb">ACAddTask</a>(pAppContext, (<a class="code" href="struct___a_managed_task.html">AManagedTask</a>*) <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#aacbfff880296c14d12cfb739ca59c03c">spIIS2MDCObj</a>);</div>
<div class="line">  res = <a class="code" href="_application_context_8h.html#a1b56c74bfbf66806ee37743fad3a03eb">ACAddTask</a>(pAppContext, (<a class="code" href="struct___a_managed_task.html">AManagedTask</a>*) &amp;sProcessTask);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p>A managed task only stores a reference to an MX configuration structure, and it will pass the reference to the low level <a class="el" href="_i_driver_8h.html#af510b3df23076a172ebd286865cc28e9">IDriver</a> in the hardware initialization virtual function <a class="el" href="_a_managed_task__vtbl_8h.html#acdeb2880befe6dabbadda75fe249ba2d">AMTHardwareInit()</a>. For example this is the code for the spI2C1BusObj:</p>
<div class="fragment"><div class="line"><span class="comment">/* file: I2BusTask.c */</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="syserror_8h.html#a741625c706792e23dae12c911c4513f9">sys_error_code_t</a> <a class="code" href="_i2_c_bus_task__vtbl_8h.html#a6c4b00b6396faa4be6151abeed1729d4">I2CBusTask_vtblHardwareInit</a>(<a class="code" href="struct___a_managed_task.html">AManagedTask</a> *_this, <span class="keywordtype">void</span> *p_params)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_inc_2stm32u5xx__hal__conf_8h.html#a631dea7b230e600555f979c62af1de21">assert_param</a>(_this);</div>
<div class="line">  <a class="code" href="syserror_8h.html#a741625c706792e23dae12c911c4513f9">sys_error_code_t</a> res = SYS_NO_ERROR_CODE;</div>
<div class="line">  <a class="code" href="struct___i2_c_bus_task.html">I2CBusTask</a> *p_obj = (<a class="code" href="struct___i2_c_bus_task.html">I2CBusTask</a> *) _this;</div>
<div class="line"> </div>
<div class="line">  p_obj-&gt;<a class="code" href="struct___i2_c_bus_task.html#a54186ac7e2579b189ecb6a2d2969f4ea">p_driver</a> = <a class="code" href="_i2_c_master_driver_8h.html#a6f34f01f5f52c5728e03da33c58180e5">I2CMasterDriverAlloc</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (p_obj-&gt;<a class="code" href="struct___i2_c_bus_task.html#a54186ac7e2579b189ecb6a2d2969f4ea">p_driver</a> == NULL)</div>
<div class="line">  {</div>
<div class="line">    SYS_DEBUGF(<a class="code" href="sysdebug_8h.html#a8309aceac8f7d3f306032682faea3824">SYS_DBG_LEVEL_SEVERE</a>, (<span class="stringliteral">&quot;I2CBus task: unable to alloc driver object.\r\n&quot;</span>));</div>
<div class="line">    res = SYS_GET_LAST_LOW_LEVEL_ERROR_CODE();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="struct___i2_c_master_driver_params__t.html">I2CMasterDriverParams_t</a> driver_cfg =</div>
<div class="line">    {</div>
<div class="line">      .<a class="code" href="struct___i2_c_master_driver_params__t.html#ab4af0eda669d9fdd1387a76ade8104f6">p_mx_i2c_cfg</a> = (<span class="keywordtype">void</span> *) p_obj-&gt;<a class="code" href="struct___i2_c_bus_task.html#a6b01566e51853def020029e2b651bd44">p_mx_drv_cfg</a></div>
<div class="line">    };</div>
<div class="line">    res = <a class="code" href="_i_driver_8h.html#af70edea328a674ae76b8766eacc4770d">IDrvInit</a>((<a class="code" href="struct___i_driver.html">IDriver</a> *) p_obj-&gt;<a class="code" href="struct___i2_c_bus_task.html#a54186ac7e2579b189ecb6a2d2969f4ea">p_driver</a>, &amp;driver_cfg);</div>
<div class="line">    <span class="keywordflow">if</span> (SYS_IS_ERROR_CODE(res))</div>
<div class="line">    {</div>
<div class="line">      SYS_DEBUGF(<a class="code" href="sysdebug_8h.html#a8309aceac8f7d3f306032682faea3824">SYS_DBG_LEVEL_SEVERE</a>, (<span class="stringliteral">&quot;I2CBus task: error during driver initialization\r\n&quot;</span>));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p>in the above example <code>p_obj-&gt;p_mx_drv_cfg</code> is the same reference, <code>&amp;MX_I2C1InitParams</code>, passed in the task allocation <code>spI2C1BusObj = I2CBusTaskAlloc(&amp;MX_I2C1InitParams);</code>.</p>
<h2><a class="anchor" id="eloom_cube_irq"></a>
eLooM objects and STM32 HAL callbacks</h2>
<p>In an embedded application a developer must manage asynchronous request coming from MCU peripherals or external component connected to one or more pin of the MCU. These are the Interrupt requests (IRQ). The HAL driver provides a simple, generic multi-instance and feature-oriented set of <b>procedural APIs</b> that simplify the user application implementation. The HAL driver source code is developed in Strict ANSI-C. For the IRQ, the HAL peripheral drivers include <b>interrupt handle</b> and <b>user callback functions</b>. For example, these are the prototype of the interrupt handler for the I2C and EXTI peripherals with the respective callbacks:</p>
<div class="fragment"><div class="line"><span class="comment">/* IRQ handler */</span></div>
<div class="line"><span class="keywordtype">void</span> HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c);</div>
<div class="line"><span class="keywordtype">void</span> HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c);</div>
<div class="line"><span class="keywordtype">void</span> HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* User callback */</span></div>
<div class="line"><span class="keywordtype">void</span> HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c);</div>
<div class="line"><span class="keywordtype">void</span> HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c);</div>
<div class="line"><span class="keywordtype">void</span> EXTI_PendingCallback(<span class="keywordtype">void</span>);</div>
</div><!-- fragment --><p>eLooM, following the <b>Object Oriented</b> programming model, provides a set of interface and objects that can be used and extended, like managed task (<a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a>) and low level driver (<a class="el" href="_i_driver_8h.html#af510b3df23076a172ebd286865cc28e9">IDriver</a>). An embedded applicaiton is designed as a set of managed task, each of which is the gatekeeper for one or more hardware peripherals of the MCU. For example an application defined I2CTask object can be the gatekeeper for an I2C instance of the MCU. This means that we must be able to activate a specific I2CTask object from the HAL I2C callbacks.</p>
<p><a class="anchor" id="eloom_fig15"></a></p><div class="image">
<img src="30_eloom_and_hal-irq_1.png" alt=""/>
<div class="caption">
Fig.15</div></div>
<p>How to link an IRQ callback to an object? eLooM provides two class to support this scenario:</p><ul>
<li>drivers/<a class="el" href="_h_w_driver_map_8h.html#ac151eed1759a3b6e8d41f4d28d71a21a">HWDriverMap_t</a> is a map (key, <a class="el" href="_i_driver_8h.html#af510b3df23076a172ebd286865cc28e9">IDriver</a>) specialized for low level drivers.</li>
<li>services/<a class="el" href="_managed_task_map_8h.html#a28467b846dbe13e0bae844d5c2afcdae">MTMap_t</a> is a map (key, <a class="el" href="_a_managed_task_8h.html#af516b211ac6895cd8b909223b7f8d743">AManagedTask</a>) specialized for managed tasks (the name stand for <b>M</b>anaged <b>T</b>ask Map.).</li>
</ul>
<p>In the I2C example, the <a class="el" href="_h_w_driver_map_8h.html#ac151eed1759a3b6e8d41f4d28d71a21a">HWDriverMap_t</a> can be added in the class object of the I2CMasterDriver because in OO we model it as a static member of the the I2CMasterDriver class.<br  />
 Note: a <a href="https://learn.microsoft.com/en-us/cpp/cpp/static-members-cpp?view=msvc-170">static class member</a> is a member that is not bound to a specific instance of the class, but the only one copy of the data is maintained and accessible for all objects of the class.</p>
<div class="fragment"><div class="line"><span class="comment">/* file: I2CMasterDrive.c */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct___i2_c_master_driver_class.html">_I2CMasterDriverClass</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="struct___i_i_o_driver__vtbl.html">IIODriver_vtbl</a> <a class="code" href="struct___i2_c_master_driver_class.html#a1d144e2aff08e44636321a8568f127b7">vtbl</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="struct___h_w_driver_map_element.html">HWDriverMapElement_t</a> <a class="code" href="struct___i2_c_master_driver_class.html#a591ff4495da99d08a8c0417e9346e23a">ip_drv_map_elements</a>[I2CDRV_CFG_HARDWARE_PERIPHERALS_COUNT];</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="struct___h_w_driver_map.html">HWDriverMap_t</a> <a class="code" href="struct___i2_c_master_driver_class.html#aac3d1b690f5141ed84c4c2f6ee790132">ip_drv_map</a>;</div>
<div class="line"> </div>
<div class="line">} <a class="code" href="_i2_c_master_driver_8c.html#a3de431c09d08ab036a11b62f6257cf17">I2CMasterDriverClass_t</a>;</div>
</div><!-- fragment --><p>The link between the object and the callback is done in the virtual function <a class="el" href="_i_driver_8h.html#af70edea328a674ae76b8766eacc4770d">IDrvInit()</a>:</p>
<div class="fragment"><div class="line"><span class="comment">/* file: I2CMasterDrive.c */</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="syserror_8h.html#a741625c706792e23dae12c911c4513f9">sys_error_code_t</a> <a class="code" href="_i2_c_master_driver__vtbl_8h.html#af1900055b64373471c28a6a03167387c">I2CMasterDriver_vtblInit</a>(<a class="code" href="struct___i_driver.html">IDriver</a> *_this, <span class="keywordtype">void</span> *p_params)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_inc_2stm32u5xx__hal__conf_8h.html#a631dea7b230e600555f979c62af1de21">assert_param</a>(_this != NULL);</div>
<div class="line">  <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_inc_2stm32u5xx__hal__conf_8h.html#a631dea7b230e600555f979c62af1de21">assert_param</a>(p_params != NULL);</div>
<div class="line">  <a class="code" href="syserror_8h.html#a741625c706792e23dae12c911c4513f9">sys_error_code_t</a> res = SYS_NO_ERROR_CODE;</div>
<div class="line">  UINT nRes = TX_SUCCESS;</div>
<div class="line">  <a class="code" href="struct___i2_c_master_driver__t.html">I2CMasterDriver_t</a> *p_obj = (<a class="code" href="struct___i2_c_master_driver__t.html">I2CMasterDriver_t</a> *) _this;</div>
<div class="line">  p_obj-&gt;<a class="code" href="struct___i2_c_master_driver__t.html#abbdde903eb6cd3535fc61656e95c8491">mx_handle</a>.<a class="code" href="struct___i2_c_master_driver_params__t.html#ab4af0eda669d9fdd1387a76ade8104f6">p_mx_i2c_cfg</a> = ((<a class="code" href="struct___i2_c_master_driver_params__t.html">I2CMasterDriverParams_t</a> *) p_params)-&gt;p_mx_i2c_cfg;</div>
<div class="line">  I2C_HandleTypeDef *p_i2c = p_obj-&gt;<a class="code" href="struct___i2_c_master_driver__t.html#abbdde903eb6cd3535fc61656e95c8491">mx_handle</a>.<a class="code" href="struct___i2_c_master_driver_params__t.html#ab4af0eda669d9fdd1387a76ade8104f6">p_mx_i2c_cfg</a>-&gt;<a class="code" href="struct___m_x___i2_c_params__t.html#a6767bf6c14cf7ceaa4aabf99fb2f614d">p_i2c_handle</a>;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">/* other initializaiton ... */</span></div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span> (!<a class="code" href="_h_w_driver_map_8h.html#a96194a6b797849730ba69219798243ab">HWDriverMap_IsInitialized</a>(&amp;<a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_datalog_app_task_8c.html#a50b371568791f15a7d4a2e4dfb83c358">sTheClass</a>.ip_drv_map))</div>
<div class="line"> {</div>
<div class="line">   (void) <a class="code" href="_h_w_driver_map_8h.html#a18668ca483e678b8d818815e7d340086">HWDriverMap_Init</a>(&amp;<a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_datalog_app_task_8c.html#a50b371568791f15a7d4a2e4dfb83c358">sTheClass</a>.ip_drv_map, <a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_datalog_app_task_8c.html#a50b371568791f15a7d4a2e4dfb83c358">sTheClass</a>.ip_drv_map_elements, I2CDRV_CFG_HARDWARE_PERIPHERALS_COUNT);</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">/* Add the driver to the map.</span></div>
<div class="line"><span class="comment">  * Use the peripheral address as unique key for the map. */</span></div>
<div class="line"> <a class="code" href="struct___h_w_driver_map_element.html">HWDriverMapElement_t</a> *p_element = NULL;</div>
<div class="line"> uint32_t key = (uint32_t) p_obj-&gt;<a class="code" href="struct___i2_c_master_driver__t.html#abbdde903eb6cd3535fc61656e95c8491">mx_handle</a>.<a class="code" href="struct___i2_c_master_driver_params__t.html#ab4af0eda669d9fdd1387a76ade8104f6">p_mx_i2c_cfg</a>-&gt;<a class="code" href="struct___m_x___i2_c_params__t.html#a6767bf6c14cf7ceaa4aabf99fb2f614d">p_i2c_handle</a>-&gt;Instance;</div>
<div class="line"> p_element = <a class="code" href="_h_w_driver_map_8h.html#ac88763fb89d4231f80e181cd1d762ad8">HWDriverMap_AddElement</a>(&amp;<a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_datalog_app_task_8c.html#a50b371568791f15a7d4a2e4dfb83c358">sTheClass</a>.ip_drv_map, key, _this);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">if</span>(p_element == NULL)</div>
<div class="line"> {</div>
<div class="line">   SYS_SET_LOW_LEVEL_ERROR_CODE(SYS_INVALID_PARAMETER_ERROR_CODE);</div>
<div class="line">   res = SYS_INVALID_PARAMETER_ERROR_CODE;</div>
<div class="line"> }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line"> {</div>
<div class="line">   nRes = tx_semaphore_create(&amp;p_obj-&gt;<a class="code" href="struct___i2_c_master_driver__t.html#a01309bdeec9b97b2480d7e4ccfed9d9e">sync_obj</a>, <span class="stringliteral">&quot;I2CDrv&quot;</span>, 0);</div>
<div class="line">   <span class="keywordflow">if</span>(nRes != TX_SUCCESS)</div>
<div class="line">   {</div>
<div class="line">     SYS_SET_LOW_LEVEL_ERROR_CODE(SYS_OUT_OF_MEMORY_ERROR_CODE);</div>
<div class="line">     res = SYS_OUT_OF_MEMORY_ERROR_CODE;</div>
<div class="line"> </div>
<div class="line">    (void) <a class="code" href="_h_w_driver_map_8h.html#a763cd1be9b229ab9580642bfbe2e6957">HWDriverMap_RemoveElement</a>(&amp;<a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_datalog_app_task_8c.html#a50b371568791f15a7d4a2e4dfb83c358">sTheClass</a>.ip_drv_map, key);</div>
<div class="line">   }</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line">  SYS_DEBUGF(<a class="code" href="sysdebug_8h.html#adba2388ee51da1963b4846885e596b68">SYS_DBG_LEVEL_VERBOSE</a>, (<span class="stringliteral">&quot;I2CMasterDriver: initialization done: %d.\r\n&quot;</span>, res));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, from the I2C IRQ callback we can use the class object to access the map and the right I2CMasterDriver istance:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> I2CMasterDrvMemTxRxCpltCallback(I2C_HandleTypeDef *p_i2c)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="struct___h_w_driver_map_value.html">HWDriverMapValue_t</a> *p_val;</div>
<div class="line">  TX_SEMAPHORE *sync_obj;</div>
<div class="line"> </div>
<div class="line">  p_val = <a class="code" href="_h_w_driver_map_8h.html#a877d2f21f68456de706d2e2f247daca0">HWDriverMap_FindByKey</a>(&amp;<a class="code" href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_datalog_app_task_8c.html#a50b371568791f15a7d4a2e4dfb83c358">sTheClass</a>.ip_drv_map, (uint32_t) p_i2c-&gt;Instance);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(p_val != NULL)</div>
<div class="line">  {</div>
<div class="line">    sync_obj = &amp;((<a class="code" href="struct___i2_c_master_driver__t.html">I2CMasterDriver_t</a>*)p_val-&gt;<a class="code" href="struct___h_w_driver_map_value.html#a8bedfd521ae0eec2805a5380b7ed8f4c">p_driver_obj</a>)-&gt;sync_obj;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(sync_obj != NULL)</div>
<div class="line">    {</div>
<div class="line">      tx_semaphore_put(sync_obj);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The sequence diagram of <a class="el" href="e_loo_m_main.html#eloom_fig16">Fig.16</a> summarizes what we saw in the previous code fragmants.</p>
<p><a class="anchor" id="eloom_fig16"></a></p><div class="image">
<img src="27_HWDriverMap_sequence.png" alt=""/>
<div class="caption">
Fig.16</div></div>
<p>The <a class="el" href="_managed_task_map_8h.html#a28467b846dbe13e0bae844d5c2afcdae">MTMap_t</a> can be used in the same way to link a IRQ callback with a managed task.</p>
<h1><a class="anchor" id="eloom_rtos"></a>
Support for different RTOS</h1>
<p>Since v3.2.0 eLooM supports <a href="https://freertos.org/">FreeRTOS</a> and <a href="https://learn.microsoft.com/en-us/azure/rtos/threadx/">ThreadX</a> as RTOS in the <em>Kernel layer</em>, see <a class="el" href="e_loo_m_main.html#eloom_fig01">Fig.1</a>. In fact, there are two version of eLooM, one for each RTOS. This is because one of the main goal of eLooM is to have optimized code to reach the best performance on STM32, as discussed in <a href="http://www.stf12.org/odev/framework/blog/files/why-another-driver-layer.php">this article</a>. We don't want to make compromise between FreeRTOS and ThreadX. We discovered also that this choice has a very little impact on code portability thanks to the similar semantic of the API provided by the two schedulers: porting a complex eLooM application from one RTOS to the other requires few hours effort.</p>
<p>Nonetheless, there are few things in eLooM designed to simplify the development, in term of portability between FreeRTOS and ThreadX. Both ROTS provide API for:</p><ul>
<li>Memory management: <a href="https://freertos.org/a00111.html">FreeRTOS</a>, ThreadX <a href="https://learn.microsoft.com/en-us/azure/rtos/threadx/chapter4#tx_block_pool_create">1</a> and <a href="https://learn.microsoft.com/en-us/azure/rtos/threadx/chapter4#tx_byte_pool_create">2</a>.</li>
<li>Critical sections: <a href="https://freertos.org/a00020.html">FreeRTOS</a>, <a href="https://learn.microsoft.com/en-us/azure/rtos/threadx/chapter4#tx_interrupt_control">ThreadX</a></li>
</ul>
<p>eLooM provides a framework level API for <b>dynamic memory management</b> and <b>critical sections</b>. These API are exported in different header file, so an application file can include only the required services:</p><ul>
<li><a class="el" href="syscs_8h.html" title="System critical section.">services/syscs.h</a> declares the critical sectoins API:<ul>
<li>SYS_DECLARE_CS()</li>
<li>SYS_ENTER_CRTITICAL()</li>
<li>SYS_EXIT_CRTITICAL()</li>
</ul>
</li>
<li><a class="el" href="sysmem_8h.html" title="System memory management.">services/sysmem.h</a> declares the dynamic memory management API:<ul>
<li><a class="el" href="sysmem_8h.html#afd7b8120de07929b991842b8ad3f5db7">SysAlloc()</a></li>
<li><a class="el" href="sysmem_8h.html#a9947abefb4af7648a433a88d2bed6fc4">SysFree()</a></li>
</ul>
</li>
</ul>
<p>These API help a developer to write code that works on both implementation of eLooM as it is, or easier to port. At the same time these services do not hide the native implementations provided by the RTOS, but they are just another option for the developer</p>
<h2><a class="anchor" id="eloom_basesrv"></a>
eLooM base services</h2>
<p>Since version v3.3.0 the above concepts have been generalized. We identified a minimum set of basic features that work on top of the kernel layer and that are used at all levels of the framework. These are, other that the critical section and the dynamic memory management:</p><ul>
<li>The definition of some eLooM specific types in the header file <b>systype.h</b> (it exists for backward compatibility)</li>
<li>The definition of the target platform, as the used STM32 device RTOS, in the header file <b><a class="el" href="systp_8h.html" title="Target platform definition.">systp.h</a></b></li>
<li>The basic error definition in the header file <b><a class="el" href="syserror_8h.html" title="Define the global error management API.">syserror.h</a></b></li>
</ul>
<p>So, we introduced in this version of eLooM a new umbrella header file named <b><a class="el" href="eloom__sysbase_8h.html" title="Umbrella header for the basic system features.">eloom_sysbase.h</a></b> that simplifies the include chain across the framework and the eLooM Components. It can be used also at application level in case of a new class that does not inherit from the framework hierarchy.</p>
<p><a class="el" href="eloom_gs_page.html">Getting Started</a> <a class="el" href="eloom_da_page.html">A Simple Demo</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="a_h_w_driver_map_8h_html_a96194a6b797849730ba69219798243ab"><div class="ttname"><a href="_h_w_driver_map_8h.html#a96194a6b797849730ba69219798243ab">HWDriverMap_IsInitialized</a></div><div class="ttdeci">static bool HWDriverMap_IsInitialized(HWDriverMap_t *_this)</div><div class="ttdef"><b>Definition:</b> HWDriverMap.h:255</div></div>
<div class="ttc" id="a_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c_html_a81a37c72b222dd62519ba64704eb9463"><div class="ttname"><a href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#a81a37c72b222dd62519ba64704eb9463">spIIS2DLPCObj</a></div><div class="ttdeci">static AManagedTaskEx * spIIS2DLPCObj</div><div class="ttdef"><b>Definition:</b> App.c:132</div></div>
<div class="ttc" id="astruct___i2_c_bus_task_html_a6b01566e51853def020029e2b651bd44"><div class="ttname"><a href="struct___i2_c_bus_task.html#a6b01566e51853def020029e2b651bd44">_I2CBusTask::p_mx_drv_cfg</a></div><div class="ttdeci">const void * p_mx_drv_cfg</div><div class="ttdef"><b>Definition:</b> I2CBusTask.h:73</div></div>
<div class="ttc" id="astruct___i2_c_master_driver_class_html_aac3d1b690f5141ed84c4c2f6ee790132"><div class="ttname"><a href="struct___i2_c_master_driver_class.html#aac3d1b690f5141ed84c4c2f6ee790132">_I2CMasterDriverClass::ip_drv_map</a></div><div class="ttdeci">HWDriverMap_t ip_drv_map</div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.c:51</div></div>
<div class="ttc" id="astruct___application_context_html"><div class="ttname"><a href="struct___application_context.html">_ApplicationContext</a></div><div class="ttdef"><b>Definition:</b> ApplicationContext.h:40</div></div>
<div class="ttc" id="a_h_w_driver_map_8h_html_a877d2f21f68456de706d2e2f247daca0"><div class="ttname"><a href="_h_w_driver_map_8h.html#a877d2f21f68456de706d2e2f247daca0">HWDriverMap_FindByKey</a></div><div class="ttdeci">static HWDriverMapValue_t * HWDriverMap_FindByKey(HWDriverMap_t *_this, uint32_t key)</div><div class="ttdef"><b>Definition:</b> HWDriverMap.h:140</div></div>
<div class="ttc" id="a_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c_html_aacbfff880296c14d12cfb739ca59c03c"><div class="ttname"><a href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#aacbfff880296c14d12cfb739ca59c03c">spIIS2MDCObj</a></div><div class="ttdeci">static AManagedTaskEx * spIIS2MDCObj</div><div class="ttdef"><b>Definition:</b> App.c:126</div></div>
<div class="ttc" id="astruct___i_driver_html"><div class="ttname"><a href="struct___i_driver.html">_IDriver</a></div><div class="ttdef"><b>Definition:</b> IDriver_vtbl.h:51</div></div>
<div class="ttc" id="astruct___m_x___i2_c_params__t_html_a6767bf6c14cf7ceaa4aabf99fb2f614d"><div class="ttname"><a href="struct___m_x___i2_c_params__t.html#a6767bf6c14cf7ceaa4aabf99fb2f614d">_MX_I2CParams_t::p_i2c_handle</a></div><div class="ttdeci">I2C_HandleTypeDef * p_i2c_handle</div><div class="ttdef"><b>Definition:</b> mx.h:68</div></div>
<div class="ttc" id="a_i_driver_8h_html_af70edea328a674ae76b8766eacc4770d"><div class="ttname"><a href="_i_driver_8h.html#af70edea328a674ae76b8766eacc4770d">IDrvInit</a></div><div class="ttdeci">static sys_error_code_t IDrvInit(IDriver *_this, void *pParams)</div><div class="ttdef"><b>Definition:</b> IDriver_vtbl.h:59</div></div>
<div class="ttc" id="a_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c_html_a48badb485d5e215e4ec3b9fb13998cf1"><div class="ttname"><a href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#a48badb485d5e215e4ec3b9fb13998cf1">spISM330DHCXObj</a></div><div class="ttdeci">static AManagedTaskEx * spISM330DHCXObj</div><div class="ttdef"><b>Definition:</b> App.c:116</div></div>
<div class="ttc" id="a_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c_html_a2fa0296628c3939cbed09aa30072b6ec"><div class="ttname"><a href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_app_8c.html#a2fa0296628c3939cbed09aa30072b6ec">spHelloWorldObj</a></div><div class="ttdeci">static AManagedTask * spHelloWorldObj</div><div class="ttdef"><b>Definition:</b> App.c:103</div></div>
<div class="ttc" id="a_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_datalog_app_task_8c_html_a50b371568791f15a7d4a2e4dfb83c358"><div class="ttname"><a href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_src_2_datalog_app_task_8c.html#a50b371568791f15a7d4a2e4dfb83c358">sTheClass</a></div><div class="ttdeci">static const DatalogAppTaskClass_t sTheClass</div><div class="ttdef"><b>Definition:</b> DatalogAppTask.c:138</div></div>
<div class="ttc" id="a_i2_c_bus_task_8h_html_a43e6d8435fd3523d5394fc1cfb2cb112"><div class="ttname"><a href="_i2_c_bus_task_8h.html#a43e6d8435fd3523d5394fc1cfb2cb112">I2CBusTaskAlloc</a></div><div class="ttdeci">AManagedTaskEx * I2CBusTaskAlloc(const void *p_mx_drv_cfg)</div><div class="ttdef"><b>Definition:</b> I2CBusTask.c:131</div></div>
<div class="ttc" id="a_i2_c_bus_task__vtbl_8h_html_a6c4b00b6396faa4be6151abeed1729d4"><div class="ttname"><a href="_i2_c_bus_task__vtbl_8h.html#a6c4b00b6396faa4be6151abeed1729d4">I2CBusTask_vtblHardwareInit</a></div><div class="ttdeci">sys_error_code_t I2CBusTask_vtblHardwareInit(AManagedTask *_this, void *pParams)</div><div class="ttdef"><b>Definition:</b> I2CBusTask.c:170</div></div>
<div class="ttc" id="a_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h_html_a14712d8150bb383dfc03029dc2628600"><div class="ttname"><a href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a14712d8150bb383dfc03029dc2628600">MX_GPIO_DRDY_MDCInitParams</a></div><div class="ttdeci">const MX_GPIOParams_t MX_GPIO_DRDY_MDCInitParams</div><div class="ttdef"><b>Definition:</b> mx.c:150</div></div>
<div class="ttc" id="astruct___i2_c_master_driver_class_html"><div class="ttname"><a href="struct___i2_c_master_driver_class.html">_I2CMasterDriverClass</a></div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.c:37</div></div>
<div class="ttc" id="a_h_w_driver_map_8h_html_ac88763fb89d4231f80e181cd1d762ad8"><div class="ttname"><a href="_h_w_driver_map_8h.html#ac88763fb89d4231f80e181cd1d762ad8">HWDriverMap_AddElement</a></div><div class="ttdeci">static HWDriverMapElement_t * HWDriverMap_AddElement(HWDriverMap_t *_this, uint32_t key, IDriver *p_instance)</div><div class="ttdef"><b>Definition:</b> HWDriverMap.h:167</div></div>
<div class="ttc" id="a_i2_c_master_driver_8h_html_a6f34f01f5f52c5728e03da33c58180e5"><div class="ttname"><a href="_i2_c_master_driver_8h.html#a6f34f01f5f52c5728e03da33c58180e5">I2CMasterDriverAlloc</a></div><div class="ttdeci">IIODriver * I2CMasterDriverAlloc(void)</div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.c:112</div></div>
<div class="ttc" id="a_application_context_8h_html_a1b56c74bfbf66806ee37743fad3a03eb"><div class="ttname"><a href="_application_context_8h.html#a1b56c74bfbf66806ee37743fad3a03eb">ACAddTask</a></div><div class="ttdeci">sys_error_code_t ACAddTask(ApplicationContext *_this, AManagedTask *pTask)</div><div class="ttdef"><b>Definition:</b> ApplicationContext.c:46</div></div>
<div class="ttc" id="a_i2_c_master_driver_8c_html_a3de431c09d08ab036a11b62f6257cf17"><div class="ttname"><a href="_i2_c_master_driver_8c.html#a3de431c09d08ab036a11b62f6257cf17">I2CMasterDriverClass_t</a></div><div class="ttdeci">struct _I2CMasterDriverClass I2CMasterDriverClass_t</div></div>
<div class="ttc" id="astruct___h_w_driver_map_element_html"><div class="ttname"><a href="struct___h_w_driver_map_element.html">_HWDriverMapElement</a></div><div class="ttdef"><b>Definition:</b> HWDriverMap.h:68</div></div>
<div class="ttc" id="astruct___a_managed_task_html"><div class="ttname"><a href="struct___a_managed_task.html">_AManagedTask</a></div><div class="ttdef"><b>Definition:</b> AManagedTask_vtbl.h:97</div></div>
<div class="ttc" id="astruct___h_w_driver_map_value_html"><div class="ttname"><a href="struct___h_w_driver_map_value.html">_HWDriverMapValue</a></div><div class="ttdef"><b>Definition:</b> HWDriverMap.h:52</div></div>
<div class="ttc" id="astruct___i2_c_master_driver__t_html_abbdde903eb6cd3535fc61656e95c8491"><div class="ttname"><a href="struct___i2_c_master_driver__t.html#abbdde903eb6cd3535fc61656e95c8491">_I2CMasterDriver_t::mx_handle</a></div><div class="ttdeci">I2CMasterDriverParams_t mx_handle</div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.h:85</div></div>
<div class="ttc" id="a_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h_html_aa8f33cd3593fec0adc7f65bc14237d7b"><div class="ttname"><a href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#aa8f33cd3593fec0adc7f65bc14237d7b">MX_I2C1InitParams</a></div><div class="ttdeci">const MX_I2CParams_t MX_I2C1InitParams</div><div class="ttdef"><b>Definition:</b> mx.c:48</div></div>
<div class="ttc" id="a_h_w_driver_map_8h_html_a763cd1be9b229ab9580642bfbe2e6957"><div class="ttname"><a href="_h_w_driver_map_8h.html#a763cd1be9b229ab9580642bfbe2e6957">HWDriverMap_RemoveElement</a></div><div class="ttdeci">static bool HWDriverMap_RemoveElement(HWDriverMap_t *_this, uint32_t key)</div><div class="ttdef"><b>Definition:</b> HWDriverMap.h:222</div></div>
<div class="ttc" id="astruct___i2_c_bus_task_html_a54186ac7e2579b189ecb6a2d2969f4ea"><div class="ttname"><a href="struct___i2_c_bus_task.html#a54186ac7e2579b189ecb6a2d2969f4ea">_I2CBusTask::p_driver</a></div><div class="ttdeci">IIODriver * p_driver</div><div class="ttdef"><b>Definition:</b> I2CBusTask.h:68</div></div>
<div class="ttc" id="asysinit_8h_html_ae4794131d796c57eeb711511870325b4"><div class="ttname"><a href="sysinit_8h.html#ae4794131d796c57eeb711511870325b4">SysLoadApplicationContext</a></div><div class="ttdeci">sys_error_code_t SysLoadApplicationContext(ApplicationContext *pAppContext)</div><div class="ttdef"><b>Definition:</b> sysinit.c:183</div></div>
<div class="ttc" id="a_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h_html_a96a930b2fd263b30ea8d95c8054ce7a8"><div class="ttname"><a href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a96a930b2fd263b30ea8d95c8054ce7a8">MX_GPIO_INT2_DLPCInitParams</a></div><div class="ttdeci">const MX_GPIOParams_t MX_GPIO_INT2_DLPCInitParams</div><div class="ttdef"><b>Definition:</b> mx.c:139</div></div>
<div class="ttc" id="astruct___h_w_driver_map_value_html_a8bedfd521ae0eec2805a5380b7ed8f4c"><div class="ttname"><a href="struct___h_w_driver_map_value.html#a8bedfd521ae0eec2805a5380b7ed8f4c">_HWDriverMapValue::p_driver_obj</a></div><div class="ttdeci">IDriver * p_driver_obj</div><div class="ttdef"><b>Definition:</b> HWDriverMap.h:56</div></div>
<div class="ttc" id="astruct___i2_c_master_driver__t_html_a01309bdeec9b97b2480d7e4ccfed9d9e"><div class="ttname"><a href="struct___i2_c_master_driver__t.html#a01309bdeec9b97b2480d7e4ccfed9d9e">_I2CMasterDriver_t::sync_obj</a></div><div class="ttdeci">TX_SEMAPHORE sync_obj</div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.h:90</div></div>
<div class="ttc" id="astruct___i2_c_master_driver_class_html_a591ff4495da99d08a8c0417e9346e23a"><div class="ttname"><a href="struct___i2_c_master_driver_class.html#a591ff4495da99d08a8c0417e9346e23a">_I2CMasterDriverClass::ip_drv_map_elements</a></div><div class="ttdeci">HWDriverMapElement_t ip_drv_map_elements[I2CDRV_CFG_HARDWARE_PERIPHERALS_COUNT]</div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.c:46</div></div>
<div class="ttc" id="astruct___i2_c_master_driver_params__t_html"><div class="ttname"><a href="struct___i2_c_master_driver_params__t.html">_I2CMasterDriverParams_t</a></div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.h:56</div></div>
<div class="ttc" id="astruct___i2_c_master_driver_class_html_a1d144e2aff08e44636321a8568f127b7"><div class="ttname"><a href="struct___i2_c_master_driver_class.html#a1d144e2aff08e44636321a8568f127b7">_I2CMasterDriverClass::vtbl</a></div><div class="ttdeci">const IIODriver_vtbl vtbl</div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.c:41</div></div>
<div class="ttc" id="a_i_i_s2_d_l_p_c_task_8h_html_aec1926412093738310c6f1f7d7dcbc7f"><div class="ttname"><a href="_i_i_s2_d_l_p_c_task_8h.html#aec1926412093738310c6f1f7d7dcbc7f">IIS2DLPCTaskAlloc</a></div><div class="ttdeci">AManagedTaskEx * IIS2DLPCTaskAlloc(const void *pIRQConfig, const void *pCSConfig)</div><div class="ttdef"><b>Definition:</b> IIS2DLPCTask.c:305</div></div>
<div class="ttc" id="astruct___h_w_driver_map_html"><div class="ttname"><a href="struct___h_w_driver_map.html">_HWDriverMap</a></div><div class="ttdef"><b>Definition:</b> HWDriverMap.h:85</div></div>
<div class="ttc" id="a_h_w_driver_map_8h_html_a18668ca483e678b8d818815e7d340086"><div class="ttname"><a href="_h_w_driver_map_8h.html#a18668ca483e678b8d818815e7d340086">HWDriverMap_Init</a></div><div class="ttdeci">static sys_error_code_t HWDriverMap_Init(HWDriverMap_t *_this, HWDriverMapElement_t *p_elements, uint16_t size)</div><div class="ttdef"><b>Definition:</b> HWDriverMap.h:111</div></div>
<div class="ttc" id="a_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_inc_2_hello_world_task_8h_html_a724a6bce41efb6088d39f9c1ed5fb13e"><div class="ttname"><a href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_inc_2_hello_world_task_8h.html#a724a6bce41efb6088d39f9c1ed5fb13e">HelloWorldTaskAlloc</a></div><div class="ttdeci">AManagedTask * HelloWorldTaskAlloc(const void *pLEDConfigMX, const void *pUBConfigMX)</div><div class="ttdef"><b>Definition:</b> HelloWorldTask.c:112</div></div>
<div class="ttc" id="a_n_u_c_l_e_o-_u575_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h_html_a1ac16d1ae236e4643f3b3a052c086356"><div class="ttname"><a href="_n_u_c_l_e_o-_u575_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a1ac16d1ae236e4643f3b3a052c086356">MX_GPIO_LEDBlueInitParams</a></div><div class="ttdeci">const MX_GPIOParams_t MX_GPIO_LEDBlueInitParams</div><div class="ttdef"><b>Definition:</b> mx.c:95</div></div>
<div class="ttc" id="a_i_i_s2_m_d_c_task_8h_html_a7996f63f7d076b61d04299b4190303f0"><div class="ttname"><a href="_i_i_s2_m_d_c_task_8h.html#a7996f63f7d076b61d04299b4190303f0">IIS2MDCTaskAlloc</a></div><div class="ttdeci">AManagedTaskEx * IIS2MDCTaskAlloc(const void *pIRQConfig, const void *pCSConfig)</div><div class="ttdef"><b>Definition:</b> IIS2MDCTask.c:298</div></div>
<div class="ttc" id="asysdebug_8h_html_a8309aceac8f7d3f306032682faea3824"><div class="ttname"><a href="sysdebug_8h.html#a8309aceac8f7d3f306032682faea3824">SYS_DBG_LEVEL_SEVERE</a></div><div class="ttdeci">#define SYS_DBG_LEVEL_SEVERE</div><div class="ttdoc">A message generated when a critical error occurs. The system probably hangs.</div><div class="ttdef"><b>Definition:</b> sysdebug.h:49</div></div>
<div class="ttc" id="astruct___i2_c_master_driver__t_html"><div class="ttname"><a href="struct___i2_c_master_driver__t.html">_I2CMasterDriver_t</a></div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.h:73</div></div>
<div class="ttc" id="a_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h_html_a464015e7e594e5874bd1df7baa01431f"><div class="ttname"><a href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a464015e7e594e5874bd1df7baa01431f">MX_GPIO_UBInitParams</a></div><div class="ttdeci">const MX_GPIOParams_t MX_GPIO_UBInitParams</div><div class="ttdef"><b>Definition:</b> mx.c:62</div></div>
<div class="ttc" id="a_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h_html_a8bc228b159d80eca3cd31e519a4aa19d"><div class="ttname"><a href="_n_u_c_l_e_o-_h7_a3_z_i-_q_2_applications_2_d_a_t_a_l_o_g2_2mx_2_inc_2mx_8h.html#a8bc228b159d80eca3cd31e519a4aa19d">MX_GPIO_INT1_DHCXInitParams</a></div><div class="ttdeci">const MX_GPIOParams_t MX_GPIO_INT1_DHCXInitParams</div><div class="ttdef"><b>Definition:</b> mx.c:106</div></div>
<div class="ttc" id="a_i2_c_master_driver__vtbl_8h_html_af1900055b64373471c28a6a03167387c"><div class="ttname"><a href="_i2_c_master_driver__vtbl_8h.html#af1900055b64373471c28a6a03167387c">I2CMasterDriver_vtblInit</a></div><div class="ttdeci">sys_error_code_t I2CMasterDriver_vtblInit(IDriver *_this, void *p_params)</div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.c:129</div></div>
<div class="ttc" id="asyserror_8h_html_a741625c706792e23dae12c911c4513f9"><div class="ttname"><a href="syserror_8h.html#a741625c706792e23dae12c911c4513f9">sys_error_code_t</a></div><div class="ttdeci">uint16_t sys_error_code_t</div><div class="ttdef"><b>Definition:</b> syserror.h:41</div></div>
<div class="ttc" id="astruct___i_i_o_driver__vtbl_html"><div class="ttname"><a href="struct___i_i_o_driver__vtbl.html">_IIODriver_vtbl</a></div><div class="ttdef"><b>Definition:</b> IIODriver_vtbl.h:43</div></div>
<div class="ttc" id="asysdebug_8h_html_adba2388ee51da1963b4846885e596b68"><div class="ttname"><a href="sysdebug_8h.html#adba2388ee51da1963b4846885e596b68">SYS_DBG_LEVEL_VERBOSE</a></div><div class="ttdeci">#define SYS_DBG_LEVEL_VERBOSE</div><div class="ttdoc">A general message for system developers.</div><div class="ttdef"><b>Definition:</b> sysdebug.h:44</div></div>
<div class="ttc" id="astruct___i2_c_master_driver_params__t_html_ab4af0eda669d9fdd1387a76ade8104f6"><div class="ttname"><a href="struct___i2_c_master_driver_params__t.html#ab4af0eda669d9fdd1387a76ade8104f6">_I2CMasterDriverParams_t::p_mx_i2c_cfg</a></div><div class="ttdeci">MX_I2CParams_t * p_mx_i2c_cfg</div><div class="ttdef"><b>Definition:</b> I2CMasterDriver.h:61</div></div>
<div class="ttc" id="a_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_inc_2stm32u5xx__hal__conf_8h_html_a631dea7b230e600555f979c62af1de21"><div class="ttname"><a href="_b-_u585_i-_i_o_t02_a_2_applications_2_d_a_t_a_l_o_g2_2_core_2_inc_2stm32u5xx__hal__conf_8h.html#a631dea7b230e600555f979c62af1de21">assert_param</a></div><div class="ttdeci">#define assert_param(expr)</div><div class="ttdoc">Include module's header file.</div><div class="ttdef"><b>Definition:</b> stm32u5xx_hal_conf.h:498</div></div>
<div class="ttc" id="astruct___i2_c_bus_task_html"><div class="ttname"><a href="struct___i2_c_bus_task.html">_I2CBusTask</a></div><div class="ttdef"><b>Definition:</b> I2CBusTask.h:59</div></div>
<div class="ttc" id="a_i_s_m330_d_h_c_x_task_8h_html_ae4d9736c9a3ae91edf943baf2215b56b"><div class="ttname"><a href="_i_s_m330_d_h_c_x_task_8h.html#ae4d9736c9a3ae91edf943baf2215b56b">ISM330DHCXTaskAlloc</a></div><div class="ttdeci">AManagedTaskEx * ISM330DHCXTaskAlloc(const void *pIRQConfig, const void *pMLCConfig, const void *pCSConfig)</div><div class="ttdef"><b>Definition:</b> ISM330DHCXTask.c:505</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 3 2023 17:27:33 for FP-SNS-DATALOG2 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
