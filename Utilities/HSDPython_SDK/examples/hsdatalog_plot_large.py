#!/usr/bin/env python
# coding: utf-8 
# *****************************************************************************
#  * @file    hsdatalog_plot_large.py
#  * @author  SRA
# ******************************************************************************
# * @attention
# *
# * Copyright (c) 2022 STMicroelectronics.
# * All rights reserved.
# *
# * This software is licensed under terms that can be found in the LICENSE file
# * in the root directory of this software component.
# * If no LICENSE file comes with this software, it is provided AS-IS.
# *
# *
# ******************************************************************************
#

"""
This script, `hsdatalog_plot_large.py`, is designed to plot data from acquisition folders
generated by STMicroelectronics' HSDatalog tool. It supports various options for customizing
the plots, including selecting specific sensors, setting time ranges, plotting raw data,
including annotations, and more.
The script also checks for required packages and notifies the user if any are missing.
It uses Dask for handling large datasets and Plotly for creating interactive plots.
The script can be run from the command line with various options to tailor the data
visualization to the user's needs.

NOTEs:
- The ensure out-of-core plots for large datasets, the script, starting from an acquisition folder,
    converts each selected sensor data to a Parquet file and then uses Dask for reading data in chunks.
- If you choose to plot all active sensors (using the `-s all` option):
    - If the -sp flag is not set, the script will plot each sensor in a dedicated browser tab
        one after the other. To display the next sensor plot is necessary to press CTRL+C in the terminal.
    - If the -sp flag is set, the script will save each sensor plot as an HTML file in the 'plots' folder
        and display all the plots simultaneously in the browser (one tab for each sensor).

Key Features:
- Plot data for specific sensors or all active components.
- Set start and end times for the data plot.
- Option to plot raw data.
- Include annotations in the plot.
- Create subplots for multi-dimensional sensors.
- Save plots as HTML files for sharing or further analysis.
- Upload and use a custom Device Template Model (DTDL).
- Enable debug mode to check for corrupted data and timestamps.
"""

import sys

print("Checking additional required packages...")

# List of required packages
required_packages = [
    "dask",
    "plotly",
    "plotly_resampler"
]

# Check for missing packages
missing_packages = []
for package in required_packages:
    try:
        __import__(package)
    except ImportError:
        missing_packages.append(package)

# Notify user of missing packages
if missing_packages:
    print("The following required packages are missing:")
    for package in missing_packages:
        if package == "dask":
            print(" - dask[dataframe]")
        else:
            print(f" - {package}")
    print("Please install the missing packages and try again.")
    sys.exit(1)

import os
import webbrowser
import dask.dataframe as dd
from plotly.subplots import make_subplots
import plotly.graph_objects as go
from plotly_resampler import FigureResampler
import click
from st_hsdatalog.HSD_utils.dtm import HSDatalogDTM
from st_hsdatalog.HSD_utils.exceptions import MissingDeviceModelError, MissingISPUOutputDescriptorException
import st_hsdatalog.HSD_utils.logger as logger
from st_hsdatalog.HSD.HSDatalog import HSDatalog

log = logger.setup_applevel_logger(is_debug = False, file_name= "app_debug.log")
script_version = "1.0.0"

def show_help(ctx, param, value):
    if value and not ctx.resilient_parsing:
        # Display the help information for the command
        click.secho(ctx.get_help(), color=ctx.color)
        # Display examples of script execution
        click.secho("\n-> Script execution examples:")
        # Example: Plot data for a specific acquisition folder
        click.secho("   python hsdatalog_plot_large.py Acquisition_Folder_Path", fg='cyan')
        # Example: Plot data for a specific sensor
        click.secho("   python hsdatalog_plot_large.py Acquisition_Folder_Path -s Sensor_Name", fg='cyan')
        # Example: Plot data with a specific start and end time
        click.secho("   python hsdatalog_plot_large.py Acquisition_Folder_Path -st 3 -et 6", fg='cyan')
        # Example: Plot raw data (not multiplied by sensitivity)
        click.secho("   python hsdatalog_plot_large.py Acquisition_Folder_Path -r", fg='cyan')
        # Example: Plot data including annotations (if any in the acquisition)
        click.secho("   python hsdatalog_plot_large.py Acquisition_Folder_Path -l", fg='cyan')
        # Example: Plot data in subplots (one subplot for each sensor axis)
        click.secho("   python hsdatalog_plot_large.py Acquisition_Folder_Path -p", fg='cyan')
        # Example: Save plots as HTML files
        click.secho("   python hsdatalog_plot_large.py Acquisition_Folder_Path -sp", fg='cyan')
        # Example: Upload a custom device model
        click.secho("   python hsdatalog_plot.py Acquisition_Folder_Path -cdm 1 2 custom_model.json", fg='cyan')
        # Example: Enable debug mode (Check Timestamp consistency)
        click.secho("   python hsdatalog_plot.py Acquisition_Folder_Path -d", fg='cyan')
        ctx.exit()

@click.command()
@click.argument('acq_folder', type=click.Path(exists=True))
@click.option('-s', '--sensor_name', help="Component name (Sensor or Algorithm) - use \"all\" to extract all active Component data, otherwise select a specific Component by name", default='')
@click.option('-st','--start_time', help="Start Time - Data plot will start from this time (seconds)", type=int, default=0)
@click.option('-et','--end_time', help="End Time - Data plot will end up in this time (seconds)", type=int, default=-1)
@click.option('-r', '--raw_data', is_flag=True, help="Uses Raw data (not multiplied by sensitivity)", default=False)
@click.option('-l', '--labeled', is_flag=True, help="Plot data including information about annotations taken during acquisition (if any)", default=False)
@click.option('-p', '--subplots', is_flag=True, help="Multiple subplot for multi-dimensional sensors", default=False)
@click.option('-sp','--save_plots', is_flag=True, help="Save plots as HTML files", default=False)
@click.option('-cdm','--custom_device_model', help="Upload a custom Device Template Model (DTDL)", type=(int, int, str))
@click.version_option(script_version, '-v', '--version', prog_name="hsdatalog_plot_large", is_flag=True, help="hsdatalog_plot_large tool version number")
@click.option('-d', '--debug', is_flag=True, help="[DEBUG] Check for corrupted data and timestamps", default=False)
@click.option("-h"," --help", is_flag=True, is_eager=True, expose_value=False, callback=show_help, help="Show this message and exit.",)

# Define the main function that will be executed when the script is run
def hsd_plot_large(acq_folder, sensor_name, start_time, end_time, raw_data, labeled, subplots, save_plots, custom_device_model, debug):

    # If a custom device model is provided, upload it using the HSDatalogDTM module
    if custom_device_model is not None:
        HSDatalogDTM.upload_custom_dtm(custom_device_model)

    # Create an instance of the HSDatalog factory
    hsd_factory = HSDatalog()
    try:
        # Create an HSDatalog object for the given acquisition folder
        hsd = hsd_factory.create_hsd(acq_folder)
    except MissingDeviceModelError as error:
        # Handle the case where the device model is missing and log the error
        log.error("Device Template Model identifyed by [{}] not supported".format(error))
        log.info("Check your input acquisition folder, then try to upload a custom Device Template Model using -cdm flag".format(error))
        return
    
    # Enable timestamp recovery if debug mode is on
    hsd.enable_timestamp_recovery(debug)

    # Main loop to plot data
    plot_flag = True
    while plot_flag:
        # If no sensor name is provided, ask the user to select a component
        if sensor_name == '':
            # If a component is selected, plot its data
            component = HSDatalog.ask_for_component(hsd, only_active=True)
            if component is not None:
                label = ask_for_label(hsd, labeled)
                plot(hsd, component, start_time, end_time, label, subplots, save_plots, raw_data, acq_folder)
            else:
                break
        # If 'all' is specified for sensor name, plot all active components
        elif sensor_name == 'all':
            component_list = HSDatalog.get_all_components(hsd, only_active=True)
            label = ask_for_label(hsd, labeled)
            for component in component_list:
                plot(hsd, component, start_time, end_time, label, subplots, save_plots, raw_data, acq_folder)
            if not labeled:
                plot_flag = False
        # If a specific sensor name is provided, plot only that component
        else:
            component = HSDatalog.get_component(hsd, sensor_name)
            if component is not None:
                label = ask_for_label(hsd, labeled)
                plot(hsd, component, start_time, end_time, label, subplots, save_plots, raw_data, acq_folder)
            else:
                # Log an error if the specified component is not found
                log.error("No \"{}\" Component to plot found in your Device Configuration file.".format(sensor_name))
                quit()
            if not labeled:
                plot_flag = False

# Define a helper function to ask the user for a label if the data is labeled
def ask_for_label(hsd, labeled):
    label = None
    if labeled:
        label_list = hsd.get_acquisition_label_classes()
        label = hsd.prompt_label_select_CLI(label_list)
        if label is not None:
            log.info(label)
        else:
            quit()
    return label

# Define a helper function to plot data for a specific component
def plot(hsd, component, start_time, end_time, label, subplots, save_plots, raw_data, acq_folder):
    try:
        # Check if labeled data is required
        labeled = label is not None
        # Get the acquisition path
        acquisition_path = HSDatalog.get_acquisition_path(hsd)
        # Get the component name
        comp_name = list(component.keys())[0]
        
        # Define the file path for the parquet file
        file_path = os.path.join(acquisition_path, f'{comp_name}.parquet')
        # Convert data to parquet format if the file does not exist
        if not os.path.exists(file_path):
            HSDatalog.convert_dat_to_xsv(hsd, component, start_time, end_time, labeled, raw_data, acquisition_path, "PARQUET")
        
        # Read the parquet file into a Dask dataframe
        dask_df = dd.read_parquet(file_path)
        
        # Get the acquisition label classes
        acq_label_classes = HSDatalog.get_acquisition_label_classes(hsd)
        # Filter columns to plot
        columns_to_plot = [item for item in dask_df.columns if item not in acq_label_classes]
        
        # Define the layout of the plot with responsive attributes
        layout = go.Layout(
            title=comp_name,
            autosize=True  # Automatically adjust the size
        )

        # Define the output directory for saving plots
        output_dir = "plots"
        os.makedirs(output_dir, exist_ok=True)

        # Iterate over each chunk of the Dask dataframe
        for chunk in dask_df.to_delayed():
            chunk = chunk.compute()
            x_column = "Time"
            # Create subplots if required
            if subplots:
                fig = make_subplots(rows=len(columns_to_plot)-1, cols=1)
            else:
                fig = go.Figure(layout=layout)

            # Add traces to the plot for each column
            for i, c in enumerate(columns_to_plot):
                if c != "Time":
                    y_column = c
                    if subplots:
                        fig.add_trace(go.Scattergl(x=chunk[x_column], y=chunk[y_column], mode='lines', name=y_column), row=i, col=1)
                    else:
                        fig.add_trace(go.Scattergl(x=chunk[x_column], y=chunk[y_column], mode='lines', name=y_column))
            
            # Add vertical rectangles for labeled data
            if labeled:
                time_tags = HSDatalog.get_time_tags(hsd, label)
                for tt in time_tags:
                    fig.add_vrect(x0=tt["time_start"], x1=tt["time_end"], 
                    annotation_text=tt["label"], annotation_position="top left",
                    fillcolor="green", opacity=0.25, line_width=2)
            
        # NOTE: Here you can remove the parquet file after plotting if needed
        # if os.path.exists(file_path):
        #     os.remove(file_path)

        # Save plots as HTML files if required
        if save_plots:
            resampler = FigureResampler(fig)
            html_file = os.path.join(output_dir, f"{comp_name}.html")
            resampler.write_html(html_file)
            # Open the HTML file in the browser
            webbrowser.open_new_tab(f"file://{os.path.abspath(html_file)}")
        else:
            # Display the plot in a web browser
            webbrowser.open_new_tab("http://127.0.0.1:8050")
            resampler = FigureResampler(fig)
            resampler.show_dash()

    except MissingISPUOutputDescriptorException as ispu_err:
        # Handle missing ISPU output descriptor exception
        log.error(ispu_err)
        log.warning("Copy the right ISPU output descriptor file in your \"{}\" acquisition folder renamed as \"ispu_output_format.json\"".format(acq_folder))
    except Exception as err:
        log.exception(err)

if __name__ == '__main__':
    # Execute the main function
    hsd_plot_large()

