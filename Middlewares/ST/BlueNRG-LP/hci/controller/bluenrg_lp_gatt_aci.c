/**
  ******************************************************************************
  * @file    bluenrg_lp_gatt_aci.c
  * @author  System Research & Applications Team - Agrate/Catania Lab.
  * @version 2.0.0
  * @date    25-September-2024
  * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode (gatt_aci)
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

#include "ble_types.h"
#include "bluenrg_lp_gatt_aci.h"
#include "hci_tl.h"

ble_status_t aci_gatt_srv_init(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x101;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_add_service_nwk(uint8_t service_uuid_type,
                                          service_uuid_t *Service_UUID,
                                          uint8_t service_type,
                                          uint8_t max_attribute_records,
                                          uint16_t *service_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_add_service_nwk_cp0 *cp0 = (aci_gatt_srv_add_service_nwk_cp0 *)(cmd_buffer);
  aci_gatt_srv_add_service_nwk_cp1 *cp1 =
    (aci_gatt_srv_add_service_nwk_cp1 *)(cmd_buffer +
                                         1 +
                                         (service_uuid_type == 1 ? 2 : (service_uuid_type == 2 ? 16 : 0)));
  aci_gatt_srv_add_service_nwk_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->service_uuid_type = HTOB(service_uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (service_uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->Service_UUID, (const void *) Service_UUID, size);
    index_input += size;
    {
      cp1->service_type = HTOB(service_type, 1);
    }
    index_input += 1;
    {
      cp1->max_attribute_records = HTOB(max_attribute_records, 1);
    }
    index_input += 1;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x102;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *service_handle = BTOH(resp.service_handle, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_include_service_nwk(uint16_t service_handle,
                                              uint16_t included_service_handle,
                                              uint16_t *include_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_include_service_nwk_cp0 *cp0 = (aci_gatt_srv_include_service_nwk_cp0 *)(cmd_buffer);
  aci_gatt_srv_include_service_nwk_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->service_handle = HTOB(service_handle, 2);
  index_input += 2;
  cp0->included_service_handle = HTOB(included_service_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x103;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *include_handle = BTOH(resp.include_handle, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_add_char_nwk(uint16_t service_handle,
                                       uint8_t char_uuid_type,
                                       char_uuid_t *char_uuid,
                                       uint16_t char_value_length,
                                       uint8_t char_properties,
                                       uint8_t security_permissions,
                                       uint8_t gatt_evt_mask,
                                       uint8_t enc_key_size,
                                       uint8_t is_variable,
                                       uint16_t *char_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_add_char_nwk_cp0 *cp0 = (aci_gatt_srv_add_char_nwk_cp0 *)(cmd_buffer);
  aci_gatt_srv_add_char_nwk_cp1 *cp1 =
    (aci_gatt_srv_add_char_nwk_cp1 *)(cmd_buffer + 2 + 1 + (char_uuid_type == 1 ? 2 : (char_uuid_type == 2 ? 16 : 0)));
  aci_gatt_srv_add_char_nwk_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->service_handle = HTOB(service_handle, 2);
  index_input += 2;
  cp0->char_uuid_type = HTOB(char_uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (char_uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->char_uuid, (const void *) char_uuid, size);
    index_input += size;
    {
      cp1->char_value_length = HTOB(char_value_length, 2);
    }
    index_input += 2;
    {
      cp1->char_properties = HTOB(char_properties, 1);
    }
    index_input += 1;
    {
      cp1->security_permissions = HTOB(security_permissions, 1);
    }
    index_input += 1;
    {
      cp1->gatt_evt_mask = HTOB(gatt_evt_mask, 1);
    }
    index_input += 1;
    {
      cp1->enc_key_size = HTOB(enc_key_size, 1);
    }
    index_input += 1;
    {
      cp1->is_variable = HTOB(is_variable, 1);
    }
    index_input += 1;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x104;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *char_handle = BTOH(resp.char_handle, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_add_char_desc_nwk(uint16_t char_handle,
                                            uint8_t char_desc_uuid_type,
                                            char_desc_uuid_t *char_desc_uuid,
                                            uint16_t char_desc_value_max_len,
                                            uint16_t char_desc_value_length,
                                            uint8_t char_desc_value[],
                                            uint8_t security_permissions,
                                            uint8_t access_permissions,
                                            uint8_t gatt_evt_mask,
                                            uint8_t enc_key_size,
                                            uint8_t is_variable,
                                            uint16_t *char_desc_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_add_char_desc_nwk_cp0 *cp0 = (aci_gatt_srv_add_char_desc_nwk_cp0 *)(cmd_buffer);
  aci_gatt_srv_add_char_desc_nwk_cp1 *cp1 =
    (aci_gatt_srv_add_char_desc_nwk_cp1 *)(cmd_buffer +
                                           2 +
                                           1 +
                                           (char_desc_uuid_type == 1 ? 2 : (char_desc_uuid_type == 2 ? 16 : 0)));
  aci_gatt_srv_add_char_desc_nwk_cp2 *cp2 =
    (aci_gatt_srv_add_char_desc_nwk_cp2 *)(cmd_buffer +
                                           2 +
                                           1 +
                                           (char_desc_uuid_type == 1 ? 2 : (char_desc_uuid_type == 2 ? 16 : 0)) +
                                           2 +
                                           2 +
                                           char_desc_value_length * (sizeof(uint8_t)));
  aci_gatt_srv_add_char_desc_nwk_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->char_handle = HTOB(char_handle, 2);
  index_input += 2;
  cp0->char_desc_uuid_type = HTOB(char_desc_uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (char_desc_uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->char_desc_uuid, (const void *) char_desc_uuid, size);
    index_input += size;
    {
      cp1->char_desc_value_max_len = HTOB(char_desc_value_max_len, 2);
    }
    index_input += 2;
    {
      cp1->char_desc_value_length = HTOB(char_desc_value_length, 2);
    }
    index_input += 2;
    BLUENRG_MEMCPY((void *) &cp1->char_desc_value, (const void *) char_desc_value,
                   char_desc_value_length * sizeof(uint8_t));
    index_input += char_desc_value_length * sizeof(uint8_t);
    {
      cp2->security_permissions = HTOB(security_permissions, 1);
    }
    index_input += 1;
    {
      cp2->access_permissions = HTOB(access_permissions, 1);
    }
    index_input += 1;
    {
      cp2->gatt_evt_mask = HTOB(gatt_evt_mask, 1);
    }
    index_input += 1;
    {
      cp2->enc_key_size = HTOB(enc_key_size, 1);
    }
    index_input += 1;
    {
      cp2->is_variable = HTOB(is_variable, 1);
    }
    index_input += 1;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x105;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *char_desc_handle = BTOH(resp.char_desc_handle, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_write_handle_value_nwk(uint16_t attr_handle,
                                                 uint16_t val_offset,
                                                 uint16_t value_length,
                                                 uint8_t value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_write_handle_value_nwk_cp0 *cp0 = (aci_gatt_srv_write_handle_value_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  cp0->value_length = HTOB(value_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->value, (const void *) value, value_length * sizeof(uint8_t));
    index_input += value_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x106;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_rm_char_nwk(uint16_t char_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_rm_char_nwk_cp0 *cp0 = (aci_gatt_srv_rm_char_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->char_handle = HTOB(char_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x107;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_rm_service_nwk(uint16_t serv_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_rm_service_nwk_cp0 *cp0 = (aci_gatt_srv_rm_service_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->serv_handle = HTOB(serv_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x108;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_rm_include_service_nwk(uint16_t include_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_rm_include_service_nwk_cp0 *cp0 = (aci_gatt_srv_rm_include_service_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->include_handle = HTOB(include_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x109;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_set_event_mask(uint32_t gatt_evt_mask)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_set_event_mask_cp0 *cp0 = (aci_gatt_set_event_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->gatt_evt_mask = HTOB(gatt_evt_mask, 4);
  index_input += 4;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x10a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_exchange_config(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_exchange_config_cp0 *cp0 = (aci_gatt_clt_exchange_config_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x10b;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_prepare_write_req(uint16_t connection_handle,
                                            uint16_t attr_handle,
                                            uint16_t val_offset,
                                            uint16_t attribute_val_length,
                                            uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_prepare_write_req_cp0 *cp0 = (aci_gatt_clt_prepare_write_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x110;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_execute_write_req(uint16_t connection_handle,
                                            uint8_t execute)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_execute_write_req_cp0 *cp0 = (aci_gatt_clt_execute_write_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->execute = HTOB(execute, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x111;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_disc_all_primary_services(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_disc_all_primary_services_cp0 *cp0 = (aci_gatt_clt_disc_all_primary_services_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x112;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_disc_primary_service_by_uuid(uint16_t connection_handle,
                                                       uint8_t uuid_type,
                                                       uuid_t *uuid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_disc_primary_service_by_uuid_cp0 *cp0 = (aci_gatt_clt_disc_primary_service_by_uuid_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->uuid_type = HTOB(uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->uuid, (const void *) uuid, size);
    index_input += size;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x113;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_find_included_services(uint16_t connection_handle,
                                                 uint16_t start_handle,
                                                 uint16_t end_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_find_included_services_cp0 *cp0 = (aci_gatt_clt_find_included_services_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x114;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_disc_all_char_of_service(uint16_t connection_handle,
                                                   uint16_t start_handle,
                                                   uint16_t end_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_disc_all_char_of_service_cp0 *cp0 = (aci_gatt_clt_disc_all_char_of_service_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x115;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_disc_char_by_uuid(uint16_t connection_handle,
                                            uint16_t start_handle,
                                            uint16_t end_handle,
                                            uint8_t uuid_type,
                                            uuid_t *uuid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_disc_char_by_uuid_cp0 *cp0 = (aci_gatt_clt_disc_char_by_uuid_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  cp0->uuid_type = HTOB(uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->uuid, (const void *) uuid, size);
    index_input += size;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x116;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_disc_all_char_desc(uint16_t connection_handle,
                                             uint16_t char_handle,
                                             uint16_t end_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_disc_all_char_desc_cp0 *cp0 = (aci_gatt_clt_disc_all_char_desc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->char_handle = HTOB(char_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x117;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_read(uint16_t connection_handle,
                               uint16_t attr_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_read_cp0 *cp0 = (aci_gatt_clt_read_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x118;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_read_using_char_uuid(uint16_t connection_handle,
                                               uint16_t start_handle,
                                               uint16_t end_handle,
                                               uint8_t uuid_type,
                                               uuid_t *uuid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_read_using_char_uuid_cp0 *cp0 = (aci_gatt_clt_read_using_char_uuid_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  cp0->uuid_type = HTOB(uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->uuid, (const void *) uuid, size);
    index_input += size;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x119;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_read_long(uint16_t connection_handle,
                                    uint16_t attr_handle,
                                    uint16_t val_offset)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_read_long_cp0 *cp0 = (aci_gatt_clt_read_long_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11a;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_read_multiple_char_value(uint16_t connection_handle,
                                                   uint8_t number_of_handles,
                                                   handle_entry_t handle_entry[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_read_multiple_char_value_cp0 *cp0 = (aci_gatt_clt_read_multiple_char_value_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->number_of_handles = HTOB(number_of_handles, 1);
  index_input += 1;
  /* var_len_data input */
  {
    for (uint32_t index = 0; index < number_of_handles; index++)
    {
      cp0->handle_entry[index].handle = handle_entry[index].handle;
    }
    index_input += number_of_handles * 2;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11b;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_write_nwk(uint16_t connection_handle,
                                    uint16_t attr_handle,
                                    uint16_t attribute_val_length,
                                    uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_write_nwk_cp0 *cp0 = (aci_gatt_clt_write_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11c;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_write_long_nwk(uint16_t connection_handle,
                                         uint16_t attr_handle,
                                         uint16_t val_offset,
                                         uint16_t attribute_val_length,
                                         uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_write_long_nwk_cp0 *cp0 = (aci_gatt_clt_write_long_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_write_char_reliable_nwk(uint16_t connection_handle,
                                                  uint16_t attr_handle,
                                                  uint16_t val_offset,
                                                  uint16_t attribute_val_length,
                                                  uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_write_char_reliable_nwk_cp0 *cp0 = (aci_gatt_clt_write_char_reliable_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11e;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_write_without_resp(uint16_t connection_handle,
                                             uint16_t attr_handle,
                                             uint16_t attribute_val_length,
                                             uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_write_without_resp_cp0 *cp0 = (aci_gatt_clt_write_without_resp_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x123;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_signed_write_without_resp(uint16_t connection_handle,
                                                    uint16_t attr_handle,
                                                    uint16_t attribute_val_length,
                                                    uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_signed_write_without_resp_cp0 *cp0 = (aci_gatt_clt_signed_write_without_resp_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x124;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_clt_confirm_indication(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_confirm_indication_cp0 *cp0 = (aci_gatt_clt_confirm_indication_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x125;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_set_security_permission_nwk(uint16_t attr_handle,
                                                      uint8_t security_permissions)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_set_security_permission_nwk_cp0 *cp0 = (aci_gatt_srv_set_security_permission_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->security_permissions = HTOB(security_permissions, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x128;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_read_handle_value_nwk(uint16_t attr_handle,
                                                uint16_t offset,
                                                uint16_t value_length_requested,
                                                uint16_t *length,
                                                uint16_t *value_length,
                                                uint8_t value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_read_handle_value_nwk_cp0 *cp0 = (aci_gatt_srv_read_handle_value_nwk_cp0 *)(cmd_buffer);
  aci_gatt_srv_read_handle_value_nwk_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->offset = HTOB(offset, 2);
  index_input += 2;
  cp0->value_length_requested = HTOB(value_length_requested, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x12a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *length = BTOH(resp.length, 2);
  *value_length = BTOH(resp.value_length, 2);
  BLUENRG_MEMCPY((void *) value, (const void *) resp.value, *value_length * sizeof(uint8_t));
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_set_access_permission_nwk(uint16_t attr_handle,
                                                    uint8_t access_permissions)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_set_access_permission_nwk_cp0 *cp0 = (aci_gatt_srv_set_access_permission_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->access_permissions = HTOB(access_permissions, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x12e;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_notify(uint16_t connection_handle,
                                 uint16_t attr_handle,
                                 uint8_t flags,
                                 uint16_t val_length,
                                 uint8_t val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_notify_cp0 *cp0 = (aci_gatt_srv_notify_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->flags = HTOB(flags, 1);
  index_input += 1;
  cp0->val_length = HTOB(val_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->val, (const void *) val, val_length * sizeof(uint8_t));
    index_input += val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x12f;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_exec_write_resp_nwk(uint16_t conn_handle,
                                              uint8_t exec)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_exec_write_resp_nwk_cp0 *cp0 = (aci_gatt_srv_exec_write_resp_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->conn_handle = HTOB(conn_handle, 2);
  index_input += 2;
  cp0->exec = HTOB(exec, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x131;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_authorize_resp_nwk(uint16_t conn_handle,
                                             uint16_t attr_handle,
                                             uint8_t operation_type,
                                             uint8_t error_code,
                                             uint16_t attr_val_offset,
                                             uint16_t data_length,
                                             uint8_t data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_authorize_resp_nwk_cp0 *cp0 = (aci_gatt_srv_authorize_resp_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->conn_handle = HTOB(conn_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->operation_type = HTOB(operation_type, 1);
  index_input += 1;
  cp0->error_code = HTOB(error_code, 1);
  index_input += 1;
  cp0->attr_val_offset = HTOB(attr_val_offset, 2);
  index_input += 2;
  cp0->data_length = HTOB(data_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->data, (const void *) data, data_length * sizeof(uint8_t));
    index_input += data_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x133;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_read_prepare_queue_nwk(uint16_t conn_handle,
                                                 uint8_t item_index,
                                                 uint16_t *attr_handle,
                                                 uint16_t *value_offset,
                                                 uint16_t *value_length,
                                                 uint8_t value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_read_prepare_queue_nwk_cp0 *cp0 = (aci_gatt_srv_read_prepare_queue_nwk_cp0 *)(cmd_buffer);
  aci_gatt_srv_read_prepare_queue_nwk_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->conn_handle = HTOB(conn_handle, 2);
  index_input += 2;
  cp0->item_index = HTOB(item_index, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x135;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *attr_handle = BTOH(resp.attr_handle, 2);
  *value_offset = BTOH(resp.value_offset, 2);
  *value_length = BTOH(resp.value_length, 2);
  BLUENRG_MEMCPY((void *) value, (const void *) resp.value, *value_length * sizeof(uint8_t));
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_write_multiple_instance_handle_value(uint16_t connection_handle,
                                                               uint16_t attr_handle,
                                                               uint16_t value_length,
                                                               uint8_t value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_write_multiple_instance_handle_value_cp0 *cp0 =
    (aci_gatt_srv_write_multiple_instance_handle_value_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->value_length = HTOB(value_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->value, (const void *) value, value_length * sizeof(uint8_t));
    index_input += value_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x136;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_srv_read_multiple_instance_handle_value_nwk(uint16_t connection_handle,
                                                                  uint16_t attr_handle,
                                                                  uint16_t *value_length,
                                                                  uint8_t value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0 *cp0 =
    (aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0 *)(cmd_buffer);
  aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x137;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *value_length = BTOH(resp.value_length, 2);
  BLUENRG_MEMCPY((void *) value, (const void *) resp.value, *value_length * sizeof(uint8_t));
  return BLE_STATUS_SUCCESS;
}
