/**
  ******************************************************************************
  * @file    bluenrg_lp_gap_aci.c
  * @author  System Research & Applications Team - Agrate/Catania Lab.
  * @version 2.0.0
  * @date    25-September-2024
  * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode (gap_aci)
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

#include "ble_types.h"
#include "bluenrg_lp_gap_aci.h"
#include "hci_tl.h"

/**
  * @brief Set the IO capabilities of the device. This command cannot be sent
  *        during a pairing procedure.
  * @param io_capability IO capability of the device.
  *        Values:
  *        - 0x00: IO_CAP_DISPLAY_ONLY
  *        - 0x01: IO_CAP_DISPLAY_YES_NO
  *        - 0x02: IO_CAP_KEYBOARD_ONLY
  *        - 0x03: IO_CAP_NO_INPUT_NO_OUTPUT
  *        - 0x04: IO_CAP_KEYBOARD_DISPLAY
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_io_capability(uint8_t io_capability)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_io_capability_cp0 *cp0 = (aci_gap_set_io_capability_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->io_capability = HTOB(io_capability, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x085;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Set the authentication requirements for the device. If the command is
  *        given during pairing, the command returns  BLE_STATUS_NOT_ALLOWED.
  * @param bonding_mode Bonding mode. Only if bonding is enabled (0x01), the
  *        bonding information is stored in flash
  *        Values:
  *        - 0x00: NO_BONDING
  *        - 0x01: BONDING
  * @param mitm_mode MITM mode.
  *        Values:
  *        - 0x00: MITM_PROTECTION_NOT_REQUIRED
  *        - 0x01: MITM_PROTECTION_REQUIRED
  * @param sc_support LE Secure connections support. - 0x00: Secure Connections
  *        Pairing not supported - 0x01: Secure Connections Pairing supported but
  *        optional - 0x02: Secure Connections Pairing supported and mandatory
  *        (SC Only Mode)
  *        Values:
  *        - 0x00: SC_IS_NOT_SUPPORTED
  *        - 0x01: SC_IS_SUPPORTED
  *        - 0x02: SC_IS_MANDATORY
  * @param key_press_notification_support Keypress notification support
  *        Values:
  *        - 0x00: KEYPRESS_IS_NOT_SUPPORTED
  *        - 0x01: KEYPRESS_IS_SUPPORTED
  * @param min_encryption_key_size Minimum encryption key size to be used during
  *        pairing
  *        Values:
  *        - 7 ... 16
  * @param max_encryption_key_size Maximum encryption key size to be used during
  *        pairing
  *        Values:
  *        - 7 ... 16
  * @param use_fixed_pin Use or not fixed pin. If set to 0x00, then during the
  *        pairing process the application will not be requested for a pin
  *        (fixed_pin will be used). If set to 0x01, then during pairing process
  *        if a passkey is required the application will be notified
  *        Values:
  *        - 0x00: USE_FIXED_PIN_FOR_PAIRING
  *        - 0x01: DONOT_USE_FIXED_PIN_FOR_PAIRING
  * @param fixed_pin Fixed pin to be used during pairing if MIMT protection is
  *        enabled. Any random value between 0 to 999999
  *        Values:
  *        - 0 ... 999999
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_authentication_requirement(uint8_t bonding_mode,
                                                    uint8_t mitm_mode,
                                                    uint8_t sc_support,
                                                    uint8_t key_press_notification_support,
                                                    uint8_t min_encryption_key_size,
                                                    uint8_t max_encryption_key_size,
                                                    uint8_t use_fixed_pin,
                                                    uint32_t fixed_pin)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_authentication_requirement_cp0 *cp0 = (aci_gap_set_authentication_requirement_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->bonding_mode = HTOB(bonding_mode, 1);
  index_input += 1;
  cp0->mitm_mode = HTOB(mitm_mode, 1);
  index_input += 1;
  cp0->sc_support = HTOB(sc_support, 1);
  index_input += 1;
  cp0->key_press_notification_support = HTOB(key_press_notification_support, 1);
  index_input += 1;
  cp0->min_encryption_key_size = HTOB(min_encryption_key_size, 1);
  index_input += 1;
  cp0->max_encryption_key_size = HTOB(max_encryption_key_size, 1);
  index_input += 1;
  cp0->use_fixed_pin = HTOB(use_fixed_pin, 1);
  index_input += 1;
  cp0->fixed_pin = HTOB(fixed_pin, 4);
  index_input += 4;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x086;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Set the authorization requirements of the device. This command has to
  *        be given when connected to a device if authorization is required to
  *        access services which require authorization. DEPRECATED API (still
  *        supported but not recommended)
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param authorization_enable Enable the authorization in the device and when a
  *        remote device tries to read/write a characteristic with authorization
  *        requirements, the stack will send back an error response with
  *        "Insufficient authorization" error code. After pairing is complete a
  *        ACI_GAP_AUTHORIZATION_REQ_EVENT will be sent to the Host.
  *        Values:
  *        - 0x00: AUTHORIZATION_NOT_REQUIRED
  *        - 0x01: AUTHORIZATION_REQUIRED
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_authorization_requirement(uint16_t connection_handle,
                                                   uint8_t authorization_enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_authorization_requirement_cp0 *cp0 = (aci_gap_set_authorization_requirement_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->authorization_enable = HTOB(authorization_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x087;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This command should be send by the host in response to @ref
  *        aci_gap_pass_key_req_event event. The command parameter contains the
  *        pass key which will be used during the pairing process.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param pass_key Pass key that will be used during the pairing process.  Must
  *        be a six-digit decimal number.
  *        Values:
  *        - 0 ... 999999
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_pass_key_resp(uint16_t connection_handle,
                                   uint32_t pass_key)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_pass_key_resp_cp0 *cp0 = (aci_gap_pass_key_resp_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->pass_key = HTOB(pass_key, 4);
  index_input += 4;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x088;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Authorize a device to access attributes. This command should be send
  *        by the host in response to @ref aci_gap_authorization_req_event event.
  *        DEPRECATED API (still supported but not recommended)
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param authorize Authorization response.
  *        Values:
  *        - 0x01: Authorize
  *        - 0x02: Reject
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_authorization_resp(uint16_t connection_handle,
                                        uint8_t authorize)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_authorization_resp_cp0 *cp0 = (aci_gap_authorization_resp_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->authorize = HTOB(authorize, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x089;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Initialize the GAP layer. Register the GAP service with the GATT.
  *        Depending on the role, presence of standard GAP characteristics will
  *        be checked (Device Name, Appearance, Peripheral Preferred Connection
  *        Parameters).  WARNING: A section of the Flash memory is used by this
  *        procedure. When this section is empty, data are written inside. This
  *        normally happens once during the lifetime of the device, when the
  *        command is executed for the first time (unless the section is erased).
  *        Do not power off the device while this function is writing into Flash
  *        memory.
  * @param role Bitmap of allowed roles.
  *        Flags:
  *        - 0x01: Peripheral
  *        - 0x02: Broadcaster
  *        - 0x04: Central
  *        - 0x08: Observer
  * @param privacy_type Specify if privacy is enabled or not and which one .
  *        Values:
  *        - 0x00: Privacy disabled
  *        - 0x01: Privacy host enabled
  *        - 0x02: Privacy controller enabled
  * @param device_name_char_len Length of the device name characteristic
  *        Values:
  *        - 0 ... 248
  * @param identity_address_type Specify which address has to be used as Identity
  *        Address. 0x00: The public address is used as identity address 0x01:
  *        The static random address is used as identity address
  *        Values:
  *        - 0x00: Public Address
  *        - 0x01: Static Random Address
  * @param[out] service_handle Handle of the GAP service
  * @param[out] dev_name_char_handle Device Name Characteristic handle
  * @param[out] appearance_char_handle Appearance Characteristic handle
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_init(uint8_t role,
                          uint8_t privacy_type,
                          uint8_t device_name_char_len,
                          uint8_t identity_address_type,
                          uint16_t *service_handle,
                          uint16_t *dev_name_char_handle,
                          uint16_t *appearance_char_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_init_cp0 *cp0 = (aci_gap_init_cp0 *)(cmd_buffer);
  aci_gap_init_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->role = HTOB(role, 1);
  index_input += 1;
  cp0->privacy_type = HTOB(privacy_type, 1);
  index_input += 1;
  cp0->device_name_char_len = HTOB(device_name_char_len, 1);
  index_input += 1;
  cp0->identity_address_type = HTOB(identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x08a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *service_handle = BTOH(resp.service_handle, 2);
  *dev_name_char_handle = BTOH(resp.dev_name_char_handle, 2);
  *appearance_char_handle = BTOH(resp.appearance_char_handle, 2);
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Send a slave security request to the master. This command has to be
  *        issued to notify the master of the security requirements of the slave.
  *        The master may encrypt the link, initiate the pairing procedure, or
  *        reject the request.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_slave_security_req(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_slave_security_req_cp0 *cp0 = (aci_gap_slave_security_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x08d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This command can be used to get the current security settings of the
  *        device.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param[out] security_mode Security mode.
  *             Values:
  *             - 0x01: Security Mode 1
  *             - 0x02: Security Mode 2
  * @param[out] security_level Security Level.
  *             Values:
  *             - 0x01: Security Level 1
  *             - 0x02: Security Level 2
  *             - 0x03: Security Level 3
  *             - 0x04: Security Level 4
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_get_security_level(uint16_t connection_handle,
                                        uint8_t *security_mode,
                                        uint8_t *security_level)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_get_security_level_cp0 *cp0 = (aci_gap_get_security_level_cp0 *)(cmd_buffer);
  aci_gap_get_security_level_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x090;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *security_mode = BTOH(resp.security_mode, 1);
  *security_level = BTOH(resp.security_level, 1);
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief It allows masking events from the GAP. The default configuration is
  *        all the events masked.
  * @param gap_evt_mask GAP event mask. Default: 0xFFFF.
  *        Flags:
  *        - 0x0000: No events
  *        - 0x0001: ACI_GAP_LIMITED_DISCOVERABLE_EVENT
  *        - 0x0002: ACI_GAP_PAIRING_COMPLETE_EVENT
  *        - 0x0004: ACI_GAP_PASS_KEY_REQ_EVENT
  *        - 0x0008: ACI_GAP_AUTHORIZATION_REQ_EVENT
  *        - 0x0010: ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT
  *        - 0x0020: ACI_GAP_BOND_LOST_EVENT
  *        - 0x0080: ACI_GAP_PROC_COMPLETE_EVENT
  *        - 0x0100: ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT
  *        - 0x0200: ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT
  *        - 0x0400: ACI_L2CAP_PROC_TIMEOUT_EVENT
  *        - 0x0800: ACI_GAP_ADDR_NOT_RESOLVED_EVENT
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_event_mask(uint16_t gap_evt_mask)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_event_mask_cp0 *cp0 = (aci_gap_set_event_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->gap_evt_mask = HTOB(gap_evt_mask, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x091;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Command the controller to terminate the connection. A @ref
  *        hci_disconnection_complete_event event will be generated when the link
  *        is disconnected. It is important to leave an 100 ms blank window
  *        before sending any new command (including system hardware reset),
  *        since immediately after @ref hci_disconnection_complete_event event,
  *        system could save important information in non volatile memory.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param reason The reason for ending the connection.
  *        Values:
  *        - 0x05: Authentication Failure
  *        - 0x13: Remote User Terminated Connection
  *        - 0x14: Remote Device Terminated Connection due to Low Resources
  *        - 0x15: Remote Device Terminated Connection due to Power Off
  *        - 0x1A: Unsupported Remote Feature
  *        - 0x3B: Unacceptable Connection Parameters
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_terminate(uint16_t connection_handle,
                               uint8_t reason)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_terminate_cp0 *cp0 = (aci_gap_terminate_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->reason = HTOB(reason, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x093;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Clear the security database. All the devices in the security database
  *        will be removed. ATTENTION: It is strongly recommended not to give
  *        this command during intense radio activity (e.g. during advertising or
  *        connection with short intervals, i.e. less than 30 ms, or during
  *        scanning), since it will trigger an erase of a Flash sector. After
  *        this command, all devices previously recorded in the bonding table and
  *        connected when command has been submitted will remain connected,
  *        preserving authentication and encryption of the link.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_clear_security_db(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x094;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Allows the security manager to complete the pairing procedure and re-
  *        bond with the master. This command should be given by the application
  *        when it receives the ACI_GAP_BOND_LOST_EVENT if it wants the re-
  *        bonding to happen successfully. If this command is not given on
  *        receiving the event, the bonding procedure will timeout.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_allow_rebond(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_allow_rebond_cp0 *cp0 = (aci_gap_allow_rebond_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x095;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Creates a direct connection to a device.
  * @param initiating_phy PHYs that will be used for initiating the connection.
  *        Flags:
  *        - 0x01: LE_1M_PHY_BIT
  *        - 0x04: LE_CODED_PHY_BIT
  * @param peer_address_type The peer_address_type parameter indicates the type
  *        of address used in the connectable advertisement sent by the peer. 0:
  *        Public Device Address or Public Identity Address 1: Random Device
  *        Address or Random (static) Identity Address
  *        Values:
  *        - 0x00: Public Address
  *        - 0x01: Random Address
  * @param peer_address Public Device Address, Random Device Address, Public
  *        Identity Address, or Random (static) Identity Address of the device to
  *        be connected.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_create_connection(uint8_t initiating_phy,
                                       uint8_t peer_address_type,
                                       uint8_t peer_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_create_connection_cp0 *cp0 = (aci_gap_create_connection_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->initiating_phy = HTOB(initiating_phy, 1);
  index_input += 1;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09c;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Terminate the specified GAP procedure. An @ref
  *        aci_gap_proc_complete_event event is generated when the procedure has
  *        been completed, with the procedure code set to the corresponding
  *        procedure.
  * @param procedure_code Code identifying the procedure.
  *        Values:
  *        - 0x00: GAP_LIMITED_DISCOVERY_PROC
  *        - 0x01: GAP_GENERAL_DISCOVERY_PROC
  *        - 0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x05: GAP_OBSERVATION_PROC
  *        - 0x06: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x07: GAP_NAME_DISCOVERY_PROC
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_terminate_proc(uint8_t procedure_code)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_terminate_proc_cp0 *cp0 = (aci_gap_terminate_proc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->procedure_code = HTOB(procedure_code, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Start the connection update procedure (only when role is Master). A
  *        @ref hci_le_connection_update is called. On completion of the
  *        procedure, an @ref hci_le_connection_update_complete_event event is
  *        returned to the upper layer.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param conn_interval_min Minimum value for the connection event interval.
  *        This shall be less than or equal to conn_interval_max. Time = N * 1.25
  *        msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_interval_max Maximum value for the connection event interval.
  *        This shall be greater than or equal to conn_interval_min. Time = N *
  *        1.25 msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param supervision_timeout Supervision timeout for the LE Link. It shall be a
  *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
  *        connInterval * 2. Time = N * 10 msec.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @param minimum_ce_length Information parameter about the minimum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @param maximum_ce_length Information parameter about the maximum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_connection_update(uint16_t connection_handle,
                                             uint16_t conn_interval_min,
                                             uint16_t conn_interval_max,
                                             uint16_t conn_latency,
                                             uint16_t supervision_timeout,
                                             uint16_t minimum_ce_length,
                                             uint16_t maximum_ce_length)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_start_connection_update_cp0 *cp0 = (aci_gap_start_connection_update_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09e;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Send the SM pairing request to start a pairing process. The
  *        authentication requirements and IO capabilities should be set before
  *        issuing this command using the @ref aci_gap_set_io_capability and @ref
  *        aci_gap_set_authentication_requirement commands. A @ref
  *        aci_gap_pairing_complete_event event is returned after the pairing
  *        process is completed.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param force_rebond If 1, Pairing request will be sent even if the device was
  *        previously bonded,  otherwise pairing request is not sent.
  *        Values:
  *        - 0x00: NO
  *        - 0x01: YES
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_send_pairing_req(uint16_t connection_handle,
                                      uint8_t force_rebond)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_send_pairing_req_cp0 *cp0 = (aci_gap_send_pairing_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->force_rebond = HTOB(force_rebond, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09f;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This command tries to resolve the address provided with the IRKs
  *        present in its database. If the address is resolved successfully with
  *        any one of the IRKs present in the database, it returns success and
  *        also the corresponding public/static random address stored with the
  *        IRK in the database.
  * @param address Address to be resolved
  * @param[out] actual_address The public or static random address of the peer
  *             device, distributed during pairing phase.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_resolve_private_addr(uint8_t address[6],
                                          uint8_t actual_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_resolve_private_addr_cp0 *cp0 = (aci_gap_resolve_private_addr_cp0 *)(cmd_buffer);
  aci_gap_resolve_private_addr_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->address, (const void *) address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a0;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) actual_address, (const void *) resp.actual_address, 6);
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This command returns the identity addresses of the bonded devices.
  * @param offset Index of the first record to be returned.
  * @param max_num_of_addresses Used to specify the maximum number of devices to
  *        be returned.
  * @param[out] num_of_addresses The number of bonded devices returned by this
  *             command.
  * @param[out] bonded_device_entry See @ref bonded_device_entry_t
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_get_bonded_devices(uint8_t offset,
                                        uint8_t max_num_of_addresses,
                                        uint8_t *num_of_addresses,
                                        bonded_device_entry_t bonded_device_entry[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_get_bonded_devices_cp0 *cp0 = (aci_gap_get_bonded_devices_cp0 *)(cmd_buffer);
  aci_gap_get_bonded_devices_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->offset = HTOB(offset, 1);
  index_input += 1;
  cp0->max_num_of_addresses = HTOB(max_num_of_addresses, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a3;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *num_of_addresses = BTOH(resp.num_of_addresses, 1);
  BLUENRG_MEMCPY((void *) bonded_device_entry, (const void *) resp.bonded_device_entry,
                 *num_of_addresses * sizeof(bonded_device_entry_t));
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The command finds whether the device, whose address is specified in
  *        the command, is bonded. If the device is using a resolvable private
  *        address and it has been bonded, then the command will return
  *        BLE_STATUS_SUCCESS.
  * @param peer_address_type Address type.
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  * @param peer_address Address used by the peer device while advertising
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_is_device_bonded(uint8_t peer_address_type,
                                      uint8_t peer_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_is_device_bonded_cp0 *cp0 = (aci_gap_is_device_bonded_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a4;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This command allows the User to validate/confirm or not the Numeric
  *        Comparison value showed through the
  *        ACI_GAP_Numeric_Comparison_Value_Event.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param confirm_yes_no 0 : The Numeric Values showed on both local and peer
  *        device are different! 1 : The Numeric Values showed on both local and
  *        peer device are equal!
  *        Values:
  *        - 0x00: No
  *        - 0x01: YES
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_numeric_comparison_value_confirm_yesno(uint16_t connection_handle,
                                                            uint8_t confirm_yes_no)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_numeric_comparison_value_confirm_yesno_cp0 *cp0 =
    (aci_gap_numeric_comparison_value_confirm_yesno_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->confirm_yes_no = HTOB(confirm_yes_no, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a5;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This command permits to signal to the Stack the input type detected
  *        during Passkey input.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param input_type Passkey input type detected
  *        Values:
  *        - 0x00: Passkey entry started
  *        - 0x01: Passkey digit entered
  *        - 0x02: Passkey digit erased
  *        - 0x03: Passkey cleared
  *        - 0x04: Passkey entry completed
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_passkey_input(uint16_t connection_handle,
                                   uint8_t input_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_passkey_input_cp0 *cp0 = (aci_gap_passkey_input_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->input_type = HTOB(input_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a6;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This command is sent by the User to get (i.e. to extract from the
  *        Stack) the OOB data generated by the Stack itself. In a complete
  *        system (i.e. having an OOB channel fully handled) this command should
  *        be invoked by the OOB Channel manager to require the local OOB data
  *        (hence without user interaction) to be sent via OOB to the remote peer
  *        candidate device. The requested OOB data are returned in response to
  *        the incoming command. The OOB data are not generated on the fly, but
  *        they are already available in the Stack.
  * @param oob_data_type OOB Data type. - 0x00: Legacy Privacy (LP) v.4.1 TK
  *        (Temporary Key) - 0x01: Secure Connections (SC) v.4.2 Random value r
  *        used for generation of Confirm value - 0x02: Secure Connections (SC)
  *        v.4.2 Confirm value C generated through AES-CMAC-128 based
  *        cryptographic function: C=f4(PKx, PKx, r, 0)
  *        Values:
  *        - 0x00: SM_TK
  *        - 0x01: SM_RANDOM_VALUE
  *        - 0x02: SM_CONFIRM_VALUE
  * @param[out] address_type Identity address type.
  *             Values:
  *             - 0x00: Public Identity Address
  *             - 0x01: Random (static) Identity Address
  * @param[out] address Public or Random (static) address of this  device
  * @param[out] oob_data_len Length of OOB Data carried by next data field
  * @param[out] oob_data OOB Data to be exported via OOB.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_get_oob_data(uint8_t oob_data_type,
                                  uint8_t *address_type,
                                  uint8_t address[6],
                                  uint8_t *oob_data_len,
                                  uint8_t oob_data[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_get_oob_data_cp0 *cp0 = (aci_gap_get_oob_data_cp0 *)(cmd_buffer);
  aci_gap_get_oob_data_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->oob_data_type = HTOB(oob_data_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a7;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *address_type = BTOH(resp.address_type, 1);
  BLUENRG_MEMCPY((void *) address, (const void *) resp.address, 6);
  *oob_data_len = BTOH(resp.oob_data_len, 1);
  BLUENRG_MEMCPY((void *) oob_data, (const void *) resp.oob_data, 16);
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This command is sent (by the User) to input the OOB data arrived via
  *        OOB communication. It may be sent to set either the OOB Authentication
  *        data of the Local device, or the data received via OOB by the Remote
  *        peer candidate device. It can be used with oob_data_len set to 0 to
  *        generate OOB authentication data for Secure Connections. In a complete
  *        system (i.e. having an OOB channel fully handled) this command should
  *        be invoked by the OOB Channel manager when receiving the OOB data
  *        (hence without user interaction). Since the BLE stack v 2.x
  *        implementation supports just one entry for the Remote peer candidate
  *        list containing the OOB data, at every command invocation the data
  *        existing in that entry are overwritten.
  * @param device_type OOB Device type:  - 0x00: The Address information are
  *        ignored.    - oob_data_len= 0x00: this triggers the automatic
  *        regeneration of OOB Authentication data (for Secure Connections only).
  *        - oob_data_len in [0..16]: the oob_data carried by the command will
  *        overwrite the current local Authentication OOB Data.  - 0x01: The
  *        Address information is used to search the entry of the Remote peer
  *        candidate list containing the OOB data for that specific remote
  *        device; if no entry exists, a new entry is used, if available (current
  *        implementation supports only 1 entry in this list).    - oob_data_len
  *        in [0..16]: the oob_data carried by the command overwrites (if
  *        present) the remote Authentication OOB Data.
  *        Values:
  *        - 0x00: Local device
  *        - 0x01: Remote device
  * @param address_type Identity address type.
  *        Values:
  *        - 0x00: Public Identity Address
  *        - 0x01: Random (static) Identity Address
  * @param address Public or Random (static) address of the peer device
  * @param oob_data_type OOB Data type. - 0x00: Legacy Privacy (LP) v.4.1 TK
  *        (Temporary Key) - 0x01: Secure Connections (SC) v.4.2 Random value r
  *        used for generation of Confirm value - 0x02: Secure Connections (SC)
  *        v.4.2 Confirm value C generated through AES-CMAC-128 based
  *        cryptographic function: C=f4(PKx, PKx, r, 0)
  *        Values:
  *        - 0x00: SM_TK
  *        - 0x01: SM_RANDOM_VALUE
  *        - 0x02: SM_CONFIRM_VALUE
  * @param oob_data_len Length of OOB Data carried by next data field
  *        Values:
  *        - 0x00 ... 0x10
  * @param oob_data OOB Data to be exported via OOB.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_oob_data(uint8_t device_type,
                                  uint8_t address_type,
                                  uint8_t address[6],
                                  uint8_t oob_data_type,
                                  uint8_t oob_data_len,
                                  uint8_t oob_data[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_oob_data_cp0 *cp0 = (aci_gap_set_oob_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->device_type = HTOB(device_type, 1);
  index_input += 1;
  cp0->address_type = HTOB(address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->address, (const void *) address, 6);
  index_input += 6;
  cp0->oob_data_type = HTOB(oob_data_type, 1);
  index_input += 1;
  cp0->oob_data_len = HTOB(oob_data_len, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->oob_data, (const void *) oob_data, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a8;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This command can be used to remove a specified device from the bonding
  *        table. ATTENTION: the device removed from the Bonding Table will
  *        preserve its connection and authentication, until explicit
  *        disconnection is requested by the user.
  * @param peer_identity_address_type Identity address type.
  *        Values:
  *        - 0x00: Public Identity Address
  *        - 0x01: Random (static) Identity Address
  * @param peer_identity_address Public or Random (static) Identity address of
  *        the peer device
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_remove_bonded_device(uint8_t peer_identity_address_type,
                                          uint8_t peer_identity_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_remove_bonded_device_cp0 *cp0 = (aci_gap_remove_bonded_device_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0aa;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This commands configures the advertising parameters for the legacy
  *        advertising or for a given extended advertising set.
  * @param advertising_handle Used to identify an advertising set. This parameter
  *        is only meaningful if Extended Advertising Feature is enabled.
  *        Values:
  *        - 0x00 ... 0xEF
  * @param discoverable_mode Specifies the discoverable mode of the device.
  *        Values:
  *        - 0: Not Discoverable
  *        - 1: Limited Discoverable
  *        - 2: General Discoverable
  *        - 3: Broadcast
  * @param advertising_event_properties The advertising_event_properties
  *        parameter describes the type of advertising event that is being
  *        configured and its basic properties according to V5.1, Vol 2, Part E,
  *        section 7.8.53.
  *        Flags:
  *        - 0x0001: Connectable
  *        - 0x0002: Scannable
  *        - 0x0004: Directed
  *        - 0x0008: High Duty Cycle Directed Connectable
  *        - 0x0010: Legacy
  *        - 0x0020: Anonymous
  *        - 0x0040: Include TX Power
  * @param primary_advertising_interval_min Minimum advertising interval for
  *        undirected and low duty cycle directed advertising. Time = N * 0.625
  *        msec.
  *        Values:
  *        - 0x00000020 (20.000 ms)  ... 0x00FFFFFF (10485759.375 ms)
  * @param primary_advertising_interval_max Maximum advertising interval for
  *        undirected and low duty cycle directed advertising. Time = N * 0.625
  *        msec.
  *        Values:
  *        - 0x00000020 (20.000 ms)  ... 0x00FFFFFF (10485759.375 ms)
  * @param primary_advertising_channel_map It is a bit field that indicates the
  *        advertising channels that shall be used when transmitting advertising
  *        packets.
  *        Flags:
  *        - 0x01: CH_37
  *        - 0x02: CH_38
  *        - 0x04: CH_39
  * @param peer_address_type The peer address type.
  *        Values:
  *        - 0x00: Public
  *        - 0x01: Random
  * @param peer_address Public Device Address, Random Device Address, Public
  *        Identity Address, or Random (static) Identity Address of the device to
  *        be connected.
  * @param advertising_filter_policy Advertising Filter Policy. If Directed
  *        advertising is selected, the peer_address_type and peer_address shall
  *        be valid and the advertising_filter_policy parameter shall be ignored.
  *        0x00 Process scan and connection requests from all devices (i.e., the
  *        White List is not in use) 0x01 Process connection requests from all
  *        devices and scan requests only from devices that are in the White List
  *        0x02 Process scan requests from all devices and connection requests
  *        only from devices that are in the White List. 0x03 Process scan and
  *        connection requests only from devices in the White List. All other
  *        values Reserved for future use
  *        Values:
  *        - 0x00: Scan and Connection requests from any
  *        - 0x01: Connection requests from any, scan requests from White List only
  *        - 0x02: Scan requests from any, connection requests from White List only
  *        - 0x03: Scan and connection requests from White
List only
  * @param advertising_tx_power The advertising_tx_power parameter indicates the
  *        maximum power level at which the advertising packets are to be
  *        transmitted on the advertising channels. The Controller shall choose a
  *        power level lower than or equal to the one specified by the Host.
  *        (Units: dBm). This parameter is ignored if extended advertising is not
  *        enabled.
  *        Values:
  *        - -127 ... 126
  *        - 127: No preference
  * @param primary_advertising_phy The primary_advertising_phy parameter
  *        indicates the PHY on which the advertising packets are transmitted on
  *        the primary advertising channel. If legacy advertising PDUs are being
  *        used, the primary_advertising_phy shall indicate the LE 1M PHY. This
  *        parameter is ignored if extended advertising is not enabled.
  *        Values:
  *        - 0x01: LE_1M_PHY
  *        - 0x03: LE_CODED_PHY
  * @param secondary_advertising_max_skip The secondary_advertising_max_skip
  *        parameter is the maximum number of advertising events that can be
  *        skipped before the AUX_ADV_IND can be sent. This parameter is ignored
  *        if extended advertising is not enabled. 0x00 AUX_ADV_IND shall be sent
  *        prior to the next advertising event 0x01-0xFF Maximum advertising
  *        events the Controller can skip before sending the AUX_ADV_IND packets
  *        on the secondary advertising channel
  * @param secondary_advertising_phy The secondary_advertising_phy parameter
  *        indicates the PHY on which the advertising packets are be transmitted
  *        on the secondary advertising channel. This parameter is ignored if
  *        extended advertising is not enabled.
  *        Values:
  *        - 0x01: LE_1M_PHY
  *        - 0x02: LE_2M_PHY
  *        - 0x03: LE_CODED_PHY
  * @param advertising_sid The advertising_sid parameter specifies the value to
  *        be transmitted in the Advertising SID subfield of the ADI field of the
  *        Extended Header of those advertising channel PDUs that have an ADI
  *        field. If the advertising set only uses PDUs that do not contain an
  *        ADI field, advertising_sid is ignored. This parameter is ignored if
  *        extended advertising is not enabled.
  *        Values:
  *        - 0x00 ... 0x0F
  * @param scan_request_notification_enable The scan_request_notification_enable
  *        parameter indicates whether the Controller shall send notifications
  *        upon the receipt of a scan request PDU that is in response to an
  *        advertisement from the specified advertising set that contains its
  *        device address and is from a scanner that is allowed by the
  *        advertising filter policy. This parameter is ignored if extended
  *        advertising is not enabled.
  *        Values:
  *        - 0x00: Scan request notifications disabled
  *        - 0x01: Scan request notifications enabled
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_advertising_configuration(uint8_t advertising_handle,
                                                   uint8_t discoverable_mode,
                                                   uint16_t advertising_event_properties,
                                                   uint32_t primary_advertising_interval_min,
                                                   uint32_t primary_advertising_interval_max,
                                                   uint8_t primary_advertising_channel_map,
                                                   uint8_t peer_address_type,
                                                   uint8_t peer_address[6],
                                                   uint8_t advertising_filter_policy,
                                                   int8_t advertising_tx_power,
                                                   uint8_t primary_advertising_phy,
                                                   uint8_t secondary_advertising_max_skip,
                                                   uint8_t secondary_advertising_phy,
                                                   uint8_t advertising_sid,
                                                   uint8_t scan_request_notification_enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_advertising_configuration_cp0 *cp0 = (aci_gap_set_advertising_configuration_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->discoverable_mode = HTOB(discoverable_mode, 1);
  index_input += 1;
  cp0->advertising_event_properties = HTOB(advertising_event_properties, 2);
  index_input += 2;
  cp0->primary_advertising_interval_min = HTOB(primary_advertising_interval_min, 4);
  index_input += 4;
  cp0->primary_advertising_interval_max = HTOB(primary_advertising_interval_max, 4);
  index_input += 4;
  cp0->primary_advertising_channel_map = HTOB(primary_advertising_channel_map, 1);
  index_input += 1;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  if (peer_address != NULL)
  {
    BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  }
  index_input += 6;
  cp0->advertising_filter_policy = HTOB(advertising_filter_policy, 1);
  index_input += 1;
  cp0->advertising_tx_power = HTOB(advertising_tx_power, 1);
  index_input += 1;
  cp0->primary_advertising_phy = HTOB(primary_advertising_phy, 1);
  index_input += 1;
  cp0->secondary_advertising_max_skip = HTOB(secondary_advertising_max_skip, 1);
  index_input += 1;
  cp0->secondary_advertising_phy = HTOB(secondary_advertising_phy, 1);
  index_input += 1;
  cp0->advertising_sid = HTOB(advertising_sid, 1);
  index_input += 1;
  cp0->scan_request_notification_enable = HTOB(scan_request_notification_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0ab;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The LE_Set_Extended_Advertising_Enable command is used to request the
  *        Controller to enable or disable one or more advertising sets using the
  *        advertising sets identified by the advertising_handle[i] parameter.
  *        The Controller manages the timing of advertisements in accordance with
  *        the advertising parameters given in the
  *        LE_Set_Extended_Advertising_Parameters command. Only Enable parameter
  *        is used if extended advertising feature is disabled through modular
  *        configuration (CONTROLLER_EXT_ADV_SCAN_ENABLED=0).
  * @param Enable It allows to enable or disable one or more advertising sets
  *        using the advertising sets identified by the advertising_handle[i]
  *        parameter.
  *        Values:
  *        - 0x00: Disable
  *        - 0x01: Enable
  * @param number_of_sets The number_of_sets parameter is the number of
  *        advertising sets contained in the parameter arrays. 0x00: Disable all
  *        advertising sets 0x01 to 0x3F: Number of advertising sets to enable or
  *        disable. Ignored if extended advertising feature is disabled through
  *        modular configuration (CONTROLLER_EXT_ADV_SCAN_ENABLED=0).
  *        Values:
  *        - 0x00: Disable all sets
  *        - 0x01 ... 0x3F
  * @param advertising_set_parameters See @ref advertising_set_parameters_t
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_advertising_enable(uint8_t enable,
                                            uint8_t number_of_sets,
                                            advertising_set_parameters_t advertising_set_parameters[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_advertising_enable_cp0 *cp0 = (aci_gap_set_advertising_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  cp0->number_of_sets = HTOB(number_of_sets, 1);
  index_input += 1;
  /* var_len_data input */
  {
    for (uint32_t index = 0; index < number_of_sets; index++)
    {
      cp0->advertising_set_parameters[index].advertising_handle = advertising_set_parameters[index].advertising_handle;
      cp0->advertising_set_parameters[index].duration = advertising_set_parameters[index].duration;
      cp0->advertising_set_parameters[index].max_extended_advertising_events =
        advertising_set_parameters[index].max_extended_advertising_events;
    }
    index_input += number_of_sets * 4;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0ac;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The ACI_GAP_SET_ADVERTISING_DATA_NWK function is used to set the data
  *        in advertising PDUs.  If the device is in Limited Discoverable Mode,
  *        Flags data type in advertising data must have the flags set as
  *        described: - The LE Limited Discoverable Mode flag set to one. - The
  *        'BR/EDR Not Supported' flag set to one. - All other flags set to zero.
  *        If the device is in General Discoverable Mode, Flags data type in
  *        advertising data must have the flags set as described: - The LE
  *        General Discoverable Mode flag set to one. - The 'BR/EDR Not
  *        Supported' flag set to one. - All other flags set to zero.  If the
  *        device is in one of the other modes, Flags data type in advertising
  *        data must have the flags set as described: - The 'BR/EDR Not
  *        Supported' flag set to one. - All other flags set to zero.  If a
  *        device is sending non connectable events, Flags data type may be
  *        omitted, otherwise it must be present.
  * @param advertising_handle Used to identify an advertising set. This parameter
  *        is only meaningful if Extended Advertising Feature is enabled.
  *        Values:
  *        - 0x00 ... 0xEF
  * @param operation The Host may set the advertising data in one or more
  *        operations using this parameter. 0x00: Intermediate fragment of
  *        fragmented extended advertising data 0x01: First fragment of
  *        fragmented extended advertising data 0x02: Last fragment of fragmented
  *        extended advertising data 0x03: Complete extended advertising data
  *        0x04: Unchanged data (just update the Advertising DID) All other
  *        values: Reserved for future use
  *        Values:
  *        - 0x00: Intermediate fragment
  *        - 0x01: First fragment
  *        - 0x02: Last fragment
  *        - 0x03: Complete data
  *        - 0x04: Unchanged data
  * @param advertising_data_length Length of advertising data. For legacy PDUs
  *        which supports advertising data maximum value is 31 octets.
  *        Values:
  *        - 0 ... 251
  * @param advertising_data Advertising data, that must be properly formatted
  *        (see Core v5.1 Vol 3, part C, chapter 11).
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_advertising_data_nwk(uint8_t advertising_handle,
                                              uint8_t operation,
                                              uint8_t advertising_data_length,
                                              uint8_t advertising_data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_advertising_data_nwk_cp0 *cp0 = (aci_gap_set_advertising_data_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->operation = HTOB(operation, 1);
  index_input += 1;
  cp0->advertising_data_length = HTOB(advertising_data_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->advertising_data,
                   (const void *) advertising_data,
                   advertising_data_length * sizeof(uint8_t));
    index_input += advertising_data_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0ad;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The ACI_GAP_SET_SCAN_RESPONSE_DATA function configures the scan
  *        response data as requested by the application.
  * @param advertising_handle Used to identify an advertising set. This parameter
  *        is only meaningful if Extended Advertising Feature is enabled.
  *        Values:
  *        - 0x00 ... 0xEF
  * @param operation The Host may set the scan response data in one or more
  *        operations using the operation parameter in the command. 0x00:
  *        Intermediate fragment of fragmented scan response data 0x01: First
  *        fragment of fragmented scan response data 0x02: Last fragment of
  *        fragmented scan response data 0x03: Complete scan response data All
  *        other values: Reserved for future use
  *        Values:
  *        - 0x00: Intermediate fragment
  *        - 0x01: First fragment
  *        - 0x02: Last fragment
  *        - 0x03: Complete data
  * @param scan_response_data_length Length of scan response data. If the
  *        advertising set uses scannable legacy advertising PDUs maximum length
  *        is 31 octets.
  *        Values:
  *        - 0 ... 251
  * @param scan_response_data Scan response data, that must be properly formatted
  *        (see Core v5.1 Vol 3, part C, chapter 11).
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_scan_response_data_nwk(uint8_t advertising_handle,
                                                uint8_t operation,
                                                uint8_t scan_response_data_length,
                                                uint8_t scan_response_data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_scan_response_data_nwk_cp0 *cp0 = (aci_gap_set_scan_response_data_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->operation = HTOB(operation, 1);
  index_input += 1;
  cp0->scan_response_data_length = HTOB(scan_response_data_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->scan_response_data,
                   (const void *) scan_response_data,
                   scan_response_data_length * sizeof(uint8_t));
    index_input += scan_response_data_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0ae;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The ACI_GAP_SET_SCAN_CONFIGURATION function configures the scan
  *        parameters for a given PHY. To configure more than one PHY, this
  *        function must be called more times.
  * @param filter_duplicates The filter_duplicates parameter controls whether the
  *        Link Layer should filter out duplicate advertising reports (filtering
  *        duplicates enabled) to the Host or if the Link Layer should generate
  *        advertising reports for each packet received (filtering duplicates
  *        disabled). See [Vol 6] Part B, Section 4.4.3.5.
  *        Values:
  *        - 0x00: Duplicate filtering disabled
  *        - 0x01: Duplicate filtering enabled
  *        - 0x02: Duplicate filtering enabled, reset for each scan period
  * @param scanning_filter_policy 0x00 Accept all advertisement packets. Directed
  *        advertising packets which are not addressed for this device shall be
  *        ignored. 0x01 Ignore advertisement packets from devices not in the
  *        White List Only. Directed advertising packets which are not addressed
  *        for this device shall be ignored 0x02 Accept all undirected
  *        advertisement packets. Directed advertisement packets where initiator
  *        address is a RPA and  Directed advertisement packets addressed to this
  *        device shall be accepted. 0x03 Accept all undirected advertisement
  *        packets from devices that are in the White List.Directed advertisement
  *        packets where initiator address is RPA and Directed advertisement
  *        packets addressed to this device shall be accepted.
  *        Values:
  *        - 0x00: Accept All
  *        - 0x01: White List Only
  *        - 0x02: Accept All (use resolving list)
  *        - 0x03: White List Only (use resolving list)
  * @param Scanning_PHY PHY that is going to be configured. Only one bit can be
  *        set.
  *        Flags:
  *        - 0x01: LE_1M_PHY_BIT
  *        - 0x04: LE_CODED_PHY_BIT
  * @param scan_type The scan_type parameter specifies the type of scan to
  *        perform. 0: Passive Scanning. No scan request PDUs shall be sent. 1:
  *        Active Scanning. Scan request PDUs may be sent.
  *        Values:
  *        - 0x00: Passive Scanning
  *        - 0x01: Active Scanning
  * @param scan_interval Time interval from when the Controller started its last
  *        scan until it begins the subsequent scan on the primary advertising
  *        physical channel.  Time = N * 0.625 ms
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms)
  * @param scan_window Time interval from when the Controller started its last
  *        scan until it begins the subsequent scan on the primary advertising
  *        physical channel. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms)
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_scan_configuration(uint8_t filter_duplicates,
                                            uint8_t scanning_filter_policy,
                                            uint8_t Scanning_PHY,
                                            uint8_t scan_type,
                                            uint16_t scan_interval,
                                            uint16_t scan_window)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_scan_configuration_cp0 *cp0 = (aci_gap_set_scan_configuration_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->filter_duplicates = HTOB(filter_duplicates, 1);
  index_input += 1;
  cp0->scanning_filter_policy = HTOB(scanning_filter_policy, 1);
  index_input += 1;
  cp0->Scanning_PHY = HTOB(Scanning_PHY, 1);
  index_input += 1;
  cp0->scan_type = HTOB(scan_type, 1);
  index_input += 1;
  cp0->scan_interval = HTOB(scan_interval, 2);
  index_input += 2;
  cp0->scan_window = HTOB(scan_window, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0af;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief This function configures the connection parameters. To configure more
  *        than one PHY, this function must be called more times.
  * @param initiating_phy PHY that is going to be configured. Only one bit can be
  *        set.
  *        Flags:
  *        - 0x01: LE_1M_PHY_BIT
  *        - 0x02: LE_2M_PHY_BIT
  *        - 0x04: LE_CODED_PHY_BIT
  * @param conn_interval_min Minimum value for the connection event interval.
  *        This shall be less than or equal to conn_interval_max. Time = N * 1.25
  *        msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_interval_max Maximum value for the connection event interval.
  *        This shall be greater than or equal to conn_interval_min. Time = N *
  *        1.25 msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param supervision_timeout Supervision timeout for the LE Link. It shall be a
  *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
  *        connInterval * 2. Time = N * 10 msec.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @param minimum_ce_length Information parameter about the minimum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @param maximum_ce_length Information parameter about the maximum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_connection_configuration(uint8_t initiating_phy,
                                                  uint16_t conn_interval_min,
                                                  uint16_t conn_interval_max,
                                                  uint16_t conn_latency,
                                                  uint16_t supervision_timeout,
                                                  uint16_t minimum_ce_length,
                                                  uint16_t maximum_ce_length)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_connection_configuration_cp0 *cp0 = (aci_gap_set_connection_configuration_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->initiating_phy = HTOB(initiating_phy, 1);
  index_input += 1;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b0;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Starts a GAP procedure according to the procedure code.
  * @param procedure_code Procedure to be started.
  *        Values:
  *        - 0x00: GAP_LIMITED_DISCOVERY_PROC
  *        - 0x01: GAP_GENERAL_DISCOVERY_PROC
  *        - 0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x05: GAP_OBSERVATION_PROC
  * @param phy_s PHYs that will be used for Scanning or Initiating .
  *        Flags:
  *        - 0x01: LE_1M_PHY_BIT
  *        - 0x04: LE_CODED_PHY_BIT
  * @param duration Ignored. Reserved for future use.
  * @param period Ignored. Reserved for future use.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_procedure(uint8_t procedure_code,
                                     uint8_t phy_s,
                                     uint16_t duration,
                                     uint16_t period)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_start_procedure_cp0 *cp0 = (aci_gap_start_procedure_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->procedure_code = HTOB(procedure_code, 1);
  index_input += 1;
  cp0->phy_s = HTOB(phy_s, 1);
  index_input += 1;
  cp0->duration = HTOB(duration, 2);
  index_input += 2;
  cp0->period = HTOB(period, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b1;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Creates a direct connection to a device and read the name
  *        characteristic.
  * @param phy_s PHYs that will be used for initiating the connection.
  *        Flags:
  *        - 0x01: LE_1M_PHY_BIT
  *        - 0x04: LE_CODED_PHY_BIT
  * @param peer_address_type The peer_address_type parameter indicates the type
  *        of address used in the connectable advertisement sent by the peer. 0:
  *        Public Device Address or Public Identity Address 1: Random Device
  *        Address or Random (static) Identity Address
  *        Values:
  *        - 0x00: Public Address
  *        - 0x01: Random Address
  * @param peer_address Public Device Address, Random Device Address, Public
  *        Identity Address, or Random (static) Identity Address of the device to
  *        be connected.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_discover_name(uint8_t phy_s,
                                   uint8_t peer_address_type,
                                   uint8_t peer_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_discover_name_cp0 *cp0 = (aci_gap_discover_name_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->phy_s = HTOB(phy_s, 1);
  index_input += 1;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b2;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Add specific device addresses to the white and/or resolving list.
  * @param lists Select in which list the device addresses will be added: white
  *        list, resolving list or both.
  *        Flags:
  *        - 0x01: White List
  *        - 0x02: Resolving List
  * @param clear_lists Clear the selected lists before adding the device
  *        addresses.
  *        Values:
  *        - 0x00: Do not clear
  *        - 0x01: Clear before adding
  * @param num_of_list_entries Number of devices that have to be added to the
  *        whitelist.
  *        Values:
  *        - 0x00 ... 0xFF
  * @param list_entry See @ref list_entry_t
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_add_devices_to_white_and_resolving_list(uint8_t lists,
                                                             uint8_t clear_lists,
                                                             uint8_t num_of_list_entries,
                                                             list_entry_t list_entry[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_add_devices_to_white_and_resolving_list_cp0 *cp0 =
    (aci_gap_add_devices_to_white_and_resolving_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->lists = HTOB(lists, 1);
  index_input += 1;
  cp0->clear_lists = HTOB(clear_lists, 1);
  index_input += 1;
  cp0->num_of_list_entries = HTOB(num_of_list_entries, 1);
  index_input += 1;
  /* var_len_data input */
  {
    for (uint32_t index = 0; index < num_of_list_entries; index++)
    {
      cp0->list_entry[index].peer_address_type = list_entry[index].peer_address_type;
      BLUENRG_MEMCPY((void *) &cp0->list_entry[index].peer_address,
                     (const void *) &list_entry[index].peer_address,
                     6);
    }
    index_input += num_of_list_entries * 7;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b3;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Clear the specified lists and add all bonded devices.
  * @param lists Select in which list the device addresses will be added: white
  *        list, resolving list or both.
  *        Flags:
  *        - 0x01: White List
  *        - 0x02: Resolving List
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_configure_white_and_resolving_list(uint8_t lists)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_configure_white_and_resolving_list_cp0 *cp0 = (aci_gap_configure_white_and_resolving_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->lists = HTOB(lists, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b4;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Set_Periodic_Advertising_Configuration command is used by the
  *        Host to set the parameters for periodic advertising. See
  *        hci_le_set_periodic_advertising_parameters().
  * @param advertising_handle It is used to identify an advertising set
  *        Values:
  *        - 0x00 ... 0xEF: Used to identify a periodic advertisement
  * @param periodic_advertising_interval_min Minimum advertising interval for
  *        periodic advertising. Time = N * 1.25 ms; Time Range: 7.5ms to
  *        81.91875 s.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) : Minimum advertising interval for periodic advertising.
  * @param periodic_advertising_interval_max Maximum advertising interval for
  *        periodic advertising. Time = N * 1.25 ms; Time Range: 7.5ms to
  *        81.91875 s.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) : Maximum advertising interval for periodic advertising.
  * @param periodic_advertising_properties The periodic_advertising_properties
  *        parameter indicates which fields should be included in the advertising
  *        packet.
  *        Flags:
  *        - 0x0040: Include TxPower in the advertising PDU
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_periodic_advertising_configuration(uint8_t advertising_handle,
                                                            uint16_t periodic_advertising_interval_min,
                                                            uint16_t periodic_advertising_interval_max,
                                                            uint16_t periodic_advertising_properties)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_periodic_advertising_configuration_cp0 *cp0 =
    (aci_gap_set_periodic_advertising_configuration_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->periodic_advertising_interval_min = HTOB(periodic_advertising_interval_min, 2);
  index_input += 2;
  cp0->periodic_advertising_interval_max = HTOB(periodic_advertising_interval_max, 2);
  index_input += 2;
  cp0->periodic_advertising_properties = HTOB(periodic_advertising_properties, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b5;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Set_Periodic_Advertising_Data command is used to set the data
  *        used in periodic advertising PDUs. See
  *        hci_le_set_periodic_advertising_data().
  * @param advertising_handle It is used to identify an advertising set
  *        Values:
  *        - 0x00 ... 0xEF: Used to identify an advertising set
  * @param operation The Host may set the periodic advertising data in one or
  *        more operations using the operation parameter in the command.
  *        Values:
  *        - 0x00: Intermediate fragment of fragmented periodic advertising data
  *        - 0x01: First fragment of fragmented periodic advertising data
  *        - 0x02: Last fragment of fragmented periodic advertising data
  *        - 0x03: Complete periodic advertising data
  * @param advertising_data_length The number of octets in the Advertising Data
  *        parameter
  *        Values:
  *        - 0 ... 252: The number of octets in the Advertising Data parameter
  * @param advertising_data Periodic advertising data formatted as defined in
  *        [Vol 3] Part C, Section 11. Note: This parameter has a variable
  *        length.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_periodic_advertising_data_nwk(uint8_t advertising_handle,
                                                       uint8_t operation,
                                                       uint8_t advertising_data_length,
                                                       uint8_t advertising_data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_periodic_advertising_data_nwk_cp0 *cp0 = (aci_gap_set_periodic_advertising_data_nwk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->operation = HTOB(operation, 1);
  index_input += 1;
  cp0->advertising_data_length = HTOB(advertising_data_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->advertising_data,
                   (const void *) advertising_data,
                   advertising_data_length * sizeof(uint8_t));
    index_input += advertising_data_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b6;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Set_Periodic_Advertising_Enable command is used to request the
  *        Controller to enable or disable the periodic advertising for the
  *        advertising set specified by the advertising_handle parameter
  *        (ordinary advertising is not affected). See
  *        hci_le_set_periodic_advertising_enable().
  * @param enable It is used to request the Controller to enable or disable the
  *        periodic advertising for the advertising set specified by the
  *        advertising_handle parameter (ordinary advertising is not affected).
  *        Values:
  *        - 0x00: Periodic advertising is disabled (default)
  *        - 0x01: Periodic advertising is enabled
  * @param advertising_handle
  *        Values:
  *        - 0x00 ... 0xEF: Used to identify an advertising set
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_periodic_advertising_enable(uint8_t enable,
                                                     uint8_t advertising_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_periodic_advertising_enable_cp0 *cp0 = (aci_gap_set_periodic_advertising_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b7;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Periodic_Advertising_Create_Sync command is used to
  *        synchronize with periodic advertising from an advertiser and begin
  *        receiving periodic advertising packets. See
  *        hci_le_periodic_advertising_create_sync().
  * @param options The options parameter is used to determine whether the
  *        Periodic Advertiser List is used and whether
  *        HCI_Periodic_Advertising_Report events for this periodic advertising
  *        train are initially enabled or disabled. If bit 0 is set, the Periodic
  *        Advertiser List is used to determine which advertiser to listen to. If
  *        the Periodic Advertiser List is not used, the advertising_sid,
  *        Advertiser address_type, and Advertiser Address parameters specify the
  *        periodic advertising device to listen to; otherwise they shall be
  *        ignored. If bit 1 is set, reporting is initially disabled, otherwise
  *        it is enabled.
  *        Flags:
  *        - 0x01: USE_PERIODIC_ADV_LIST
  *        - 0x02: DISABLE_REPORTING
  * @param advertising_sid The advertising_sid parameter, if used, specifies the
  *        value that must match the Advertising SID subfield in the ADI field of
  *        the received advertisement for it to be used to synchronize.
  *        Values:
  *        - 0x00 ... 0x0F: Advertising SID subfield in the ADI field used to identify the Periodic
  *          Advertising
  * @param advertising_address_type Advertising address type
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  * @param advertising_address Public Device Address, Random Device Address,
  *        Public Identity Address, or Random (static) Identity Address of the
  *        advertiser
  * @param skip The Skip parameter specifies the number of consecutive periodic
  *        advertising packets that the receiver may skip after successfully
  *        receiving a periodic advertising packet.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param sync_timeout The Skip parameter specifies the number of consecutive
  *        periodic advertising packets that the receiver may skip after
  *        successfully receiving a periodic advertising packet. Time = N*10 ms;
  *        Time Range: 100 ms to 163.84 s.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x4000 (163840 ms) : Synchronization timeout for the periodic advertising
  * @param sync_cte_type The sync_cte_type parameter specifies whether to only
  *        synchronize to periodic advertising with certain types of Constant
  *        Tone Extension (a value of 0 indicates that the presence or absence of
  *        a Constant Tone Extension is irrelevant). If the periodic advertising
  *        has the wrong type of Constant Tone Extension then: - If bit 0 of
  *        options is set, the Controller shall ignore this address and SID and
  *        continue to search for other periodic advertisements. - Otherwise, the
  *        Controller shall cancel the synchronization with the error code
  *        Unsupported Remote Feature/Unsupported LMP Feature (0x1A).
  *        Flags:
  *        - 0x01: Do not sync to packets with an AoA Constant Tone Extension
  *        - 0x02: Do not sync to packets with an AoD Constant Tone Extension with 1 microsecond
  *          slots
  *        - 0x04: Do not sync to packets with an AoD Constant Tone Extension with 2 microseconds
  *          slots
  *        - 0x08: Do not sync to packets with a type 3 Constant Tone Extension (currently
  *          reserved for future use)
  *        - 0x10: Do not sync to packets without a Constant Tone Extension
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_periodic_advertising_create_sync(uint8_t options,
                                                      uint8_t advertising_sid,
                                                      uint8_t advertising_address_type,
                                                      uint8_t advertising_address[6],
                                                      uint16_t skip,
                                                      uint16_t sync_timeout,
                                                      uint8_t sync_cte_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_periodic_advertising_create_sync_cp0 *cp0 = (aci_gap_periodic_advertising_create_sync_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->options = HTOB(options, 1);
  index_input += 1;
  cp0->advertising_sid = HTOB(advertising_sid, 1);
  index_input += 1;
  cp0->advertising_address_type = HTOB(advertising_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->advertising_address, (const void *) advertising_address, 6);
  index_input += 6;
  cp0->skip = HTOB(skip, 2);
  index_input += 2;
  cp0->sync_timeout = HTOB(sync_timeout, 2);
  index_input += 2;
  cp0->sync_cte_type = HTOB(sync_cte_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b8;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Periodic_Advertising_Create_Sync_Cancel command is used to
  *        cancel the GAP_Periodic_Advertising_Create_Sync command while it is
  *        pending. See hci_le_periodic_advertising_create_sync_cancel().
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_periodic_advertising_create_sync_cancel(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0b9;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Remove_Advertising_Set command is used to remove an
  *        advertising set from the Controller. If the advertising set
  *        corresponding to the advertising_handle parameter does not exist, then
  *        the Controller shall return the error code Unknown Advertising
  *        Identifier (0x42). If advertising on the advertising set is enabled,
  *        then the Controller shall return the error code Command Disallowed
  *        (0x0C).
  * @param advertising_handle It is used to identify an advertising set
  *        Values:
  *        - 0x00 ... 0xEF: Used to identify an advertising set
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_remove_advertising_set(uint8_t advertising_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_remove_advertising_set_cp0 *cp0 = (aci_gap_remove_advertising_set_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0ba;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Clear_Advertising_Sets command is used to remove all existing
  *        advertising sets from the Controller. If advertising is enabled on any
  *        advertising set, then the Controller shall return the error code
  *        Command Disallowed (0x0C). Note: All advertising sets are cleared on
  *        HCI reset.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_clear_advertising_sets(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0bb;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Periodic_Advertising_Terminate_Sync command is used to stop
  *        reception of the periodic advertising identified by the sync_handle
  *        parameter. See hci_le_periodic_advertising_terminate_sync().
  * @param sync_handle It is used to identify the periodic advertiser
  *        Values:
  *        - 0x0000 ... 0x0EFF: sync_handle to be used to identify the periodic advertiser
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_periodic_advertising_terminate_sync(uint16_t sync_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_periodic_advertising_terminate_sync_cp0 *cp0 =
    (aci_gap_periodic_advertising_terminate_sync_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->sync_handle = HTOB(sync_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c0;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief Send a slave security request to the master. This command has to be
  *        issued to notify the master of the security requirements of the slave.
  *        The master may encrypt the link, initiate the pairing procedure, or
  *        reject the request.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_add_device_to_periodic_advertiser_list(uint8_t advertiser_address_type,
                                                            uint8_t advertising_address[6],
                                                            uint8_t advertising_sid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_add_device_to_periodic_advertiser_list_cp0 *cp0 =
    (aci_gap_add_device_to_periodic_advertiser_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertiser_address_type = HTOB(advertiser_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->advertising_address, (const void *) advertising_address, 6);
  index_input += 6;
  cp0->advertising_sid = HTOB(advertising_sid, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c1;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Remove_Device_From_Periodic_Advertiser_List command is used to
  *        remove one device from the list of Periodic Advertisers stored in the
  *        Controller. See hci_le_remove_device_from_periodic_advertising_list().
  * @param advertiser_address_type Advertising Address type
  *        Values:
  *        - 0x00: Public Device Address or Public Identity Address
  *        - 0x01: Random Device Address or Random (static) Identity Address
  * @param advertising_address Public Device Address, Random Device Address,
  *        Public Identity Address, or Random (static) Identity Address of the
  *        advertiser
  * @param advertising_sid It is used to  identify the Periodic Advertising
  *        Values:
  *        - 0x00 ... 0x0F: Advertising SID subfield in the ADI field used to identify the Periodic
  *        Advertising
  *        All other values Reserved for future
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_remove_device_from_periodic_advertising_list(uint8_t advertiser_address_type,
                                                                  uint8_t advertising_address[6],
                                                                  uint8_t advertising_sid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_remove_device_from_periodic_advertising_list_cp0 *cp0 =
    (aci_gap_remove_device_from_periodic_advertising_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertiser_address_type = HTOB(advertiser_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->advertising_address, (const void *) advertising_address, 6);
  index_input += 6;
  cp0->advertising_sid = HTOB(advertising_sid, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c2;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Clear_Periodic_Advertiser_List command is used to remove all
  *        devices from the list of Periodic Advertisers in the Controller. See
  *        hci_le_clear_periodic_advertiser_list().
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_clear_periodic_advertiser_list(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c3;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The GAP_Read_Periodic_Advertiser_List_Size command is used to read the
  *        total number of Periodic Advertiser list entries that can be stored in
  *        the Controller. Note: The number of entries that can be stored is not
  *        fixed and the Controller can change it at any time (e.g., because the
  *        memory used to store the list can also be used for other purposes).
  * @param[out] periodic_advertiser_list_size Total number of Periodic Advertiser
  *             list entries that can be stored in the Controller
  *             Values:
  *             - 0x1F ... 0xFF: Total number of Periodic Advertiser list entries that can be stored in the
  *               Controller
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_read_periodic_advertiser_list_size(uint8_t *periodic_advertiser_list_size)
{
  struct hci_request rq_t;
  aci_gap_read_periodic_advertiser_list_size_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c4;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *periodic_advertiser_list_size = BTOH(resp.periodic_advertiser_list_size, 1);
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The ACI_GAP_Set_Periodic_Advertising_Receive_Enable command will
  *        enable or disable reports for the periodic advertising train
  *        identified by the sync_handle parameter. See
  *        hci_le_set_periodic_advertising_receive_enable().
  * @param sync_handle sync_handle identifying the periodic advertising train
  *        Values:
  *        - 0x0000 ... 0x0EFF: sync_handle identifying the periodic advertising train
  * @param enable It determines whether reporting is enabled or disabled
  *        Values:
  *        - 0x00: Reporting disabled
  *        - 0x01: Reporting enabled
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_periodic_advertising_receive_enable(uint16_t sync_handle,
                                                             uint8_t enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_periodic_advertising_receive_enable_cp0 *cp0 =
    (aci_gap_set_periodic_advertising_receive_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->sync_handle = HTOB(sync_handle, 2);
  index_input += 2;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c5;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The ACI_GAP_Periodic_Advertising_Sync_Transfer command is used to
  *        instruct the Controller to send synchronization information about the
  *        periodic advertising train identified by the sync_handle parameter to
  *        a connected device. See hci_le_periodic_advertising_sync_transfer().
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param service_data The service_data parameter is a value provided by the
  *        Host for use by the Host of the peer device. It is not used by the
  *        Controller.
  * @param sync_handle Sync handle that identifies the synchronization
  *        information about the periodic advertising train.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_periodic_advertising_sync_transfer(uint16_t connection_handle,
                                                        uint16_t service_data,
                                                        uint16_t sync_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_periodic_advertising_sync_transfer_cp0 *cp0 = (aci_gap_periodic_advertising_sync_transfer_cp0 *)(cmd_buffer);
  aci_gap_periodic_advertising_sync_transfer_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->service_data = HTOB(service_data, 2);
  index_input += 2;
  cp0->sync_handle = HTOB(sync_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c6;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The ACI_GAP_Periodic_Advertising_Set_Info_Transfer command is used to
  *        instruct the Controller to send synchronization information about the
  *        periodic advertising in an advertising set to a connected device. See
  *        hci_le_periodic_advertising_set_info_transfer()
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param service_data It is a value provided by the Host to identify the
  *        periodic advertising train to the peer device. It is not used by the
  *        Controller.
  * @param advertising_handle It is used to identify an advertising set
  *        Values:
  *        - 0x00 ... 0xEF
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_periodic_advertising_set_info_transfer(uint16_t connection_handle,
                                                            uint16_t service_data,
                                                            uint8_t advertising_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_periodic_advertising_set_info_transfer_cp0 *cp0 =
    (aci_gap_periodic_advertising_set_info_transfer_cp0 *)(cmd_buffer);
  aci_gap_periodic_advertising_set_info_transfer_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->service_data = HTOB(service_data, 2);
  index_input += 2;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c7;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The ACI_GAP_Set_Periodic_Advertising_Sync_Transfer_Parameters command
  *        is used to specify how the Controller will process periodic
  *        advertising synchronization information received from the device
  *        identified by the connection_handle parameter (the "transfer mode").
  *        See hci_le_set_periodic_advertising_sync_transfer_parameters().
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param mode The Mode parameter specifies the action to be taken when periodic
  *        advertising synchronization information is received. If Mode is 0x00,
  *        the Controller will ignore the information. Otherwise it will notify
  *        the Host and synchronize to the periodic advertising. Mode also
  *        specifies whether periodic advertising reports are initially enabled
  *        or disabled.
  *        Values:
  *        - 0x00: No attempt is made to synchronize to the periodic advertising and
  *                no HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
  *        - 0x01: An HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
  *                HCI_LE_Periodic_Advertising_Report events will be disabled.
  *        - 0x02: An HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
  *                HCI_LE_Periodic_Advertising_Report events will be enabled.
  * @param skip The Skip parameter specifies the number of consecutive periodic
  *        advertising packets that the receiver may skip after successfully
  *        receiving a periodic advertising packet.
  *        Values:
  *        - 0x0000 ... 0x01F3: The number of periodic advertising packets that can be skipped after
  *                             a successful receive
  * @param sync_timeout The Skip parameter specifies the number of consecutive
  *        periodic advertising packets that the receiver may skip after
  *        successfully receiving a periodic advertising packet. Time = N*10 ms;
  *        Time Range: 100 ms to 163.84 s.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x4000 (163840 ms) : Synchronization timeout for the periodic advertising
  * @param cte_type It specifies whether to only synchronize to periodic
  *        advertising with certain types of Constant Tone Extension. If the
  *        periodic advertiser changes the type of the Constant Tone Extension
  *        after the Controller has synchronized with the periodic advertising,
  *        it shall remain synchronized.
  *        Flags:
  *        - 0x01: Do not sync to packets with an AoA Constant Tone Extension
  *        - 0x02: Do not sync to packets with an AoD Constant Tone Extension with 1 microsecond slots
  *        - 0x04: Do not sync to packets with an AoD Constant Tone Extension with 2 microseconds slots
  *        - 0x10: Do not sync to packets without a Constant Tone Extension
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_periodic_advertising_sync_transfer_parameters(uint16_t connection_handle,
                                                                       uint8_t mode,
                                                                       uint16_t skip,
                                                                       uint16_t sync_timeout,
                                                                       uint8_t cte_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_periodic_advertising_sync_transfer_parameters_cp0 *cp0 =
    (aci_gap_set_periodic_advertising_sync_transfer_parameters_cp0 *)(cmd_buffer);
  aci_gap_set_periodic_advertising_sync_transfer_parameters_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->mode = HTOB(mode, 1);
  index_input += 1;
  cp0->skip = HTOB(skip, 2);
  index_input += 2;
  cp0->sync_timeout = HTOB(sync_timeout, 2);
  index_input += 2;
  cp0->cte_type = HTOB(cte_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c8;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}

/**
  * @brief The ACI_GAP_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters
  *        command is used to specify the initial value for the mode, skip,
  *        timeout, and Constant Tone Extension type to be used for all
  *        subsequent connections over the LE transport. See
  *        hci_le_set_default_periodic_advertising_sync_transfer_parameters().
  * @param mode The Mode parameter specifies the initial action to be taken. If
  *        Mode is 0x00, the Controller will ignore the information. Otherwise it
  *        will notify the Host and synchronize to the periodic advertising. Mode
  *        also specifies whether periodic advertising reports are initially
  *        enabled or disabled.
  *        Values:
  *        - 0x00: No attempt is made to synchronize to the periodic advertising and no
  *                HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
  *        - 0x01: An HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
  *                HCI_LE_Periodic_Advertising_Report events will be disabled.
  *        - 0x02: An HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is sent to the Host.
  *                HCI_LE_Periodic_Advertising_Report events will be enabled.
  * @param skip The Skip parameter specifies the number of consecutive periodic
  *        advertising packets that the receiver may skip after successfully
  *        receiving a periodic advertising packet.
  *        Values:
  *        - 0x0000 ... 0x01F3: The number of periodic advertising packets that can be skipped after
  *                     a successful receive
  * @param sync_timeout The Skip parameter specifies the number of consecutive
  *        periodic advertising packets that the receiver may skip after
  *        successfully receiving a periodic advertising packet. Time = N*10 ms;
  *        Time Range: 100 ms to 163.84 s.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x4000 (163840 ms) : Synchronization timeout for the periodic advertising
  * @param cte_type The cte_type parameter specifies whether to only synchronize
  *        to periodic advertising with certain types of Constant Tone Extension.
  *        If the periodic advertiser changes the type of the Constant Tone
  *        Extension after the Controller has synchronized with the periodic
  *        advertising, it shall remain synchronized.
  *        Flags:
  *        - 0x01: Do not sync to packets with an AoA Constant Tone Extension
  *        - 0x02: Do not sync to packets with an AoD Constant Tone Extension with 1 microsecond slots
  *        - 0x04: Do not sync to packets with an AoD Constant Tone Extension with 2 microseconds slots
  *        - 0x10: Do not sync to packets without a Constant Tone Extension
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_default_periodic_advertising_sync_transfer_parameters(uint8_t mode,
                                                                               uint16_t skip,
                                                                               uint16_t sync_timeout,
                                                                               uint8_t cte_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[532];
  aci_gap_set_default_periodic_advertising_sync_transfer_parameters_cp0 *cp0 =
    (aci_gap_set_default_periodic_advertising_sync_transfer_parameters_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->mode = HTOB(mode, 1);
  index_input += 1;
  cp0->skip = HTOB(skip, 2);
  index_input += 2;
  cp0->sync_timeout = HTOB(sync_timeout, 2);
  index_input += 2;
  cp0->cte_type = HTOB(cte_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ext_aci = TRUE;
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0c9;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
