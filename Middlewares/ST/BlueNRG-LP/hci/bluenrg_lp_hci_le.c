/**
  ******************************************************************************
  * @file    bluenrg_lp_hci_le.c
  * @author  System Research & Applications Team - Agrate/Catania Lab.
  * @version 2.0.0
  * @date    25-September-2024
  * @brief   Source file for external uC - BlueNRG-x in network coprocessor
  *          mode (hci_le). Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

#include "ble_types.h"
#include "bluenrg_lp_hci_le.h"
#include "hci_tl.h"

ble_status_t hci_disconnect(uint16_t connection_handle,
                            uint8_t reason)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_disconnect_cp0 *cp0 = (hci_disconnect_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->reason = HTOB(reason, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x01;
  rq_t.ocf = 0x006;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_remote_version_information(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_read_remote_version_information_cp0 *cp0 = (hci_read_remote_version_information_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x01;
  rq_t.ocf = 0x01d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_set_event_mask(uint8_t event_mask[8])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_set_event_mask_cp0 *cp0 = (hci_set_event_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->event_mask, (const void *) event_mask, 8);
  index_input += 8;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x03;
  rq_t.ocf = 0x001;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_reset(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x03;
  rq_t.ocf = 0x003;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_transmit_power_level(uint16_t connection_handle,
                                           uint8_t type,
                                           int8_t *transmit_power_level)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_read_transmit_power_level_cp0 *cp0 = (hci_read_transmit_power_level_cp0 *)(cmd_buffer);
  hci_read_transmit_power_level_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->type = HTOB(type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x03;
  rq_t.ocf = 0x02d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *transmit_power_level = BTOH(resp.transmit_power_level, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_set_event_mask_page_2(uint8_t event_mask_page_2[8])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_set_event_mask_page_2_cp0 *cp0 = (hci_set_event_mask_page_2_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->event_mask_page_2, (const void *) event_mask_page_2, 8);
  index_input += 8;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x03;
  rq_t.ocf = 0x063;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_authenticated_payload_timeout(uint16_t connection_handle,
                                                    uint16_t *authenticated_payload_timeout)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_read_authenticated_payload_timeout_cp0 *cp0 = (hci_read_authenticated_payload_timeout_cp0 *)(cmd_buffer);
  hci_read_authenticated_payload_timeout_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x03;
  rq_t.ocf = 0x07b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *authenticated_payload_timeout = BTOH(resp.authenticated_payload_timeout, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_write_authenticated_payload_timeout(uint16_t connection_handle,
                                                     uint16_t authenticated_payload_timeout)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_write_authenticated_payload_timeout_cp0 *cp0 = (hci_write_authenticated_payload_timeout_cp0 *)(cmd_buffer);
  hci_write_authenticated_payload_timeout_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->authenticated_payload_timeout = HTOB(authenticated_payload_timeout, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x03;
  rq_t.ocf = 0x07c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_local_version_information(uint8_t *hci_version,
                                                uint16_t *hci_revision,
                                                uint8_t *lmp_pal_version,
                                                uint16_t *manufacturer_name,
                                                uint16_t *lmp_pal_subversion)
{
  struct hci_request rq_t;
  hci_read_local_version_information_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x04;
  rq_t.ocf = 0x001;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *hci_version = BTOH(resp.hci_version, 1);
  *hci_revision = BTOH(resp.hci_revision, 2);
  *lmp_pal_version = BTOH(resp.lmp_pal_version, 1);
  *manufacturer_name = BTOH(resp.manufacturer_name, 2);
  *lmp_pal_subversion = BTOH(resp.lmp_pal_subversion, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_local_supported_commands(uint8_t supported_commands[64])
{
  struct hci_request rq_t;
  hci_read_local_supported_commands_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x04;
  rq_t.ocf = 0x002;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) supported_commands, (const void *) resp.supported_commands, 64);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_local_supported_features(uint8_t lmp_features[8])
{
  struct hci_request rq_t;
  hci_read_local_supported_features_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x04;
  rq_t.ocf = 0x003;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) lmp_features, (const void *) resp.lmp_features, 8);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_bd_addr(uint8_t bd_addr[6])
{
  struct hci_request rq_t;
  hci_read_bd_addr_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x04;
  rq_t.ocf = 0x009;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) bd_addr, (const void *) resp.bd_addr, 6);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_rssi(uint16_t connection_handle,
                           int8_t *rssi)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_read_rssi_cp0 *cp0 = (hci_read_rssi_cp0 *)(cmd_buffer);
  hci_read_rssi_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x05;
  rq_t.ocf = 0x005;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *rssi = BTOH(resp.rssi, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_event_mask(uint8_t le_event_mask[8])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_event_mask_cp0 *cp0 = (hci_le_set_event_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->le_event_mask, (const void *) le_event_mask, 8);
  index_input += 8;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x001;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_buffer_size(uint16_t *hc_le_acl_data_packet_length,
                                     uint8_t *hc_total_num_le_acl_data_lackets)
{
  struct hci_request rq_t;
  hci_le_read_buffer_size_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x002;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *hc_le_acl_data_packet_length = BTOH(resp.hc_le_acl_data_packet_length, 2);
  *hc_total_num_le_acl_data_lackets = BTOH(resp.hc_total_num_le_acl_data_lackets, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_local_supported_features(uint8_t le_features[8])
{
  struct hci_request rq_t;
  hci_le_read_local_supported_features_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x003;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) le_features, (const void *) resp.le_features, 8);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_random_address(uint8_t random_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_random_address_cp0 *cp0 = (hci_le_set_random_address_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->random_address, (const void *) random_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x005;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_advertising_parameters(uint16_t advertising_interval_min,
                                               uint16_t advertising_interval_max,
                                               uint8_t advertising_type,
                                               uint8_t own_address_type,
                                               uint8_t peer_address_type,
                                               uint8_t peer_address[6],
                                               uint8_t advertising_channel_map,
                                               uint8_t advertising_filter_policy)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_advertising_parameters_cp0 *cp0 = (hci_le_set_advertising_parameters_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_interval_min = HTOB(advertising_interval_min, 2);
  index_input += 2;
  cp0->advertising_interval_max = HTOB(advertising_interval_max, 2);
  index_input += 2;
  cp0->advertising_type = HTOB(advertising_type, 1);
  index_input += 1;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  if (peer_address)
  {
    BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  }
  index_input += 6;
  cp0->advertising_channel_map = HTOB(advertising_channel_map, 1);
  index_input += 1;
  cp0->advertising_filter_policy = HTOB(advertising_filter_policy, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x006;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_advertising_channel_tx_power(int8_t *transmit_power_level)
{
  struct hci_request rq_t;
  hci_le_read_advertising_channel_tx_power_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x007;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *transmit_power_level = BTOH(resp.transmit_power_level, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_advertising_data(uint8_t advertising_data_length,
                                         uint8_t advertising_data[31])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_advertising_data_cp0 *cp0 = (hci_le_set_advertising_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_data_length = HTOB(advertising_data_length, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->advertising_data, (const void *) advertising_data, 31);
  index_input += 31;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x008;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_scan_response_data(uint8_t scan_response_data_length,
                                           uint8_t scan_response_data[31])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_scan_response_data_cp0 *cp0 = (hci_le_set_scan_response_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->scan_response_data_length = HTOB(scan_response_data_length, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->scan_response_data, (const void *) scan_response_data, 31);
  index_input += 31;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x009;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_advertising_enable(uint8_t advertising_enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_advertising_enable_cp0 *cp0 = (hci_le_set_advertising_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_enable = HTOB(advertising_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_scan_parameters(uint8_t le_scan_type,
                                        uint16_t le_scan_interval,
                                        uint16_t le_scan_window,
                                        uint8_t own_address_type,
                                        uint8_t scanning_filter_policy)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_scan_parameters_cp0 *cp0 = (hci_le_set_scan_parameters_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_type = HTOB(le_scan_type, 1);
  index_input += 1;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->scanning_filter_policy = HTOB(scanning_filter_policy, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_scan_enable(uint8_t le_scan_enable,
                                    uint8_t filter_duplicates)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_scan_enable_cp0 *cp0 = (hci_le_set_scan_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_enable = HTOB(le_scan_enable, 1);
  index_input += 1;
  cp0->filter_duplicates = HTOB(filter_duplicates, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_create_connection(uint16_t le_scan_interval,
                                      uint16_t le_scan_window,
                                      uint8_t initiator_filter_policy,
                                      uint8_t peer_address_type,
                                      uint8_t peer_address[6],
                                      uint8_t own_address_type,
                                      uint16_t conn_interval_min,
                                      uint16_t conn_interval_max,
                                      uint16_t conn_latency,
                                      uint16_t supervision_timeout,
                                      uint16_t minimum_ce_length,
                                      uint16_t maximum_ce_length)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_create_connection_cp0 *cp0 = (hci_le_create_connection_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->initiator_filter_policy = HTOB(initiator_filter_policy, 1);
  index_input += 1;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_create_connection_cancel(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00e;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_white_list_size(uint8_t *white_list_size)
{
  struct hci_request rq_t;
  hci_le_read_white_list_size_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00f;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *white_list_size = BTOH(resp.white_list_size, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_clear_white_list(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x010;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_add_device_to_white_list(uint8_t address_type,
                                             uint8_t address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_add_device_to_white_list_cp0 *cp0 = (hci_le_add_device_to_white_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->address_type = HTOB(address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->address, (const void *) address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x011;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_remove_device_from_white_list(uint8_t address_type,
                                                  uint8_t address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_remove_device_from_white_list_cp0 *cp0 = (hci_le_remove_device_from_white_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->address_type = HTOB(address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->address, (const void *) address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x012;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_connection_update(uint16_t connection_handle,
                                      uint16_t conn_interval_min,
                                      uint16_t conn_interval_max,
                                      uint16_t conn_latency,
                                      uint16_t supervision_timeout,
                                      uint16_t minimum_ce_length,
                                      uint16_t maximum_ce_length)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_connection_update_cp0 *cp0 = (hci_le_connection_update_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x013;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_host_channel_classification(uint8_t le_channel_map[5])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_host_channel_classification_cp0 *cp0 = (hci_le_set_host_channel_classification_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->le_channel_map, (const void *) le_channel_map, 5);
  index_input += 5;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x014;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_channel_map(uint16_t connection_handle,
                                     uint8_t le_channel_map[5])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_channel_map_cp0 *cp0 = (hci_le_read_channel_map_cp0 *)(cmd_buffer);
  hci_le_read_channel_map_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x015;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) le_channel_map, (const void *) resp.le_channel_map, 5);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_remote_used_features(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_remote_used_features_cp0 *cp0 = (hci_le_read_remote_used_features_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x016;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_encrypt(uint8_t key[16],
                            uint8_t plaintext_data[16],
                            uint8_t encrypted_data[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_encrypt_cp0 *cp0 = (hci_le_encrypt_cp0 *)(cmd_buffer);
  hci_le_encrypt_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->key, (const void *) key, 16);
  index_input += 16;
  BLUENRG_MEMCPY((void *) &cp0->plaintext_data, (const void *) plaintext_data, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x017;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) encrypted_data, (const void *) resp.encrypted_data, 16);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_rand(uint8_t random_number[8])
{
  struct hci_request rq_t;
  hci_le_rand_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x018;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) random_number, (const void *) resp.random_number, 8);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_start_encryption(uint16_t connection_handle,
                                     uint8_t random_number[8],
                                     uint16_t encrypted_diversifier,
                                     uint8_t long_term_key[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_start_encryption_cp0 *cp0 = (hci_le_start_encryption_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMCPY((void *) &cp0->random_number, (const void *) random_number, 8);
  index_input += 8;
  cp0->encrypted_diversifier = HTOB(encrypted_diversifier, 2);
  index_input += 2;
  BLUENRG_MEMCPY((void *) &cp0->long_term_key, (const void *) long_term_key, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x019;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_long_term_key_request_reply(uint16_t connection_handle,
                                                uint8_t long_term_key[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_long_term_key_request_reply_cp0 *cp0 = (hci_le_long_term_key_request_reply_cp0 *)(cmd_buffer);
  hci_le_long_term_key_request_reply_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMCPY((void *) &cp0->long_term_key, (const void *) long_term_key, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_long_term_key_requested_negative_reply(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_long_term_key_requested_negative_reply_cp0 *cp0 =
    (hci_le_long_term_key_requested_negative_reply_cp0 *)(cmd_buffer);
  hci_le_long_term_key_requested_negative_reply_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_supported_states(uint8_t le_states[8])
{
  struct hci_request rq_t;
  hci_le_read_supported_states_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01c;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) le_states, (const void *) resp.le_states, 8);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_receiver_test(uint8_t rx_frequency)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_receiver_test_cp0 *cp0 = (hci_le_receiver_test_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->rx_frequency = HTOB(rx_frequency, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_transmitter_test(uint8_t tx_frequency,
                                     uint8_t length_of_test_data,
                                     uint8_t packet_payload)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_transmitter_test_cp0 *cp0 = (hci_le_transmitter_test_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->tx_frequency = HTOB(tx_frequency, 1);
  index_input += 1;
  cp0->length_of_test_data = HTOB(length_of_test_data, 1);
  index_input += 1;
  cp0->packet_payload = HTOB(packet_payload, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01e;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_test_end(uint16_t *number_of_packets)
{
  struct hci_request rq_t;
  hci_le_test_end_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01f;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *number_of_packets = BTOH(resp.number_of_packets, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_data_length(uint16_t connection_handle,
                                    uint16_t tx_octets,
                                    uint16_t tx_time)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_data_length_cp0 *cp0 = (hci_le_set_data_length_cp0 *)(cmd_buffer);
  hci_le_set_data_length_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->tx_octets = HTOB(tx_octets, 2);
  index_input += 2;
  cp0->tx_time = HTOB(tx_time, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x022;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_suggested_default_data_length(uint16_t *suggested_max_tx_octets,
                                                       uint16_t *suggested_max_tx_time)
{
  struct hci_request rq_t;
  hci_le_read_suggested_default_data_length_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x023;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *suggested_max_tx_octets = BTOH(resp.suggested_max_tx_octets, 2);
  *suggested_max_tx_time = BTOH(resp.suggested_max_tx_time, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_write_suggested_default_data_length(uint16_t suggested_max_tx_octets,
                                                        uint16_t suggested_max_tx_time)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_write_suggested_default_data_length_cp0 *cp0 = (hci_le_write_suggested_default_data_length_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->suggested_max_tx_octets = HTOB(suggested_max_tx_octets, 2);
  index_input += 2;
  cp0->suggested_max_tx_time = HTOB(suggested_max_tx_time, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x024;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_local_p256_public_key(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x025;
  rq_t.event = 0x0F;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_generate_dhkey(uint8_t remote_p256_public_key[64])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_generate_dhkey_cp0 *cp0 = (hci_le_generate_dhkey_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->remote_p256_public_key, (const void *) remote_p256_public_key, 64);
  index_input += 64;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x026;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_add_device_to_resolving_list(uint8_t peer_identity_address_type,
                                                 uint8_t peer_identity_address[6],
                                                 uint8_t peer_irk[16],
                                                 uint8_t local_irk[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_add_device_to_resolving_list_cp0 *cp0 = (hci_le_add_device_to_resolving_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMCPY((void *) &cp0->peer_irk, (const void *) peer_irk, 16);
  index_input += 16;
  BLUENRG_MEMCPY((void *) &cp0->local_irk, (const void *) local_irk, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x027;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_remove_device_from_resolving_list(uint8_t peer_identity_address_type,
                                                      uint8_t peer_identity_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_remove_device_from_resolving_list_cp0 *cp0 = (hci_le_remove_device_from_resolving_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x028;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_clear_resolving_list(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x029;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_resolving_list_size(uint8_t *resolving_list_size)
{
  struct hci_request rq_t;
  hci_le_read_resolving_list_size_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02a;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *resolving_list_size = BTOH(resp.resolving_list_size, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_peer_resolvable_address(uint8_t peer_identity_address_type,
                                                 uint8_t peer_identity_address[6],
                                                 uint8_t peer_resolvable_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_peer_resolvable_address_cp0 *cp0 = (hci_le_read_peer_resolvable_address_cp0 *)(cmd_buffer);
  hci_le_read_peer_resolvable_address_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) peer_resolvable_address, (const void *) resp.peer_resolvable_address, 6);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_local_resolvable_address(uint8_t peer_identity_address_type,
                                                  uint8_t peer_identity_address[6],
                                                  uint8_t local_resolvable_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_local_resolvable_address_cp0 *cp0 = (hci_le_read_local_resolvable_address_cp0 *)(cmd_buffer);
  hci_le_read_local_resolvable_address_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) local_resolvable_address, (const void *) resp.local_resolvable_address, 6);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_address_resolution_enable(uint8_t address_resolution_enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_address_resolution_enable_cp0 *cp0 = (hci_le_set_address_resolution_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->address_resolution_enable = HTOB(address_resolution_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_resolvable_private_address_timeout(uint16_t rpa_timeout)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_resolvable_private_address_timeout_cp0 *cp0 =
    (hci_le_set_resolvable_private_address_timeout_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->rpa_timeout = HTOB(rpa_timeout, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02e;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_maximum_data_length(uint16_t *supported_max_tx_octets,
                                             uint16_t *supported_max_tx_time,
                                             uint16_t *supported_max_rx_octets,
                                             uint16_t *supported_max_rx_time)
{
  struct hci_request rq_t;
  hci_le_read_maximum_data_length_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02f;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *supported_max_tx_octets = BTOH(resp.supported_max_tx_octets, 2);
  *supported_max_tx_time = BTOH(resp.supported_max_tx_time, 2);
  *supported_max_rx_octets = BTOH(resp.supported_max_rx_octets, 2);
  *supported_max_rx_time = BTOH(resp.supported_max_rx_time, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_phy(uint16_t connection_handle,
                             uint8_t *tx_phy,
                             uint8_t *rx_phy)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_phy_cp0 *cp0 = (hci_le_read_phy_cp0 *)(cmd_buffer);
  hci_le_read_phy_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x030;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *tx_phy = BTOH(resp.tx_phy, 1);
  *rx_phy = BTOH(resp.rx_phy, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_default_phy(uint8_t all_phys,
                                    uint8_t tx_phys,
                                    uint8_t rx_phys)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_default_phy_cp0 *cp0 = (hci_le_set_default_phy_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->all_phys = HTOB(all_phys, 1);
  index_input += 1;
  cp0->tx_phys = HTOB(tx_phys, 1);
  index_input += 1;
  cp0->rx_phys = HTOB(rx_phys, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x031;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_phy(uint16_t connection_handle,
                            uint8_t all_phys,
                            uint8_t tx_phys,
                            uint8_t rx_phys,
                            uint16_t phy_options)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_phy_cp0 *cp0 = (hci_le_set_phy_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->all_phys = HTOB(all_phys, 1);
  index_input += 1;
  cp0->tx_phys = HTOB(tx_phys, 1);
  index_input += 1;
  cp0->rx_phys = HTOB(rx_phys, 1);
  index_input += 1;
  cp0->phy_options = HTOB(phy_options, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x032;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_enhanced_receiver_test(uint8_t rx_channel,
                                           uint8_t phy,
                                           uint8_t modulation_index)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_enhanced_receiver_test_cp0 *cp0 = (hci_le_enhanced_receiver_test_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->rx_channel = HTOB(rx_channel, 1);
  index_input += 1;
  cp0->phy = HTOB(phy, 1);
  index_input += 1;
  cp0->modulation_index = HTOB(modulation_index, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x033;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_enhanced_transmitter_test(uint8_t tx_channel,
                                              uint8_t length_of_test_data,
                                              uint8_t packet_payload,
                                              uint8_t phy)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_enhanced_transmitter_test_cp0 *cp0 = (hci_le_enhanced_transmitter_test_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->tx_channel = HTOB(tx_channel, 1);
  index_input += 1;
  cp0->length_of_test_data = HTOB(length_of_test_data, 1);
  index_input += 1;
  cp0->packet_payload = HTOB(packet_payload, 1);
  index_input += 1;
  cp0->phy = HTOB(phy, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x034;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_advertising_set_random_address(uint8_t advertising_handle,
                                                       uint8_t advertising_random_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_advertising_set_random_address_cp0 *cp0 = (hci_le_set_advertising_set_random_address_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->advertising_random_address, (const void *) advertising_random_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x035;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_extended_advertising_parameters(uint8_t advertising_handle,
                                                        uint16_t advertising_event_properties,
                                                        uint8_t primary_advertising_interval_min[3],
                                                        uint8_t primary_advertising_interval_max[3],
                                                        uint8_t primary_advertising_channel_map,
                                                        uint8_t own_address_type,
                                                        uint8_t peer_address_type,
                                                        uint8_t peer_address[6],
                                                        uint8_t advertising_filter_policy,
                                                        int8_t advertising_tx_power,
                                                        uint8_t primary_advertising_phy,
                                                        uint8_t secondary_advertising_max_skip,
                                                        uint8_t secondary_advertising_phy,
                                                        uint8_t advertising_sid,
                                                        uint8_t scan_request_notification_enable,
                                                        int8_t *selected_tx_power)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_extended_advertising_parameters_cp0 *cp0 = (hci_le_set_extended_advertising_parameters_cp0 *)(cmd_buffer);
  hci_le_set_extended_advertising_parameters_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->advertising_event_properties = HTOB(advertising_event_properties, 2);
  index_input += 2;
  BLUENRG_MEMCPY((void *) &cp0->primary_advertising_interval_min, (const void *) primary_advertising_interval_min, 3);
  index_input += 3;
  BLUENRG_MEMCPY((void *) &cp0->primary_advertising_interval_max, (const void *) primary_advertising_interval_max, 3);
  index_input += 3;
  cp0->primary_advertising_channel_map = HTOB(primary_advertising_channel_map, 1);
  index_input += 1;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  if (peer_address)
  {
    BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  }
  index_input += 6;
  cp0->advertising_filter_policy = HTOB(advertising_filter_policy, 1);
  index_input += 1;
  cp0->advertising_tx_power = HTOB(advertising_tx_power, 1);
  index_input += 1;
  cp0->primary_advertising_phy = HTOB(primary_advertising_phy, 1);
  index_input += 1;
  cp0->secondary_advertising_max_skip = HTOB(secondary_advertising_max_skip, 1);
  index_input += 1;
  cp0->secondary_advertising_phy = HTOB(secondary_advertising_phy, 1);
  index_input += 1;
  cp0->advertising_sid = HTOB(advertising_sid, 1);
  index_input += 1;
  cp0->scan_request_notification_enable = HTOB(scan_request_notification_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x036;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *selected_tx_power = BTOH(resp.selected_tx_power, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_extended_advertising_data(uint8_t advertising_handle,
                                                  uint8_t operation,
                                                  uint8_t fragment_preference,
                                                  uint8_t advertising_data_length,
                                                  uint8_t advertising_data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_set_extended_advertising_data_cp0 *cp0 = (hci_le_set_extended_advertising_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->operation = HTOB(operation, 1);
  index_input += 1;
  cp0->fragment_preference = HTOB(fragment_preference, 1);
  index_input += 1;
  cp0->advertising_data_length = HTOB(advertising_data_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->advertising_data,
                   (const void *) advertising_data,
                   advertising_data_length * sizeof(uint8_t));
    index_input += advertising_data_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x037;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_extended_scan_response_data(uint8_t advertising_handle,
                                                    uint8_t operation,
                                                    uint8_t fragment_preference,
                                                    uint8_t scan_response_data_length,
                                                    uint8_t scan_response_data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_set_extended_scan_response_data_cp0 *cp0 = (hci_le_set_extended_scan_response_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->operation = HTOB(operation, 1);
  index_input += 1;
  cp0->fragment_preference = HTOB(fragment_preference, 1);
  index_input += 1;
  cp0->scan_response_data_length = HTOB(scan_response_data_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->scan_response_data,
                   (const void *) scan_response_data,
                   scan_response_data_length * sizeof(uint8_t));
    index_input += scan_response_data_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x038;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_extended_advertising_enable(uint8_t enable,
                                                    uint8_t number_of_sets,
                                                    advertising_set_parameters_t advertising_set_parameters[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_extended_advertising_enable_cp0 *cp0 = (hci_le_set_extended_advertising_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  cp0->number_of_sets = HTOB(number_of_sets, 1);
  index_input += 1;
  /* var_len_data input */
  {
    for (uint32_t i = 0; i < number_of_sets; i++)
    {
      cp0->advertising_set_parameters[i].advertising_handle = advertising_set_parameters[i].advertising_handle;
      cp0->advertising_set_parameters[i].duration = advertising_set_parameters[i].duration;
      cp0->advertising_set_parameters[i].max_extended_advertising_events =
        advertising_set_parameters[i].max_extended_advertising_events;
    }
    index_input += number_of_sets * 4;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x039;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_maximum_advertising_data_length(uint16_t *maximum_advertising_data_length)
{
  struct hci_request rq_t;
  hci_le_read_maximum_advertising_data_length_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x03a;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *maximum_advertising_data_length = BTOH(resp.maximum_advertising_data_length, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_number_of_supported_advertising_sets(uint8_t *num_supported_advertising_sets)
{
  struct hci_request rq_t;
  hci_le_read_number_of_supported_advertising_sets_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x03b;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *num_supported_advertising_sets = BTOH(resp.num_supported_advertising_sets, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_remove_advertising_set(uint8_t advertising_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_remove_advertising_set_cp0 *cp0 = (hci_le_remove_advertising_set_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x03c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_clear_advertising_sets(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x03d;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_periodic_advertising_parameters(uint8_t advertising_handle,
                                                        uint16_t periodic_advertising_interval_min,
                                                        uint16_t periodic_advertising_interval_max,
                                                        uint16_t periodic_advertising_properties)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_periodic_advertising_parameters_cp0 *cp0 = (hci_le_set_periodic_advertising_parameters_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->periodic_advertising_interval_min = HTOB(periodic_advertising_interval_min, 2);
  index_input += 2;
  cp0->periodic_advertising_interval_max = HTOB(periodic_advertising_interval_max, 2);
  index_input += 2;
  cp0->periodic_advertising_properties = HTOB(periodic_advertising_properties, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x03e;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_periodic_advertising_data(uint8_t advertising_handle,
                                                  uint8_t operation,
                                                  uint8_t advertising_data_length,
                                                  uint8_t advertising_data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_set_periodic_advertising_data_cp0 *cp0 = (hci_le_set_periodic_advertising_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->operation = HTOB(operation, 1);
  index_input += 1;
  cp0->advertising_data_length = HTOB(advertising_data_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->advertising_data,
                   (const void *) advertising_data,
                   advertising_data_length * sizeof(uint8_t));
    index_input += advertising_data_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x03f;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_periodic_advertising_enable(uint8_t enable,
                                                    uint8_t advertising_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_periodic_advertising_enable_cp0 *cp0 = (hci_le_set_periodic_advertising_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x040;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_extended_scan_parameters(uint8_t own_address_type,
                                                 uint8_t scanning_filter_policy,
                                                 uint8_t scanning_phys,
                                                 extended_scan_parameters_t extended_scan_parameters[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_extended_scan_parameters_cp0 *cp0 = (hci_le_set_extended_scan_parameters_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->scanning_filter_policy = HTOB(scanning_filter_policy, 1);
  index_input += 1;
  cp0->scanning_phys = HTOB(scanning_phys, 1);
  index_input += 1;
  uint32_t len = 0;

  for (uint32_t i = 0; i < sizeof(cp0->scanning_phys) * 8; i++)
  {
    if ((cp0->scanning_phys >> i) & 0x01)
    {
      len++;
    }
  }
  /* var_len_data input */
  {
    for (uint32_t i = 0; i < len; i++)
    {
      cp0->extended_scan_parameters[i].scan_type = extended_scan_parameters[i].scan_type;
      cp0->extended_scan_parameters[i].scan_interval = extended_scan_parameters[i].scan_interval;
      cp0->extended_scan_parameters[i].scan_window = extended_scan_parameters[i].scan_window;
    }
    index_input += len * 5;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x041;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_extended_scan_enable(uint8_t enable,
                                             uint8_t filter_duplicates,
                                             uint16_t duration,
                                             uint16_t period)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_extended_scan_enable_cp0 *cp0 = (hci_le_set_extended_scan_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  cp0->filter_duplicates = HTOB(filter_duplicates, 1);
  index_input += 1;
  cp0->duration = HTOB(duration, 2);
  index_input += 2;
  cp0->period = HTOB(period, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x042;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_extended_create_connection(uint8_t initiating_filter_policy,
                                               uint8_t own_address_type,
                                               uint8_t peer_address_type,
                                               uint8_t peer_address[6],
                                               uint8_t initiating_phys,
                                               extended_create_connection_parameters_t ext_create_conn_param[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_extended_create_connection_cp0 *cp0 = (hci_le_extended_create_connection_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->initiating_filter_policy = HTOB(initiating_filter_policy, 1);
  index_input += 1;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  cp0->initiating_phys = HTOB(initiating_phys, 1);
  index_input += 1;
  uint32_t len = 0;

  for (uint32_t i = 0; i < sizeof(cp0->initiating_phys) * 8; i++)
  {
    if ((cp0->initiating_phys >> i) & 0x01)
    {
      len++;
    }
  }
  /* var_len_data input */
  {
    for (uint32_t i = 0; i < len; i++)
    {
      cp0->ext_create_conn_param[i].scan_interval =
        ext_create_conn_param[i].scan_interval;
      cp0->ext_create_conn_param[i].scan_window =
        ext_create_conn_param[i].scan_window;
      cp0->ext_create_conn_param[i].conn_interval_min =
        ext_create_conn_param[i].conn_interval_min;
      cp0->ext_create_conn_param[i].conn_interval_max =
        ext_create_conn_param[i].conn_interval_max;
      cp0->ext_create_conn_param[i].conn_latency =
        ext_create_conn_param[i].conn_latency;
      cp0->ext_create_conn_param[i].supervision_timeout =
        ext_create_conn_param[i].supervision_timeout;
      cp0->ext_create_conn_param[i].minimum_ce_length =
        ext_create_conn_param[i].minimum_ce_length;
      cp0->ext_create_conn_param[i].maximum_ce_length =
        ext_create_conn_param[i].maximum_ce_length;
    }
    index_input += len * 16;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x043;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_periodic_advertising_create_sync(uint8_t options,
                                                     uint8_t advertising_sid,
                                                     uint8_t advertising_address_type,
                                                     uint8_t advertising_address[6],
                                                     uint16_t skip,
                                                     uint16_t sync_timeout,
                                                     uint8_t sync_cte_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_periodic_advertising_create_sync_cp0 *cp0 = (hci_le_periodic_advertising_create_sync_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->options = HTOB(options, 1);
  index_input += 1;
  cp0->advertising_sid = HTOB(advertising_sid, 1);
  index_input += 1;
  cp0->advertising_address_type = HTOB(advertising_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->advertising_address, (const void *) advertising_address, 6);
  index_input += 6;
  cp0->skip = HTOB(skip, 2);
  index_input += 2;
  cp0->sync_timeout = HTOB(sync_timeout, 2);
  index_input += 2;
  cp0->sync_cte_type = HTOB(sync_cte_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x044;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_periodic_advertising_create_sync_cancel(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x045;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_periodic_advertising_terminate_sync(uint16_t sync_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_periodic_advertising_terminate_sync_cp0 *cp0 = (hci_le_periodic_advertising_terminate_sync_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->sync_handle = HTOB(sync_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x046;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_add_device_to_periodic_advertiser_list(uint8_t advertiser_address_type,
                                                           uint8_t advertising_address[6],
                                                           uint8_t advertising_sid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_add_device_to_periodic_advertiser_list_cp0 *cp0 =
    (hci_le_add_device_to_periodic_advertiser_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertiser_address_type = HTOB(advertiser_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->advertising_address, (const void *) advertising_address, 6);
  index_input += 6;
  cp0->advertising_sid = HTOB(advertising_sid, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x047;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_remove_device_from_periodic_advertising_list(uint8_t advertiser_address_type,
                                                                 uint8_t advertising_address[6],
                                                                 uint8_t advertising_sid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_remove_device_from_periodic_advertising_list_cp0 *cp0 =
    (hci_le_remove_device_from_periodic_advertising_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertiser_address_type = HTOB(advertiser_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->advertising_address, (const void *) advertising_address, 6);
  index_input += 6;
  cp0->advertising_sid = HTOB(advertising_sid, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x048;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_clear_periodic_advertiser_list(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x049;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_periodic_advertiser_list_size(uint8_t *periodic_advertiser_list_size)
{
  struct hci_request rq_t;
  hci_le_read_periodic_advertiser_list_size_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x04a;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *periodic_advertiser_list_size = BTOH(resp.periodic_advertiser_list_size, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_transmit_power(int8_t *min_tx_power,
                                        int8_t *max_tx_power)
{
  struct hci_request rq_t;
  hci_le_read_transmit_power_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x04b;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *min_tx_power = BTOH(resp.min_tx_power, 1);
  *max_tx_power = BTOH(resp.max_tx_power, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_rf_path_compensation(int16_t *rf_tx_path_compensation_value,
                                              int16_t *rf_rx_path_compensation_value)
{
  struct hci_request rq_t;
  hci_le_read_rf_path_compensation_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x04c;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *rf_tx_path_compensation_value = BTOH(resp.rf_tx_path_compensation_value, 2);
  *rf_rx_path_compensation_value = BTOH(resp.rf_rx_path_compensation_value, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_write_rf_path_compensation(int16_t rf_tx_path_compensation_value,
                                               int16_t rf_rx_path_compensation_value)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_write_rf_path_compensation_cp0 *cp0 = (hci_le_write_rf_path_compensation_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->rf_tx_path_compensation_value = HTOB(rf_tx_path_compensation_value, 2);
  index_input += 2;
  cp0->rf_rx_path_compensation_value = HTOB(rf_rx_path_compensation_value, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x04d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_privacy_mode(uint8_t peer_identity_address_type,
                                     uint8_t peer_identity_address[6],
                                     uint8_t privacy_mode)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_privacy_mode_cp0 *cp0 = (hci_le_set_privacy_mode_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  cp0->privacy_mode = HTOB(privacy_mode, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x04e;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_receiver_test_v3(uint8_t rx_channel,
                                     uint8_t phy,
                                     uint8_t modulation_index,
                                     uint8_t expected_cte_length,
                                     uint8_t expected_cte_type,
                                     uint8_t slot_durations,
                                     uint8_t switching_pattern_length,
                                     uint8_t antenna_ids[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_receiver_test_v3_cp0 *cp0 = (hci_le_receiver_test_v3_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->rx_channel = HTOB(rx_channel, 1);
  index_input += 1;
  cp0->phy = HTOB(phy, 1);
  index_input += 1;
  cp0->modulation_index = HTOB(modulation_index, 1);
  index_input += 1;
  cp0->expected_cte_length = HTOB(expected_cte_length, 1);
  index_input += 1;
  cp0->expected_cte_type = HTOB(expected_cte_type, 1);
  index_input += 1;
  cp0->slot_durations = HTOB(slot_durations, 1);
  index_input += 1;
  cp0->switching_pattern_length = HTOB(switching_pattern_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->antenna_ids, (const void *) antenna_ids, switching_pattern_length * sizeof(uint8_t));
    index_input += switching_pattern_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x04f;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_transmitter_test_v3(uint8_t tx_channel,
                                        uint8_t test_data_length,
                                        uint8_t packet_payload,
                                        uint8_t phy,
                                        uint8_t cte_length,
                                        uint8_t cte_type,
                                        uint8_t switching_pattern_length,
                                        uint8_t antenna_ids[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_transmitter_test_v3_cp0 *cp0 = (hci_le_transmitter_test_v3_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->tx_channel = HTOB(tx_channel, 1);
  index_input += 1;
  cp0->test_data_length = HTOB(test_data_length, 1);
  index_input += 1;
  cp0->packet_payload = HTOB(packet_payload, 1);
  index_input += 1;
  cp0->phy = HTOB(phy, 1);
  index_input += 1;
  cp0->cte_length = HTOB(cte_length, 1);
  index_input += 1;
  cp0->cte_type = HTOB(cte_type, 1);
  index_input += 1;
  cp0->switching_pattern_length = HTOB(switching_pattern_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->antenna_ids, (const void *) antenna_ids, switching_pattern_length * sizeof(uint8_t));
    index_input += switching_pattern_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x050;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_connectionless_cte_transmit_parameters(uint8_t advertising_handle,
                                                               uint8_t cte_length,
                                                               uint8_t cte_type,
                                                               uint8_t cte_count,
                                                               uint8_t switching_pattern_length,
                                                               uint8_t antenna_ids[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_set_connectionless_cte_transmit_parameters_cp0 *cp0 =
    (hci_le_set_connectionless_cte_transmit_parameters_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->cte_length = HTOB(cte_length, 1);
  index_input += 1;
  cp0->cte_type = HTOB(cte_type, 1);
  index_input += 1;
  cp0->cte_count = HTOB(cte_count, 1);
  index_input += 1;
  cp0->switching_pattern_length = HTOB(switching_pattern_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->antenna_ids, (const void *) antenna_ids, switching_pattern_length * sizeof(uint8_t));
    index_input += switching_pattern_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x051;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_connectionless_cte_transmit_enable(uint8_t advertising_handle,
                                                           uint8_t cte_enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_connectionless_cte_transmit_enable_cp0 *cp0 =
    (hci_le_set_connectionless_cte_transmit_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  cp0->cte_enable = HTOB(cte_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x052;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_connectionless_iq_sampling_enable(uint16_t sync_handle,
                                                          uint8_t sampling_enable,
                                                          uint8_t slot_durations,
                                                          uint8_t max_sampled_cte_s,
                                                          uint8_t switching_pattern_length,
                                                          uint8_t antenna_ids[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_set_connectionless_iq_sampling_enable_cp0 *cp0 =
    (hci_le_set_connectionless_iq_sampling_enable_cp0 *)(cmd_buffer);
  hci_le_set_connectionless_iq_sampling_enable_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->sync_handle = HTOB(sync_handle, 2);
  index_input += 2;
  cp0->sampling_enable = HTOB(sampling_enable, 1);
  index_input += 1;
  cp0->slot_durations = HTOB(slot_durations, 1);
  index_input += 1;
  cp0->max_sampled_cte_s = HTOB(max_sampled_cte_s, 1);
  index_input += 1;
  cp0->switching_pattern_length = HTOB(switching_pattern_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->antenna_ids, (const void *) antenna_ids, switching_pattern_length * sizeof(uint8_t));
    index_input += switching_pattern_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x053;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_connection_cte_receive_parameters(uint16_t connection_handle,
                                                          uint8_t sampling_enable,
                                                          uint8_t slot_durations,
                                                          uint8_t switching_pattern_length,
                                                          uint8_t antenna_ids[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_set_connection_cte_receive_parameters_cp0 *cp0 =
    (hci_le_set_connection_cte_receive_parameters_cp0 *)(cmd_buffer);
  hci_le_set_connection_cte_receive_parameters_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->sampling_enable = HTOB(sampling_enable, 1);
  index_input += 1;
  cp0->slot_durations = HTOB(slot_durations, 1);
  index_input += 1;
  cp0->switching_pattern_length = HTOB(switching_pattern_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->antenna_ids, (const void *) antenna_ids, switching_pattern_length * sizeof(uint8_t));
    index_input += switching_pattern_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x054;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_connection_cte_transmit_parameters(uint16_t connection_handle,
                                                           uint8_t cte_type,
                                                           uint8_t switching_pattern_length,
                                                           uint8_t antenna_ids[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_set_connection_cte_transmit_parameters_cp0 *cp0 =
    (hci_le_set_connection_cte_transmit_parameters_cp0 *)(cmd_buffer);
  hci_le_set_connection_cte_transmit_parameters_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->cte_type = HTOB(cte_type, 1);
  index_input += 1;
  cp0->switching_pattern_length = HTOB(switching_pattern_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->antenna_ids, (const void *) antenna_ids, switching_pattern_length * sizeof(uint8_t));
    index_input += switching_pattern_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x055;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_connection_cte_request_enable(uint16_t connection_handle,
                                                  uint8_t enable,
                                                  uint16_t cte_request_interval,
                                                  uint8_t requested_cte_length,
                                                  uint8_t requested_cte_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_connection_cte_request_enable_cp0 *cp0 = (hci_le_connection_cte_request_enable_cp0 *)(cmd_buffer);
  hci_le_connection_cte_request_enable_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  cp0->cte_request_interval = HTOB(cte_request_interval, 2);
  index_input += 2;
  cp0->requested_cte_length = HTOB(requested_cte_length, 1);
  index_input += 1;
  cp0->requested_cte_type = HTOB(requested_cte_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x056;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_connection_cte_response_enable(uint16_t connection_handle,
                                                   uint8_t enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_connection_cte_response_enable_cp0 *cp0 = (hci_le_connection_cte_response_enable_cp0 *)(cmd_buffer);
  hci_le_connection_cte_response_enable_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x057;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_antenna_information(uint8_t *supported_switching_sampling_rates,
                                             uint8_t *num_antennae,
                                             uint8_t *max_switching_pattern_length,
                                             uint8_t *max_cte_length)
{
  struct hci_request rq_t;
  hci_le_read_antenna_information_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x058;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *supported_switching_sampling_rates = BTOH(resp.supported_switching_sampling_rates, 1);
  *num_antennae = BTOH(resp.num_antennae, 1);
  *max_switching_pattern_length = BTOH(resp.max_switching_pattern_length, 1);
  *max_cte_length = BTOH(resp.max_cte_length, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_periodic_advertising_receive_enable(uint16_t sync_handle,
                                                            uint8_t enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_periodic_advertising_receive_enable_cp0 *cp0 =
    (hci_le_set_periodic_advertising_receive_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->sync_handle = HTOB(sync_handle, 2);
  index_input += 2;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x059;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_periodic_advertising_sync_transfer(uint16_t connection_handle,
                                                       uint16_t service_data,
                                                       uint16_t sync_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_periodic_advertising_sync_transfer_cp0 *cp0 = (hci_le_periodic_advertising_sync_transfer_cp0 *)(cmd_buffer);
  hci_le_periodic_advertising_sync_transfer_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->service_data = HTOB(service_data, 2);
  index_input += 2;
  cp0->sync_handle = HTOB(sync_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x05a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_periodic_advertising_set_info_transfer(uint16_t connection_handle,
                                                           uint16_t service_data,
                                                           uint8_t advertising_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_periodic_advertising_set_info_transfer_cp0 *cp0 =
    (hci_le_periodic_advertising_set_info_transfer_cp0 *)(cmd_buffer);
  hci_le_periodic_advertising_set_info_transfer_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->service_data = HTOB(service_data, 2);
  index_input += 2;
  cp0->advertising_handle = HTOB(advertising_handle, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x05b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_periodic_advertising_sync_transfer_parameters(uint16_t connection_handle,
                                                                      uint8_t mode,
                                                                      uint16_t skip,
                                                                      uint16_t sync_timeout,
                                                                      uint8_t cte_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_periodic_advertising_sync_transfer_parameters_cp0 *cp0 =
    (hci_le_set_periodic_advertising_sync_transfer_parameters_cp0 *)(cmd_buffer);
  hci_le_set_periodic_advertising_sync_transfer_parameters_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->mode = HTOB(mode, 1);
  index_input += 1;
  cp0->skip = HTOB(skip, 2);
  index_input += 2;
  cp0->sync_timeout = HTOB(sync_timeout, 2);
  index_input += 2;
  cp0->cte_type = HTOB(cte_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x05c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_default_periodic_advertising_sync_transfer_parameters(uint8_t mode,
                                                                              uint16_t skip,
                                                                              uint16_t sync_timeout,
                                                                              uint8_t cte_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0 *cp0 =
    (hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->mode = HTOB(mode, 1);
  index_input += 1;
  cp0->skip = HTOB(skip, 2);
  index_input += 2;
  cp0->sync_timeout = HTOB(sync_timeout, 2);
  index_input += 2;
  cp0->cte_type = HTOB(cte_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x05d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_enhanced_read_transmit_power_level(uint16_t connection_handle,
                                                       uint8_t phy,
                                                       int8_t *current_transmit_power_level,
                                                       int8_t *max_transmit_power_level)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_enhanced_read_transmit_power_level_cp0 *cp0 = (hci_le_enhanced_read_transmit_power_level_cp0 *)(cmd_buffer);
  hci_le_enhanced_read_transmit_power_level_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->phy = HTOB(phy, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x076;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *current_transmit_power_level = BTOH(resp.current_transmit_power_level, 1);
  *max_transmit_power_level = BTOH(resp.max_transmit_power_level, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_remote_transmit_power_level(uint16_t connection_handle,
                                                     uint8_t phy)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_remote_transmit_power_level_cp0 *cp0 = (hci_le_read_remote_transmit_power_level_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->phy = HTOB(phy, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x077;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_path_loss_reporting_parameters(uint16_t connection_handle,
                                                       uint8_t high_threshold,
                                                       uint8_t high_hysteresis,
                                                       uint8_t low_threshold,
                                                       uint8_t low_hysteresis,
                                                       uint16_t min_time_spent)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_path_loss_reporting_parameters_cp0 *cp0 = (hci_le_set_path_loss_reporting_parameters_cp0 *)(cmd_buffer);
  hci_le_set_path_loss_reporting_parameters_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->high_threshold = HTOB(high_threshold, 1);
  index_input += 1;
  cp0->high_hysteresis = HTOB(high_hysteresis, 1);
  index_input += 1;
  cp0->low_threshold = HTOB(low_threshold, 1);
  index_input += 1;
  cp0->low_hysteresis = HTOB(low_hysteresis, 1);
  index_input += 1;
  cp0->min_time_spent = HTOB(min_time_spent, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x078;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_path_loss_reporting_enable(uint16_t connection_handle,
                                                   uint8_t enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_path_loss_reporting_enable_cp0 *cp0 = (hci_le_set_path_loss_reporting_enable_cp0 *)(cmd_buffer);
  hci_le_set_path_loss_reporting_enable_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->enable = HTOB(enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x079;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_transmit_power_reporting_enable(uint16_t connection_handle,
                                                        uint8_t local_enable,
                                                        uint8_t remote_enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_transmit_power_reporting_enable_cp0 *cp0 = (hci_le_set_transmit_power_reporting_enable_cp0 *)(cmd_buffer);
  hci_le_set_transmit_power_reporting_enable_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->local_enable = HTOB(local_enable, 1);
  index_input += 1;
  cp0->remote_enable = HTOB(remote_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x07a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_transmitter_test_v4(uint8_t tx_channel,
                                        uint8_t test_data_length,
                                        uint8_t packet_payload,
                                        uint8_t phy,
                                        uint8_t cte_length,
                                        uint8_t cte_type,
                                        uint8_t switching_pattern_length,
                                        uint8_t antenna_ids[],
                                        int8_t transmit_power_level)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  hci_le_transmitter_test_v4_cp0 *cp0 = (hci_le_transmitter_test_v4_cp0 *)(cmd_buffer);
  hci_le_transmitter_test_v4_cp1 *cp1 =
    (hci_le_transmitter_test_v4_cp1 *)(cmd_buffer +
                                       1 +
                                       1 +
                                       1 +
                                       1 +
                                       1 +
                                       1 +
                                       1 +
                                       switching_pattern_length * (sizeof(uint8_t)));
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->tx_channel = HTOB(tx_channel, 1);
  index_input += 1;
  cp0->test_data_length = HTOB(test_data_length, 1);
  index_input += 1;
  cp0->packet_payload = HTOB(packet_payload, 1);
  index_input += 1;
  cp0->phy = HTOB(phy, 1);
  index_input += 1;
  cp0->cte_length = HTOB(cte_length, 1);
  index_input += 1;
  cp0->cte_type = HTOB(cte_type, 1);
  index_input += 1;
  cp0->switching_pattern_length = HTOB(switching_pattern_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->antenna_ids, (const void *) antenna_ids, switching_pattern_length * sizeof(uint8_t));
    index_input += switching_pattern_length * sizeof(uint8_t);
    {
      cp1->transmit_power_level = HTOB(transmit_power_level, 1);
    }
    index_input += 1;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x07b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
