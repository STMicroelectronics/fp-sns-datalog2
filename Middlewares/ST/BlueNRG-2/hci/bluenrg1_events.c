/**
  ******************************************************************************
  * @file    bluenrg1_events.c
  * @author  AMG - RF Application team
  * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode
  *          (Event callbacks)
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
#include <stdint.h>
#include "bluenrg1_events.h"
ble_status_t hci_disconnection_complete_event_process(uint8_t *buffer_in);
ble_status_t hci_encryption_change_event_process(uint8_t *buffer_in);
ble_status_t hci_read_remote_version_information_complete_event_process(uint8_t *buffer_in);
ble_status_t hci_hardware_error_event_process(uint8_t *buffer_in);
ble_status_t hci_number_of_completed_packets_event_process(uint8_t *buffer_in);
ble_status_t hci_data_buffer_overflow_event_process(uint8_t *buffer_in);
ble_status_t hci_encryption_key_refresh_complete_event_process(uint8_t *buffer_in);
ble_status_t aci_blue_initialized_event_process(uint8_t *buffer_in);
ble_status_t aci_blue_events_lost_event_process(uint8_t *buffer_in);
ble_status_t aci_blue_crash_info_event_process(uint8_t *buffer_in);
ble_status_t aci_hal_end_of_radio_activity_event_process(uint8_t *buffer_in);
ble_status_t aci_hal_scan_req_report_event_process(uint8_t *buffer_in);
ble_status_t aci_hal_fw_error_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_limited_discoverable_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_pairing_complete_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_pass_key_req_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_authorization_req_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_slave_security_initiated_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_bond_lost_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_proc_complete_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_addr_not_resolved_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_numeric_comparison_value_event_process(uint8_t *buffer_in);
ble_status_t aci_gap_keypress_notification_event_process(uint8_t *buffer_in);
ble_status_t aci_l2cap_connection_update_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_l2cap_proc_timeout_event_process(uint8_t *buffer_in);
ble_status_t aci_l2cap_connection_update_req_event_process(uint8_t *buffer_in);
ble_status_t aci_l2cap_command_reject_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_attribute_modified_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_proc_timeout_event_process(uint8_t *buffer_in);
ble_status_t aci_att_exchange_mtu_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_att_find_info_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_att_find_by_type_value_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_att_read_by_type_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_att_read_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_att_read_blob_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_att_read_multiple_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_att_read_by_group_type_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_att_prepare_write_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_att_exec_write_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_indication_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_notification_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_proc_complete_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_error_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_disc_read_char_by_uuid_resp_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_write_permit_req_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_read_permit_req_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_read_multi_permit_req_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_tx_pool_available_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_server_confirmation_event_process(uint8_t *buffer_in);
ble_status_t aci_gatt_prepare_write_permit_req_event_process(uint8_t *buffer_in);
ble_status_t hci_le_connection_complete_event_process(uint8_t *buffer_in);
ble_status_t hci_le_advertising_report_event_process(uint8_t *buffer_in);
ble_status_t hci_le_connection_update_complete_event_process(uint8_t *buffer_in);
ble_status_t hci_le_read_remote_used_features_complete_event_process(uint8_t *buffer_in);
ble_status_t hci_le_long_term_key_request_event_process(uint8_t *buffer_in);
ble_status_t hci_le_data_length_change_event_process(uint8_t *buffer_in);
ble_status_t hci_le_read_local_p256_public_key_complete_event_process(uint8_t *buffer_in);
ble_status_t hci_le_generate_dhkey_complete_event_process(uint8_t *buffer_in);
ble_status_t hci_le_enhanced_connection_complete_event_process(uint8_t *buffer_in);
ble_status_t hci_le_direct_advertising_report_event_process(uint8_t *buffer_in);
const hci_events_table_type_t hci_events_table[7] =
{
  /* hci_disconnection_complete_event */
  {0x0005, hci_disconnection_complete_event_process},
  /* hci_encryption_change_event */
  {0x0008, hci_encryption_change_event_process},
  /* hci_read_remote_version_information_complete_event */
  {0x000c, hci_read_remote_version_information_complete_event_process},
  /* hci_hardware_error_event */
  {0x0010, hci_hardware_error_event_process},
  /* hci_number_of_completed_packets_event */
  {0x0013, hci_number_of_completed_packets_event_process},
  /* hci_data_buffer_overflow_event */
  {0x001a, hci_data_buffer_overflow_event_process},
  /* hci_encryption_key_refresh_complete_event */
  {0x0030, hci_encryption_key_refresh_complete_event_process}
};
const hci_le_meta_events_table_type_t hci_le_meta_events_table[10] =
{
  /* hci_le_connection_complete_event */
  {0x0001, hci_le_connection_complete_event_process},
  /* hci_le_advertising_report_event */
  {0x0002, hci_le_advertising_report_event_process},
  /* hci_le_connection_update_complete_event */
  {0x0003, hci_le_connection_update_complete_event_process},
  /* hci_le_read_remote_used_features_complete_event */
  {0x0004, hci_le_read_remote_used_features_complete_event_process},
  /* hci_le_long_term_key_request_event */
  {0x0005, hci_le_long_term_key_request_event_process},
  /* hci_le_data_length_change_event */
  {0x0007, hci_le_data_length_change_event_process},
  /* hci_le_read_local_p256_public_key_complete_event */
  {0x0008, hci_le_read_local_p256_public_key_complete_event_process},
  /* hci_le_generate_dhkey_complete_event */
  {0x0009, hci_le_generate_dhkey_complete_event_process},
  /* hci_le_enhanced_connection_complete_event */
  {0x000a, hci_le_enhanced_connection_complete_event_process},
  /* hci_le_direct_advertising_report_event */
  {0x000b, hci_le_direct_advertising_report_event_process}
};
const hci_vendor_specific_events_table_type_t hci_vendor_specific_events_table[43] =
{
  /* aci_blue_initialized_event */
  {0x0001, aci_blue_initialized_event_process},
  /* aci_blue_events_lost_event */
  {0x0002, aci_blue_events_lost_event_process},
  /* aci_blue_crash_info_event */
  {0x0003, aci_blue_crash_info_event_process},
  /* aci_hal_end_of_radio_activity_event */
  {0x0004, aci_hal_end_of_radio_activity_event_process},
  /* aci_hal_scan_req_report_event */
  {0x0005, aci_hal_scan_req_report_event_process},
  /* aci_hal_fw_error_event */
  {0x0006, aci_hal_fw_error_event_process},
  /* aci_gap_limited_discoverable_event */
  {0x0400, aci_gap_limited_discoverable_event_process},
  /* aci_gap_pairing_complete_event */
  {0x0401, aci_gap_pairing_complete_event_process},
  /* aci_gap_pass_key_req_event */
  {0x0402, aci_gap_pass_key_req_event_process},
  /* aci_gap_authorization_req_event */
  {0x0403, aci_gap_authorization_req_event_process},
  /* aci_gap_slave_security_initiated_event */
  {0x0404, aci_gap_slave_security_initiated_event_process},
  /* aci_gap_bond_lost_event */
  {0x0405, aci_gap_bond_lost_event_process},
  /* aci_gap_proc_complete_event */
  {0x0407, aci_gap_proc_complete_event_process},
  /* aci_gap_addr_not_resolved_event */
  {0x0408, aci_gap_addr_not_resolved_event_process},
  /* aci_gap_numeric_comparison_value_event */
  {0x0409, aci_gap_numeric_comparison_value_event_process},
  /* aci_gap_keypress_notification_event */
  {0x040a, aci_gap_keypress_notification_event_process},
  /* aci_l2cap_connection_update_resp_event */
  {0x0800, aci_l2cap_connection_update_resp_event_process},
  /* aci_l2cap_proc_timeout_event */
  {0x0801, aci_l2cap_proc_timeout_event_process},
  /* aci_l2cap_connection_update_req_event */
  {0x0802, aci_l2cap_connection_update_req_event_process},
  /* aci_l2cap_command_reject_event */
  {0x080a, aci_l2cap_command_reject_event_process},
  /* aci_gatt_attribute_modified_event */
  {0x0c01, aci_gatt_attribute_modified_event_process},
  /* aci_gatt_proc_timeout_event */
  {0x0c02, aci_gatt_proc_timeout_event_process},
  /* aci_att_exchange_mtu_resp_event */
  {0x0c03, aci_att_exchange_mtu_resp_event_process},
  /* aci_att_find_info_resp_event */
  {0x0c04, aci_att_find_info_resp_event_process},
  /* aci_att_find_by_type_value_resp_event */
  {0x0c05, aci_att_find_by_type_value_resp_event_process},
  /* aci_att_read_by_type_resp_event */
  {0x0c06, aci_att_read_by_type_resp_event_process},
  /* aci_att_read_resp_event */
  {0x0c07, aci_att_read_resp_event_process},
  /* aci_att_read_blob_resp_event */
  {0x0c08, aci_att_read_blob_resp_event_process},
  /* aci_att_read_multiple_resp_event */
  {0x0c09, aci_att_read_multiple_resp_event_process},
  /* aci_att_read_by_group_type_resp_event */
  {0x0c0a, aci_att_read_by_group_type_resp_event_process},
  /* aci_att_prepare_write_resp_event */
  {0x0c0c, aci_att_prepare_write_resp_event_process},
  /* aci_att_exec_write_resp_event */
  {0x0c0d, aci_att_exec_write_resp_event_process},
  /* aci_gatt_indication_event */
  {0x0c0e, aci_gatt_indication_event_process},
  /* aci_gatt_notification_event */
  {0x0c0f, aci_gatt_notification_event_process},
  /* aci_gatt_proc_complete_event */
  {0x0c10, aci_gatt_proc_complete_event_process},
  /* aci_gatt_error_resp_event */
  {0x0c11, aci_gatt_error_resp_event_process},
  /* aci_gatt_disc_read_char_by_uuid_resp_event */
  {0x0c12, aci_gatt_disc_read_char_by_uuid_resp_event_process},
  /* aci_gatt_write_permit_req_event */
  {0x0c13, aci_gatt_write_permit_req_event_process},
  /* aci_gatt_read_permit_req_event */
  {0x0c14, aci_gatt_read_permit_req_event_process},
  /* aci_gatt_read_multi_permit_req_event */
  {0x0c15, aci_gatt_read_multi_permit_req_event_process},
  /* aci_gatt_tx_pool_available_event */
  {0x0c16, aci_gatt_tx_pool_available_event_process},
  /* aci_gatt_server_confirmation_event */
  {0x0c17, aci_gatt_server_confirmation_event_process},
  /* aci_gatt_prepare_write_permit_req_event */
  {0x0c18, aci_gatt_prepare_write_permit_req_event_process}
};
/* hci_disconnection_complete_event */
/* Event len: 1 + 2 + 1 */
/**
  * @brief The Disconnection Complete event occurs when a connection is
  *        terminated. The status parameter indicates if the disconnection was
  *        successful or not. The reason parameter indicates the reason for the
  *        disconnection if the disconnection was successful. If the
  *        disconnection was not successful, the value of the reason parameter
  *        can be ignored by the Host. For example, this can be the case if the
  *        Host has issued the Disconnect command and there was a parameter
  *        error, or the command was not presently allowed, or a
  *        connection_handle that didn't correspond to a connection was given.
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param connection_handle connection_handle which was disconnected.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param reason Reason for disconnection. See Error Codes.
  * @retval None
  */

ble_status_t hci_disconnection_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_disconnection_complete_event_rp0 *rp0 = (hci_disconnection_complete_event_rp0 *)buffer_in;
  hci_disconnection_complete_event(rp0->status,
                                   rp0->connection_handle,
                                   rp0->reason);

  return status;
}
/* hci_encryption_change_event */
/* Event len: 1 + 2 + 1 */
/**
  * @brief The Encryption Change event is used to indicate that the change of the
  *        encryption mode has been completed. The connection_handle will be a
  *        connection_handle for an ACL connection. The encryption_enabled event
  *        parameter specifies the new encryption_enabled parameter for the
  *        connection_handle specified by the connection_handle event parameter.
  *        This event will occur on both devices to notify the Hosts when
  *        Encryption has changed for the specified connection_handle between two
  *        devices. Note: This event shall not be generated if encryption is
  *        paused or resumed; during a role switch, for example. The meaning of
  *        the encryption_enabled parameter depends on whether the Host has
  *        indicated support for Secure Connections in the
  *        Secure_Connections_Host_Support parameter. When
  *        Secure_Connections_Host_Support is 'disabled' or the connection_handle
  *        refers to an LE link, the Controller shall only use encryption_enabled
  *        values 0x00 (OFF) and 0x01 (ON). (See Bluetooth Specification v.4.1,
  *        Vol. 2, Part E, 7.7.8)
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param encryption_enabled Link Level Encryption.
  *        Values:
  *        - 0x00: Link Level Encryption OFF
  *        - 0x01: Link Level Encryption is ON with AES-CCM
  * @retval None
  */

ble_status_t hci_encryption_change_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_encryption_change_event_rp0 *rp0 = (hci_encryption_change_event_rp0 *)buffer_in;
  hci_encryption_change_event(rp0->status,
                              rp0->connection_handle,
                              rp0->encryption_enabled);

  return status;
}
/* hci_read_remote_version_information_complete_event */
/* Event len: 1 + 2 + 1 + 2 + 2 */
/**
  * @brief The Read Remote Version Information Complete event is used to indicate
  *        the completion of the process obtaining the version information of the
  *        remote Controller specified by the connection_handle event parameter.
  *        The connection_handle shall be for an ACL connection. The Version
  *        event parameter defines the specification version of the LE
  *        Controller. The manufacturer_name event parameter indicates the
  *        manufacturer of the remote Controller. The Subversion event parameter
  *        is controlled by the manufacturer and is implementation dependent. The
  *        Subversion event parameter defines the various revisions that each
  *        version of the Bluetooth hardware will go through as design processes
  *        change and errors are fixed. This allows the software to determine
  *        what Bluetooth hardware is being used and, if necessary, to work
  *        around various bugs in the hardware. When the connection_handle is
  *        associated with an LE-U logical link, the Version event parameter
  *        shall be Link Layer VersNr parameter, the manufacturer_name event
  *        parameter shall be the CompId parameter, and the Subversion event
  *        parameter shall be the SubVersNr parameter. (See Bluetooth
  *        Specification v.4.1, Vol. 2, Part E, 7.7.12)
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param version Version of the Current LMP in the remote Controller
  * @param manufacturer_name Manufacturer Name of the remote Controller
  * @param subversion Subversion of the LMP in the remote Controller
  * @retval None
  */

ble_status_t hci_read_remote_version_information_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_read_remote_version_information_complete_event_rp0 *rp0 =
    (hci_read_remote_version_information_complete_event_rp0 *)buffer_in;
  hci_read_remote_version_information_complete_event(rp0->status,
                                                     rp0->connection_handle,
                                                     rp0->version,
                                                     rp0->manufacturer_name,
                                                     rp0->subversion);

  return status;
}
/* hci_hardware_error_event */
/* Event len: 1 */
/**
  * @brief The Hardware Error event is used to indicate some implementation
  *        specific type of hardware failure for the controller. This event is
  *        used to notify the Host that a hardware failure has occurred in the
  *        Controller.
  * @param hardware_code Hardware Error Event code. Error code 0x01 and 0x02 are
  *        errors generally caused by hardware issue on the PCB; another possible
  *        cause is a slow crystal startup. In the latter case, the
  *        HS_STARTUP_TIME in the device configuration needs to be tuned. Error
  *        code 0x03 indicates an internal error of the protocol stack. After
  *        this event is recommended to force device reset.
  *        Values:
  *        - 0x01: Radio state error
  *        - 0x02: Timer overrun error
  *        - 0x03: Internal queue overflow error
  * @retval None
  */

ble_status_t hci_hardware_error_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_hardware_error_event_rp0 *rp0 = (hci_hardware_error_event_rp0 *)buffer_in;
  hci_hardware_error_event(rp0->hardware_code);

  return status;
}
/* hci_number_of_completed_packets_event */
/* Event len: 1 + rp0->number_of_handles * (sizeof(handle_packets_pair_entry_t)) */
/**
  * @brief 'The Number Of Completed Packets event is used by the Controller to
  *        indicate to the Host how many HCI Data Packets have been completed
  *        (transmitted or flushed) for each connection_handle since the previous
  *        Number Of Completed Packets event was sent to the Host. This means
  *        that the corresponding buffer space has been freed in the Controller.
  *        Based on this information, and the HC_Total_Num_ACL_Data_Packets and
  *        HC_Total_Num_Synchronous_- Data_Packets return parameter of the
  *        Read_Buffer_Size command, the Host can determine for which
  *        Connection_Handles the following HCI Data Packets should be sent to
  *        the Controller. The Number Of Completed Packets event must not be sent
  *        before the corresponding Connection Complete event. While the
  *        Controller has HCI data packets in its buffer, it must keep sending
  *        the Number Of Completed Packets event to the Host at least
  *        periodically, until it finally reports that all the pending ACL Data
  *        Packets have been transmitted or flushed.
  * @param number_of_handles The number of Connection_Handles and
  *        Num_HCI_Data_Packets parameters pairs contained in this event
  * @param handle_packets_pair_entry See @ref handle_packets_pair_entry_t
  * @retval None
  */

ble_status_t hci_number_of_completed_packets_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_number_of_completed_packets_event_rp0 *rp0 = (hci_number_of_completed_packets_event_rp0 *)buffer_in;
  uint8_t size = 1;
  int32_t i;
  handle_packets_pair_entry_t handle_packets_pair_entry[HCI_MAX_PAYLOAD_SIZE / sizeof(handle_packets_pair_entry_t)];
  for (i = 0; i < rp0->number_of_handles; i++)
  {
    handle_packets_pair_entry[i].connection_handle = rp0->handle_packets_pair_entry[i].connection_handle;
    size += 2;
    handle_packets_pair_entry[i].hc_num_of_completed_packets =
      rp0->handle_packets_pair_entry[i].hc_num_of_completed_packets;
    size += 2;
  }
  hci_number_of_completed_packets_event(rp0->number_of_handles,
                                        handle_packets_pair_entry);

  return status;
}
/* hci_data_buffer_overflow_event */
/* Event len: 1 */
/**
  * @brief 'This event is used to indicate that the Controller's data buffers
  *        have been overflowed. This can occur if the Host has sent more packets
  *        than allowed. The link_type parameter is used to indicate that the
  *        overflow was caused by ACL data.
  * @param link_type On which type of channel overflow has occurred.
  *        Values:
  *        - 0x01: ACL Buffer Overflow
  * @retval None
  */

ble_status_t hci_data_buffer_overflow_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_data_buffer_overflow_event_rp0 *rp0 = (hci_data_buffer_overflow_event_rp0 *)buffer_in;
  hci_data_buffer_overflow_event(rp0->link_type);

  return status;
}
/* hci_encryption_key_refresh_complete_event */
/* Event len: 1 + 2 */
/**
  * @brief 'The Encryption Key Refresh Complete event is used to indicate to the
  *        Host that the encryption key was refreshed on the given
  *        connection_handle any time encryption is paused and then resumed. If
  *        the Encryption Key Refresh Complete event was generated due to an
  *        encryption pause and resume operation embedded within a change
  *        connection link key procedure, the Encryption Key Refresh Complete
  *        event shall be sent prior to the Change Connection Link Key Complete
  *        event. If the Encryption Key Refresh Complete event was generated due
  *        to an encryption pause and resume operation embedded within a role
  *        switch procedure, the Encryption Key Refresh Complete event shall be
  *        sent prior to the Role Change event.
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @retval None
  */

ble_status_t hci_encryption_key_refresh_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_encryption_key_refresh_complete_event_rp0 *rp0 = (hci_encryption_key_refresh_complete_event_rp0 *)buffer_in;
  hci_encryption_key_refresh_complete_event(rp0->status,
                                            rp0->connection_handle);

  return status;
}
/* aci_blue_initialized_event */
/* Event len: 1 */
/**
  * @brief This event inform the application that the network coprocessor has
  *        been reset. If the reason code is a system crash, a following event
  *        @ref aci_blue_crash_info_event will provide more information regarding
  *        the system crash details.
  * @param reason_code Reason code describing why device was reset and in which
  *        mode is operating (Updater or Normal mode)
  *        Values:
  *        - 0x01: Firmware started properly
  *        - 0x02: Updater mode entered with ACI command
  *        - 0x03: Updater mode entered due to bad Blue Flag
  *        - 0x04: Updater mode entered due to IRQ pin
  *        - 0x05: System reset due to watchdog
  *        - 0x06: System reset due to lockup
  *        - 0x07: System reset due to brownout reset
  *        - 0x08: System reset due to crash
  *        - 0x09: System reset due to ECC error
  * @retval None
  */

ble_status_t aci_blue_initialized_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_blue_initialized_event_rp0 *rp0 = (aci_blue_initialized_event_rp0 *)buffer_in;
  aci_blue_initialized_event(rp0->reason_code);

  return status;
}
/* aci_blue_events_lost_event */
/* Event len: 8 */
/**
  * @brief This event is generated when an overflow occurs in the event queue
  *        read by the external microcontroller. This is normally caused when the
  *        external microcontroller does  not read pending events. The returned
  *        bitmap indicates which event has been lost. Please  note that one bit
  *        set to 1 indicates one or more occurrences of the particular events.
  *        The event ACI_BLUE_EVENTS_LOST_EVENT cannot be lost and it will
  *        inserted in the event queue as soon as a position is freed in the
  *        event queue. This event should not happen under normal operating
  *        condition where external microcontroller promptly reads events
  *        signaled by IRQ pin. It is provided to detected unexpected behavior of
  *        the external microcontroller or to allow application to recover
  *        situations where critical events are lost.
  * @param lost_events Bitmap of lost events. Each bit indicates one or more
  *        occurrences of the specific event.
  *        Flags:
  *        - 0x0000000000000001: HCI_DISCONNECTION_COMPLETE_EVENT
  *        - 0x0000000000000002: HCI_ENCRYPTION_CHANGE_EVENT
  *        - 0x0000000000000004: HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT
  *        - 0x0000000000000008: HCI_COMMAND_COMPLETE_EVENT
  *        - 0x0000000000000010: HCI_COMMAND_STATUS_EVENT
  *        - 0x0000000000000020: HCI_HARDWARE_ERROR_EVENT
  *        - 0x0000000000000040: HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT
  *        - 0x0000000000000080: HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT
  *        - 0x0000000000000100: ACI_BLUE_INITIALIZED_EVENT
  *        - 0x0000000000000200: ACI_GAP_LIMITED_DISCOVERABLE_EVENT
  *        - 0x0000000000000400: ACI_GAP_PAIRING_COMPLETE_EVENT
  *        - 0x0000000000000800: ACI_GAP_PASS_KEY_REQ_EVENT
  *        - 0x0000000000001000: ACI_GAP_AUTHORIZATION_REQ_EVENT
  *        - 0x0000000000002000: ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT
  *        - 0x0000000000004000: ACI_GAP_BOND_LOST_EVENT
  *        - 0x0000000000008000: ACI_GAP_PROC_COMPLETE_EVENT
  *        - 0x0000000000010000: ACI_GAP_ADDR_NOT_RESOLVED_EVENT
  *        - 0x0000000000020000: ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT
  *        - 0x0000000000040000: ACI_L2CAP_PROC_TIMEOUT_EVENT
  *        - 0x0000000000080000: ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT
  *        - 0x0000000000100000: ACI_GATT_ATTRIBUTE_MODIFIED_EVENT
  *        - 0x0000000000200000: ACI_GATT_PROC_TIMEOUT_EVENT
  *        - 0x0000000000400000: ACI_ATT_EXCHANGE_MTU_RESP_EVENT
  *        - 0x0000000000800000: ACI_ATT_FIND_INFO_RESP_EVENT
  *        - 0x0000000001000000: ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT
  *        - 0x0000000002000000: ACI_ATT_READ_BY_TYPE_RESP_EVENT
  *        - 0x0000000004000000: ACI_ATT_READ_RESP_EVENT
  *        - 0x0000000008000000: ACI_ATT_READ_BLOB_RESP_EVENT
  *        - 0x0000000010000000: ACI_ATT_READ_MULTIPLE_RESP_EVENT
  *        - 0x0000000020000000: ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT
  *        - 0x0000000040000000: ACI_ATT_WRITE_RESP_EVENT
  *        - 0x0000000080000000: ACI_ATT_PREPARE_WRITE_RESP_EVENT
  *        - 0x0000000100000000: ACI_ATT_EXEC_WRITE_RESP_EVENT
  *        - 0x0000000200000000: ACI_GATT_INDICATION_EVENT
  *        - 0x0000000400000000: ACI_GATT_NOTIFICATION_EVENT
  *        - 0x0000000800000000: ACI_GATT_PROC_COMPLETE_EVENT
  *        - 0x0000001000000000: ACI_GATT_ERROR_RESP_EVENT
  *        - 0x0000002000000000: ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT
  *        - 0x0000004000000000: ACI_GATT_WRITE_PERMIT_REQ_EVENT
  *        - 0x0000008000000000: ACI_GATT_READ_PERMIT_REQ_EVENT
  *        - 0x0000010000000000: ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT
  *        - 0x0000020000000000: ACI_GATT_TX_POOL_AVAILABLE_EVENT
  *        - 0x0000040000000000: ACI_GATT_SERVER_CONFIRMATION_EVENT
  *        - 0x0000080000000000: ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT
  *        - 0x0000100000000000: HCI_LE_CONNECTION_COMPLETE_EVENT
  *        - 0x0000200000000000: HCI_LE_ADVERTISING_REPORT_EVENT
  *        - 0x0000400000000000: HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT
  *        - 0x0000800000000000: HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT
  *        - 0x0001000000000000: HCI_LE_LONG_TERM_KEY_REQUEST_EVENT
  *        - 0x0002000000000000: HCI_LE_DATA_LENGTH_CHANGE_EVENT
  *        - 0x0004000000000000: HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT
  *        - 0x0008000000000000: HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT
  *        - 0x0010000000000000: HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT
  *        - 0x0020000000000000: HCI_LE_DIRECT_ADVERTISING_REPORT_EVENT
  *        - 0x0040000000000000: ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT
  *        - 0x0080000000000000: ACI_GAP_KEYPRESS_NOTIFICATION_EVENT
  * @retval None
  */

ble_status_t aci_blue_events_lost_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_blue_events_lost_event_rp0 *rp0 = (aci_blue_events_lost_event_rp0 *)buffer_in;
  aci_blue_events_lost_event(rp0->lost_events);

  return status;
}
/* aci_blue_crash_info_event */
/* Event len: 1 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + rp0->debug_data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is given to the application after the @ref
  *        aci_blue_initialized_event when a system crash is detected. This
  *        events returns system crash information for debugging purposes.
  *        Information reported are useful to understand the root cause of the
  *        crash.
  * @param crash_type Crash type
  *        Values:
  *        - 0x00: Assert failed
  *        - 0x01: NMI fault
  *        - 0x02: Hard fault
  * @param sp Stack pointer
  * @param r0 Register r0
  * @param r1 Register r1
  * @param r2 Register r2
  * @param r3 Register r3
  * @param r12 Register r12
  * @param lr Link register
  * @param pc Program counter where crash occurred
  * @param x_psr x_psr register
  * @param debug_data_length Length of debug_data field
  * @param debug_data Debug data
  * @retval None
  */

ble_status_t aci_blue_crash_info_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_blue_crash_info_event_rp0 *rp0 = (aci_blue_crash_info_event_rp0 *)buffer_in;
  aci_blue_crash_info_event(rp0->crash_type,
                            rp0->sp,
                            rp0->r0,
                            rp0->r1,
                            rp0->r2,
                            rp0->r3,
                            rp0->r12,
                            rp0->lr,
                            rp0->pc,
                            rp0->x_psr,
                            rp0->debug_data_length,
                            rp0->debug_data);

  return status;
}
/* aci_hal_end_of_radio_activity_event */
/* Event len: 1 + 1 + 4 */
/**
  * @brief This event is generated when the device completes a radio activity and
  *        provide information when a new radio activity will be performed.
  *        Information provided includes type of radio activity and absolute time
  *        in system ticks when a new radio activity is schedule, if any.
  *        Application can use this information to schedule user activities
  *        synchronous to selected radio activities. A command @ref
  *        aci_hal_set_radio_activity_mask is provided to enable radio activity
  *        events of user interests, by default no events are enabled. User
  *        should take into account that enabling radio events in application
  *        with intense radio activity could lead to a fairly high rate of events
  *        generated. Application use cases includes synchronizing notification
  *        with connection interval, switching  antenna at the end of advertising
  *        or performing flash erase operation while radio is idle.
  * @param last_state Completed radio events
  *        Values:
  *        - 0x00: Idle
  *        - 0x01: Advertising
  *        - 0x02: Connection event slave
  *        - 0x03: Scanning
  *        - 0x04: Connection request
  *        - 0x05: Connection event master
  *        - 0x06: TX test mode
  *        - 0x07: RX test mode
  * @param next_state Incoming radio events
  *        Values:
  *        - 0x00: Idle
  *        - 0x01: Advertising
  *        - 0x02: Connection event slave
  *        - 0x03: Scanning
  *        - 0x04: Connection request
  *        - 0x05: Connection event master
  *        - 0x06: TX test mode
  *        - 0x07: RX test mode
  * @param next_state_sys_time 32bit absolute current time expressed in internal
  *        time units.
  * @retval None
  */

ble_status_t aci_hal_end_of_radio_activity_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_hal_end_of_radio_activity_event_rp0 *rp0 = (aci_hal_end_of_radio_activity_event_rp0 *)buffer_in;
  aci_hal_end_of_radio_activity_event(rp0->last_state,
                                      rp0->next_state,
                                      rp0->next_state_sys_time);

  return status;
}
/* aci_hal_scan_req_report_event */
/* Event len: 1 + 1 + 6 */
/**
  * @brief This event is reported to the application after a scan request is
  *        received and a scan response is scheduled to be transmitted.
  * @param rssi N Size: 1 Octet (signed integer) Units: dBm
  *        Values:
  *        - 127: RSSI not available
  *        - -127 ... 20
  * @param peer_address_type 0x00 Public Device Address 0x01 Random Device
  *        Address 0x02 Public Identity Address (Corresponds to Resolved Private
  *        Address) 0x03 Random (Static) Identity Address (Corresponds to
  *        Resolved Private Address)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Public Identity Address
  *        - 0x03: Random (Static) Identity Address
  * @param peer_address Public Device Address or Random Device Address of the
  *        peer device
  * @retval None
  */

ble_status_t aci_hal_scan_req_report_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_hal_scan_req_report_event_rp0 *rp0 = (aci_hal_scan_req_report_event_rp0 *)buffer_in;
  aci_hal_scan_req_report_event(rp0->rssi,
                                rp0->peer_address_type,
                                rp0->peer_address);

  return status;
}
/* aci_hal_fw_error_event */
/* Event len: 1 + 1 + rp0->data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated to report firmware error information. After
  *        this event with error type equal to either 0x01, 0x02 or 0x3, it is
  *        recommended to disconnect the link (handle is reported in Data field).
  * @param fw_error_type Errore code identifying the type of error that has
  *        occurred.
  *        Values:
  *        - 0x01: HAL_FW_L2CAP_RECOMBINATION_ERROR
  *        - 0x02: HAL_FW_GATT_UNEXPECTED_RESPONSE_ERROR
  *        - 0x03: HAL_FW_GATT_SEQUENTIAL_PROTOCOL_ERROR
  * @param data_length Length of Data in octets
  * @param data If fw_error_type is 0x01, 0x02 or 0x03, this parameter contains
  *        the connection handle where the abnormal condition has occurred.
  * @retval None
  */

ble_status_t aci_hal_fw_error_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_hal_fw_error_event_rp0 *rp0 = (aci_hal_fw_error_event_rp0 *)buffer_in;
  aci_hal_fw_error_event(rp0->fw_error_type,
                         rp0->data_length,
                         rp0->data);

  return status;
}
/* aci_gap_limited_discoverable_event */
/* Event len: 0 */
/**
  * @brief This event is generated by the controller when the limited
  *        discoverable mode ends due to timeout. The timeout is 180 seconds.
  * @retval None
  */

ble_status_t aci_gap_limited_discoverable_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  aci_gap_limited_discoverable_event();

  return status;
}
/* aci_gap_pairing_complete_event */
/* Event len: 2 + 1 + 1 */
/**
  * @brief This event is generated when the pairing process has completed
  *        successfully or a pairing procedure timeout has occurred or the
  *        pairing has failed. This is to notify the application that we have
  *        paired with a remote device so that it can take further actions or to
  *        notify that a timeout has occurred so that the upper layer can decide
  *        to disconnect the link.
  * @param connection_handle Connection handle on which the pairing procedure
  *        completed
  * @param status Pairing status. If 0x02, see Reason code.
  *        Values:
  *        - 0x00: Success
  *        - 0x01: Timeout
  *        - 0x02: Pairing Failed
  *        - 0x03: Encryption failed, LTK missing on local device
  *        - 0x04: Encryption failed, LTK missing on peer device
  *        - 0x05: Encryption not supported by remote device
  * @param reason Pairing reason error code. Valid if status is 0x02.
  *        Values:
  *        - 0x00
  *        - 0x01: PASSKEY_ENTRY_FAILED
  *        - 0x02: OOB_NOT_AVAILABLE
  *        - 0x03: AUTH_REQ_CANNOT_BE_MET
  *        - 0x04: CONFIRM_VALUE_FAILED
  *        - 0x05: PAIRING_NOT_SUPPORTED
  *        - 0x06: INSUFF_ENCRYPTION_KEY_SIZE
  *        - 0x07: CMD_NOT_SUPPORTED
  *        - 0x08: UNSPECIFIED_REASON
  *        - 0x09: VERY_EARLY_NEXT_ATTEMPT
  *        - 0x0A: SM_INVALID_PARAMS
  *        - 0x0B: SMP_SC_DHKEY_CHECK_FAILED
  *        - 0x0C: SMP_SC_NUMCOMPARISON_FAILED
  * @retval None
  */

ble_status_t aci_gap_pairing_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_pairing_complete_event_rp0 *rp0 = (aci_gap_pairing_complete_event_rp0 *)buffer_in;
  aci_gap_pairing_complete_event(rp0->connection_handle,
                                 rp0->status,
                                 rp0->reason);

  return status;
}
/* aci_gap_pass_key_req_event */
/* Event len: 2 */
/**
  * @brief This event is generated by the Security manager to the application
  *        when a passkey is required for pairing. When this event is received,
  *        the application has to respond with the @ref aci_gap_pass_key_resp
  *        command.
  * @param connection_handle Connection handle for which the passkey has been
  *        requested.
  * @retval None
  */

ble_status_t aci_gap_pass_key_req_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_pass_key_req_event_rp0 *rp0 = (aci_gap_pass_key_req_event_rp0 *)buffer_in;
  aci_gap_pass_key_req_event(rp0->connection_handle);

  return status;
}
/* aci_gap_authorization_req_event */
/* Event len: 2 */
/**
  * @brief This event is generated by the Security manager to the application
  *        when the application has set that authorization is required for
  *        reading/writing of attributes. This event will be generated as soon as
  *        the pairing is complete. When this event is received, @ref
  *        aci_gap_authorization_resp command should be used to respond by the
  *        application.
  * @param connection_handle Connection handle for which authorization has been
  *        requested.
  * @retval None
  */

ble_status_t aci_gap_authorization_req_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_authorization_req_event_rp0 *rp0 = (aci_gap_authorization_req_event_rp0 *)buffer_in;
  aci_gap_authorization_req_event(rp0->connection_handle);

  return status;
}
/* aci_gap_slave_security_initiated_event */
/* Event len: 0 */
/**
  * @brief This event is generated when the slave security request is
  *        successfully sent to the master.
  * @retval None
  */

ble_status_t aci_gap_slave_security_initiated_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  aci_gap_slave_security_initiated_event();

  return status;
}
/* aci_gap_bond_lost_event */
/* Event len: 0 */
/**
  * @brief This event is generated on the slave when a
  *        ACI_GAP_SLAVE_SECURITY_REQUEST is called to reestablish the bond with
  *        a master but the master has lost the bond. When this event is
  *        received, the upper layer has to issue the ACI_GAP_ALLOW_REBOND
  *        command in order to allow the slave to continue the pairing process
  *        with the master. On the master this event is raised when
  *        ACI_GAP_SEND_PAIRING_REQUEST is called to reestablish a bond with a
  *        slave but the slave has lost the bond. In order to create a new bond
  *        the master has to launch ACI_GAP_SEND_PAIRING_REQUEST with
  *        force_rebond set to 1.
  * @retval None
  */

ble_status_t aci_gap_bond_lost_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  aci_gap_bond_lost_event();

  return status;
}
/* aci_gap_proc_complete_event */
/* Event len: 1 + 1 + 1 + rp0->data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is sent by the GAP to the upper layers when a procedure
  *        previously started has been terminated by the upper layer or has
  *        completed for any other reason
  * @param procedure_code Terminated procedure.
  *        Values:
  *        - 0x01: GAP_LIMITED_DISCOVERY_PROC_BIT
  *        - 0x02: GAP_GENERAL_DISCOVERY_PROC_BIT
  *        - 0x04: GAP_NAME_DISCOVERY_PROC_BIT
  *        - 0x08: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC_BIT
  *        - 0x10: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC_BIT
  *        - 0x20: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC_BIT
  *        - 0x40: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC_BIT
  *        - 0x80: GAP_OBSERVATION_PROC_BIT
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param data_length Length of Data in octets
  * @param data Procedure Specific Data: - For Name Discovery Procedure: the name
  *        of the peer device if the procedure completed successfully.
  * @retval None
  */

ble_status_t aci_gap_proc_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_proc_complete_event_rp0 *rp0 = (aci_gap_proc_complete_event_rp0 *)buffer_in;
  aci_gap_proc_complete_event(rp0->procedure_code,
                              rp0->status,
                              rp0->data_length,
                              rp0->data);

  return status;
}
/* aci_gap_addr_not_resolved_event */
/* Event len: 2 */
/**
  * @brief This event is sent only by a privacy enabled Peripheral. The event is
  *        sent to the upper layers when the peripheral is unsuccessful in
  *        resolving the resolvable address of the peer device after connecting
  *        to it.
  * @param connection_handle Connection handle for which the private address
  *        could not be resolved with any of the stored IRK's.
  * @retval None
  */

ble_status_t aci_gap_addr_not_resolved_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_addr_not_resolved_event_rp0 *rp0 = (aci_gap_addr_not_resolved_event_rp0 *)buffer_in;
  aci_gap_addr_not_resolved_event(rp0->connection_handle);

  return status;
}
/* aci_gap_numeric_comparison_value_event */
/* Event len: 2 + 4 */
/**
  * @brief This event is sent only during SC v.4.2 Pairing, when Numeric
  *        Comparison Association model is selected, in order to show the Numeric
  *        Value generated, and to ask for Confirmation to the User. When this
  *        event is received, the application has to respond with the  @ref
  *        aci_gap_numeric_comparison_value_confirm_yesno command
  * @param connection_handle Connection handle related to the underlying Pairing
  * @param numeric_value
  * @retval None
  */

ble_status_t aci_gap_numeric_comparison_value_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_numeric_comparison_value_event_rp0 *rp0 = (aci_gap_numeric_comparison_value_event_rp0 *)buffer_in;
  aci_gap_numeric_comparison_value_event(rp0->connection_handle,
                                         rp0->numeric_value);

  return status;
}
/* aci_gap_keypress_notification_event */
/* Event len: 2 + 1 */
/**
  * @brief This event is sent only during SC v.4.2 Pairing, when Keypress
  *        Notifications are supported, in order to show the input type signalled
  *        by the peer device, having Keyboard only I/O capabilities. When this
  *        event is received, no action is required to the User.
  * @param connection_handle Connection handle related to the underlying Pairing
  * @param notification_type Type of Keypress input notified/signaled by peer
  *        device
  *        Values:
  *        - 0x00: PASSKEY_ENTRY_STARTED
  *        - 0x01: PASSKEY_DIGIT_ENTERED
  *        - 0x02: PASSKEY_DIGIT_ERASED
  *        - 0x03: PASSKEY_CLEARED
  *        - 0x04: PASSKEY_ENTRY_COMPLETED
  * @retval None
  */

ble_status_t aci_gap_keypress_notification_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_keypress_notification_event_rp0 *rp0 = (aci_gap_keypress_notification_event_rp0 *)buffer_in;
  aci_gap_keypress_notification_event(rp0->connection_handle,
                                      rp0->notification_type);

  return status;
}
/* aci_l2cap_connection_update_resp_event */
/* Event len: 2 + 2 */
/**
  * @brief This event is generated when the master responds to the connection
  *        update request packet with a connection update response packet.
  * @param connection_handle Connection handle referring to the COS Channel where
  *        the Disconnection has been received.
  * @param result
  * @retval None
  */

ble_status_t aci_l2cap_connection_update_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_l2cap_connection_update_resp_event_rp0 *rp0 = (aci_l2cap_connection_update_resp_event_rp0 *)buffer_in;
  aci_l2cap_connection_update_resp_event(rp0->connection_handle,
                                         rp0->result);

  return status;
}
/* aci_l2cap_proc_timeout_event */
/* Event len: 2 + 1 + rp0->data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated when the master does not respond to the
  *        connection update request packet with a connection update response
  *        packet or a command reject packet within 30 seconds.
  * @param connection_handle Handle of the connection related to this L2CAP
  *        procedure.
  * @param data_length Length of following data
  * @param data
  * @retval None
  */

ble_status_t aci_l2cap_proc_timeout_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_l2cap_proc_timeout_event_rp0 *rp0 = (aci_l2cap_proc_timeout_event_rp0 *)buffer_in;
  aci_l2cap_proc_timeout_event(rp0->connection_handle,
                               rp0->data_length,
                               rp0->data);

  return status;
}
/* aci_l2cap_connection_update_req_event */
/* Event len: 2 + 1 + 2 + 2 + 2 + 2 + 2 */
/**
  * @brief The event is given by the L2CAP layer when a connection update request
  *        is received from the slave. The upper layer which receives this event
  *        has to respond by sending a @ref
  *        aci_l2cap_connection_parameter_update_resp command.
  * @param connection_handle Handle of the connection related to this L2CAP
  *        procedure.
  * @param identifier This is the identifier which associate the request to the
  *        response.
  * @param l2_cap_length Length of the L2CAP connection update request.
  * @param interval_min Minimum value for the connection event interval. This
  *        shall be less than or equal to conn_interval_max. Time = N * 1.25
  *        msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param interval_max Maximum value for the connection event interval. This
  *        shall be greater than or equal to conn_interval_min. Time = N * 1.25
  *        msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param slave_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param timeout_multiplier Defines connection timeout parameter in the
  *        following manner: Timeout Multiplier * 10ms.
  *        Values:
  *        - 10 (100 ms)  ... 3200 (32000 ms)
  * @retval None
  */

ble_status_t aci_l2cap_connection_update_req_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_l2cap_connection_update_req_event_rp0 *rp0 = (aci_l2cap_connection_update_req_event_rp0 *)buffer_in;
  aci_l2cap_connection_update_req_event(rp0->connection_handle,
                                        rp0->identifier,
                                        rp0->l2_cap_length,
                                        rp0->interval_min,
                                        rp0->interval_max,
                                        rp0->slave_latency,
                                        rp0->timeout_multiplier);

  return status;
}
/* aci_l2cap_command_reject_event */
/* Event len: 2 + 1 + 2 + 1 + rp0->data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated when the master responds to the connection
  *        update request packet with a command reject packet.
  * @param connection_handle Connection handle referring to the COS Channel where
  *        the Disconnection has been received.
  * @param identifier This is the identifier which associate the request to the
  *        response.
  * @param reason Reason
  * @param data_length Length of following data
  * @param data Data field associated with Reason
  * @retval None
  */

ble_status_t aci_l2cap_command_reject_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_l2cap_command_reject_event_rp0 *rp0 = (aci_l2cap_command_reject_event_rp0 *)buffer_in;
  aci_l2cap_command_reject_event(rp0->connection_handle,
                                 rp0->identifier,
                                 rp0->reason,
                                 rp0->data_length,
                                 rp0->data);

  return status;
}
/* aci_gatt_attribute_modified_event */
/* Event len: 2 + 2 + 2 + 2 + rp0->attr_data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated to the application by the GATT server when a
  *        client modifies any attribute on the server, as consequence of one of
  *        the following GATT procedures: - write without response - signed write
  *        without response - write characteristic value - write long
  *        characteristic value - reliable write.
  * @param connection_handle The connection handle which modified the attribute.
  * @param attr_handle Handle of the attribute that was modified.
  * @param offset SoC mode: the offset is never used and it is always 0. Network
  *        coprocessor mode:     - Bits 0-14: offset of the reported value inside
  *        the attribute.     - Bit 15: if the entire value of the attribute does
  *        not fit inside a single ACI_GATT_ATTRIBUTE_MODIFIED_EVENT event, this
  *        bit is set to 1 to notify that other ACI_GATT_ATTRIBUTE_MODIFIED_EVENT
  *        events will follow to report the remaining value.
  * @param attr_data_length Length of attr_data in octets
  * @param attr_data The modified value
  * @retval None
  */

ble_status_t aci_gatt_attribute_modified_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_attribute_modified_event_rp0 *rp0 = (aci_gatt_attribute_modified_event_rp0 *)buffer_in;
  aci_gatt_attribute_modified_event(rp0->connection_handle,
                                    rp0->attr_handle,
                                    rp0->offset,
                                    rp0->attr_data_length,
                                    rp0->attr_data);

  return status;
}
/* aci_gatt_proc_timeout_event */
/* Event len: 2 */
/**
  * @brief This event is generated by the client/server to the application on a
  *        GATT timeout (30 seconds). This is a critical event that should not
  *        happen during normal operating conditions. It is an indication of
  *        either a major disruption in the communication link or a mistake in
  *        the application which does not provide a reply to GATT procedures.
  *        After this event, the GATT channel is closed and no more GATT
  *        communication can be performed. The applications is expected to issue
  *        an @ref aci_gap_terminate to disconnect from the peer device. It is
  *        important to leave an 100 ms blank window before sending the @ref
  *        aci_gap_terminate, since immediately after this event, system could
  *        save important information in non volatile memory.
  * @param connection_handle Connection handle on which the GATT procedure has
  *        timed out
  * @retval None
  */

ble_status_t aci_gatt_proc_timeout_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_proc_timeout_event_rp0 *rp0 = (aci_gatt_proc_timeout_event_rp0 *)buffer_in;
  aci_gatt_proc_timeout_event(rp0->connection_handle);

  return status;
}
/* aci_att_exchange_mtu_resp_event */
/* Event len: 2 + 2 */
/**
  * @brief This event is generated in response to an Exchange MTU request (local
  *        or from the peer). See @ref aci_gatt_exchange_config.
  * @param connection_handle Connection handle related to the response
  * @param server_rx_mtu ATT_MTU value agreed between server and client
  * @retval None
  */

ble_status_t aci_att_exchange_mtu_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_exchange_mtu_resp_event_rp0 *rp0 = (aci_att_exchange_mtu_resp_event_rp0 *)buffer_in;
  aci_att_exchange_mtu_resp_event(rp0->connection_handle,
                                  rp0->server_rx_mtu);

  return status;
}
/* aci_att_find_info_resp_event */
/* Event len: 2 + 1 + 1 + rp0->event_data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a Find Information Request. See
  *        @ref aci_att_find_info_req and Find Information Response in Bluetooth
  *        Core v4.1 spec.
  * @param connection_handle Connection handle related to the response
  * @param format Format of the hanndle-uuid pairs
  * @param event_data_length Length of handle_uuid_pair in octets
  * @param handle_uuid_pair A sequence of handle-uuid pairs. if format=1, each
  *        pair is:[2 octets for handle, 2 octets for UUIDs], if format=2, each
  *        pair is:[2 octets for handle, 16 octets for UUIDs]
  * @retval None
  */

ble_status_t aci_att_find_info_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_find_info_resp_event_rp0 *rp0 = (aci_att_find_info_resp_event_rp0 *)buffer_in;
  aci_att_find_info_resp_event(rp0->connection_handle,
                               rp0->format,
                               rp0->event_data_length,
                               rp0->handle_uuid_pair);

  return status;
}
/* aci_att_find_by_type_value_resp_event */
/* Event len: 2 + 1 + rp0->num_of_handle_pair * (sizeof(attribute_group_handle_pair_t)) */
/**
  * @brief This event is generated in response to a @ref
  *        aci_att_find_by_type_value_req
  * @param connection_handle Connection handle related to the response
  * @param num_of_handle_pair Number of attribute, group handle pairs
  * @param attribute_group_handle_pair See @ref attribute_group_handle_pair_t
  * @retval None
  */

ble_status_t aci_att_find_by_type_value_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_find_by_type_value_resp_event_rp0 *rp0 = (aci_att_find_by_type_value_resp_event_rp0 *)buffer_in;
  uint8_t size = 3;
  int32_t i;
  attribute_group_handle_pair_t attribute_group_handle_pair[HCI_MAX_PAYLOAD_SIZE /
                                                            sizeof(attribute_group_handle_pair_t)];
  for (i = 0; i < rp0->num_of_handle_pair; i++)
  {
    attribute_group_handle_pair[i].found_attribute_handle = rp0->attribute_group_handle_pair[i].found_attribute_handle;
    size += 2;
    attribute_group_handle_pair[i].group_end_handle = rp0->attribute_group_handle_pair[i].group_end_handle;
    size += 2;
  }
  aci_att_find_by_type_value_resp_event(rp0->connection_handle,
                                        rp0->num_of_handle_pair,
                                        attribute_group_handle_pair);

  return status;
}
/* aci_att_read_by_type_resp_event */
/* Event len: 2 + 1 + 1 + rp0->data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a @ref
  *        aci_att_read_by_type_req. See @ref aci_gatt_find_included_services and
  *        @ref aci_gatt_disc_all_char_desc.
  * @param connection_handle Connection handle related to the response
  * @param handle_value_pair_length The size of each attribute handle-value pair
  * @param data_length Length of handle_value_pair_data in octets
  * @param handle_value_pair_data Attribute Data List as defined in Bluetooth
  *        Core v4.1 spec. A sequence of handle-value pairs: [2 octets for
  *        Attribute Handle, (handle_value_pair_length - 2 octets) for Attribute
  *        Value]
  * @retval None
  */

ble_status_t aci_att_read_by_type_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_by_type_resp_event_rp0 *rp0 = (aci_att_read_by_type_resp_event_rp0 *)buffer_in;
  aci_att_read_by_type_resp_event(rp0->connection_handle,
                                  rp0->handle_value_pair_length,
                                  rp0->data_length,
                                  rp0->handle_value_pair_data);

  return status;
}
/* aci_att_read_resp_event */
/* Event len: 2 + 1 + rp0->event_data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a Read Request. See @ref
  *        aci_gatt_read_char_value.
  * @param connection_handle Connection handle related to the response
  * @param event_data_length Length of following data
  * @param attribute_value The value of the attribute.
  * @retval None
  */

ble_status_t aci_att_read_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_resp_event_rp0 *rp0 = (aci_att_read_resp_event_rp0 *)buffer_in;
  aci_att_read_resp_event(rp0->connection_handle,
                          rp0->event_data_length,
                          rp0->attribute_value);

  return status;
}
/* aci_att_read_blob_resp_event */
/* Event len: 2 + 1 + rp0->event_data_length * (sizeof(uint8_t)) */
/**
  * @brief This event can be generated during a read long characteristic value
  *        procedure. See @ref aci_gatt_read_long_char_value.
  * @param connection_handle Connection handle related to the response
  * @param event_data_length Length of following data
  * @param attribute_value Part of the attribute value.
  * @retval None
  */

ble_status_t aci_att_read_blob_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_blob_resp_event_rp0 *rp0 = (aci_att_read_blob_resp_event_rp0 *)buffer_in;
  aci_att_read_blob_resp_event(rp0->connection_handle,
                               rp0->event_data_length,
                               rp0->attribute_value);

  return status;
}
/* aci_att_read_multiple_resp_event */
/* Event len: 2 + 1 + rp0->event_data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a Read Multiple Request.
  * @param connection_handle Connection handle related to the response
  * @param event_data_length Length of following data
  * @param set_of_values A set of two or more values. A concatenation of
  *        attribute values for each of the attribute handles in the request in
  *        the order that they were requested.
  * @retval None
  */

ble_status_t aci_att_read_multiple_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_multiple_resp_event_rp0 *rp0 = (aci_att_read_multiple_resp_event_rp0 *)buffer_in;
  aci_att_read_multiple_resp_event(rp0->connection_handle,
                                   rp0->event_data_length,
                                   rp0->set_of_values);

  return status;
}
/* aci_att_read_by_group_type_resp_event */
/* Event len: 2 + 1 + 1 + rp0->data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a Read By Group Type Request.
  *        See @ref aci_gatt_disc_all_primary_services.
  * @param connection_handle Connection handle related to the response
  * @param attribute_data_length The size of each attribute data
  * @param data_length Length of attribute_data_list in octets
  * @param attribute_data_list Attribute Data List as defined in Bluetooth Core
  *        v4.1 spec. A sequence of attribute handle, end group handle, attribute
  *        value tuples: [2 octets for Attribute Handle, 2 octets End Group
  *        Handle, (attribute_data_length - 4 octets) for Attribute Value]
  * @retval None
  */

ble_status_t aci_att_read_by_group_type_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_by_group_type_resp_event_rp0 *rp0 = (aci_att_read_by_group_type_resp_event_rp0 *)buffer_in;
  aci_att_read_by_group_type_resp_event(rp0->connection_handle,
                                        rp0->attribute_data_length,
                                        rp0->data_length,
                                        rp0->attribute_data_list);

  return status;
}
/* aci_att_prepare_write_resp_event */
/* Event len: 2 + 2 + 2 + 1 + rp0->part_attribute_value_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a @ref
  *        aci_att_prepare_write_req.
  * @param connection_handle Connection handle related to the response
  * @param attribute_handle The handle of the attribute to be written
  * @param offset The offset of the first octet to be written.
  * @param part_attribute_value_length Length of part_attribute_value in octets
  * @param part_attribute_value The value of the attribute to be written
  * @retval None
  */

ble_status_t aci_att_prepare_write_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_prepare_write_resp_event_rp0 *rp0 = (aci_att_prepare_write_resp_event_rp0 *)buffer_in;
  aci_att_prepare_write_resp_event(rp0->connection_handle,
                                   rp0->attribute_handle,
                                   rp0->offset,
                                   rp0->part_attribute_value_length,
                                   rp0->part_attribute_value);

  return status;
}
/* aci_att_exec_write_resp_event */
/* Event len: 2 */
/**
  * @brief This event is generated in response to an Execute Write Request.
  * @param connection_handle Connection handle related to the response
  * @retval None
  */

ble_status_t aci_att_exec_write_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_exec_write_resp_event_rp0 *rp0 = (aci_att_exec_write_resp_event_rp0 *)buffer_in;
  aci_att_exec_write_resp_event(rp0->connection_handle);

  return status;
}
/* aci_gatt_indication_event */
/* Event len: 2 + 2 + 1 + rp0->attribute_value_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated when an indication is received from the
  *        server.
  * @param connection_handle Connection handle related to the response
  * @param attribute_handle The handle of the attribute
  * @param attribute_value_length Length of attribute_value in octets
  * @param attribute_value The current value of the attribute
  * @retval None
  */

ble_status_t aci_gatt_indication_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_indication_event_rp0 *rp0 = (aci_gatt_indication_event_rp0 *)buffer_in;
  aci_gatt_indication_event(rp0->connection_handle,
                            rp0->attribute_handle,
                            rp0->attribute_value_length,
                            rp0->attribute_value);

  return status;
}
/* aci_gatt_notification_event */
/* Event len: 2 + 2 + 1 + rp0->attribute_value_length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated when a notification is received from the
  *        server.
  * @param connection_handle Connection handle related to the response
  * @param attribute_handle The handle of the attribute
  * @param attribute_value_length Length of attribute_value in octets
  * @param attribute_value The current value of the attribute
  * @retval None
  */

ble_status_t aci_gatt_notification_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_notification_event_rp0 *rp0 = (aci_gatt_notification_event_rp0 *)buffer_in;
  aci_gatt_notification_event(rp0->connection_handle,
                              rp0->attribute_handle,
                              rp0->attribute_value_length,
                              rp0->attribute_value);

  return status;
}
/* aci_gatt_proc_complete_event */
/* Event len: 2 + 1 */
/**
  * @brief This event is generated when a GATT client procedure completes either
  *        with error or successfully.
  * @param connection_handle Connection handle related to the response
  * @param error_code Indicates whether the procedure completed with an error or
  *        was successful.
  * @retval None
  */

ble_status_t aci_gatt_proc_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_proc_complete_event_rp0 *rp0 = (aci_gatt_proc_complete_event_rp0 *)buffer_in;
  aci_gatt_proc_complete_event(rp0->connection_handle,
                               rp0->error_code);

  return status;
}
/* aci_gatt_error_resp_event */
/* Event len: 2 + 1 + 2 + 1 */
/**
  * @brief This event is generated when an Error Response is received from the
  *        server. The error response can be given by the server at the end of
  *        one of the GATT discovery procedures. This does not mean that the
  *        procedure ended with an error, but this error event is part of the
  *        procedure itself.
  * @param connection_handle Connection handle related to the response
  * @param req_op_code The request that generated this error response
  * @param attribute_handle The attribute handle that generated this error
  *        response
  * @param error_code The reason why the request has generated an error response
  *        (ATT error codes)
  *        Values:
  *        - 0x01: Invalid handle
  *        - 0x02: Read not permitted
  *        - 0x03: Write not permitted
  *        - 0x04: Invalid PDU
  *        - 0x05: Insufficient authentication
  *        - 0x06: Request not supported
  *        - 0x07: Invalid offset
  *        - 0x08: Insufficient authorization
  *        - 0x09: Prepare queue full
  *        - 0x0A: Attribute not found
  *        - 0x0B: Attribute not long
  *        - 0x0C: Insufficient encryption key size
  *        - 0x0D: Invalid attribute value length
  *        - 0x0E: Unlikely error
  *        - 0x0F: Insufficient encryption
  *        - 0x10: Unsupported group type
  *        - 0x11: Insufficient resources
  * @retval None
  */

ble_status_t aci_gatt_error_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_error_resp_event_rp0 *rp0 = (aci_gatt_error_resp_event_rp0 *)buffer_in;
  aci_gatt_error_resp_event(rp0->connection_handle,
                            rp0->req_op_code,
                            rp0->attribute_handle,
                            rp0->error_code);

  return status;
}
/* aci_gatt_disc_read_char_by_uuid_resp_event */
/* Event len: 2 + 2 + 1 + rp0->attribute_value_length * (sizeof(uint8_t)) */
/**
  * @brief This event can be generated during a "Discover Characteristics By
  *        UUID" procedure or a "Read using Characteristic UUID" procedure. The
  *        attribute value will be a service declaration as defined in Bluetooth
  *        Core v4.1spec (vol.3, Part G, ch. 3.3.1), when a "Discover
  *        Characteristics By UUID" has been started. It will be the value of the
  *        Characteristic if a* "Read using Characteristic UUID" has been
  *        performed.
  * @param connection_handle Connection handle related to the response
  * @param attribute_handle The handle of the attribute
  * @param attribute_value_length Length of attribute_value in octets
  * @param attribute_value The attribute value will be a service declaration as
  *        defined in Bluetooth Core v4.0 spec  (vol.3, Part G, ch. 3.3.1), when
  *        a "Discover Characteristics By UUID" has been started.  It will be the
  *        value of the Characteristic if a "Read using Characteristic UUID" has
  *        been performed.
  * @retval None
  */

ble_status_t aci_gatt_disc_read_char_by_uuid_resp_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_disc_read_char_by_uuid_resp_event_rp0 *rp0 = (aci_gatt_disc_read_char_by_uuid_resp_event_rp0 *)buffer_in;
  aci_gatt_disc_read_char_by_uuid_resp_event(rp0->connection_handle,
                                             rp0->attribute_handle,
                                             rp0->attribute_value_length,
                                             rp0->attribute_value);

  return status;
}
/* aci_gatt_write_permit_req_event */
/* Event len: 2 + 2 + 1 + rp0->data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is given to the application when a write request, write
  *        command or signed write command is received by the server from the
  *        client. This event will be given to the application only if the event
  *        bit for this event generation is set when the characteristic was
  *        added. When this event is received, the application has to check
  *        whether the value being requested for write can be allowed to be
  *        written and respond with the command @ref aci_gatt_write_resp. The
  *        details of the parameters of the command can be found. Based on the
  *        response from the application, the attribute value will be modified by
  *        the stack. If the write is rejected by the application, then the value
  *        of the attribute will not be modified. In case of a write REQ, an
  *        error response will be sent to the client, with the error code as
  *        specified by the application. In case of write/signed write commands,
  *        no response is sent to the client but the attribute is not modified.
  * @param connection_handle Handle of the connection on which there was the
  *        request to write the attribute
  * @param attribute_handle The handle of the attribute
  * @param data_length Length of Data field
  * @param data The data that the client has requested to write
  * @retval None
  */

ble_status_t aci_gatt_write_permit_req_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_write_permit_req_event_rp0 *rp0 = (aci_gatt_write_permit_req_event_rp0 *)buffer_in;
  aci_gatt_write_permit_req_event(rp0->connection_handle,
                                  rp0->attribute_handle,
                                  rp0->data_length,
                                  rp0->data);

  return status;
}
/* aci_gatt_read_permit_req_event */
/* Event len: 2 + 2 + 2 */
/**
  * @brief This event is given to the application when a read request or read
  *        blob request is received by the server from the client. This event
  *        will be given to the application only if the event bit for this event
  *        generation is set when the characteristic was added. On receiving this
  *        event, the application can update the value of the handle if it
  *        desires and when done, it has to send the @ref aci_gatt_allow_read
  *        command to indicate to the stack that it can send the response to the
  *        client.
  * @param connection_handle Connection handle related to the response
  * @param attribute_handle The handle of the attribute
  * @param offset Contains the offset from which the read has been requested
  * @retval None
  */

ble_status_t aci_gatt_read_permit_req_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_read_permit_req_event_rp0 *rp0 = (aci_gatt_read_permit_req_event_rp0 *)buffer_in;
  aci_gatt_read_permit_req_event(rp0->connection_handle,
                                 rp0->attribute_handle,
                                 rp0->offset);

  return status;
}
/* aci_gatt_read_multi_permit_req_event */
/* Event len: 2 + 1 + rp0->number_of_handles * (sizeof(handle_item_t)) */
/**
  * @brief This event is given to the application when a read multiple request or
  *        read by type request is received by the server from the client. This
  *        event will be given to the application only if the event bit for this
  *        event generation is set when the characteristic was added. On
  *        receiving this event, the application can update the values of the
  *        handles if it desires and when done, it has to send the @ref
  *        aci_gatt_allow_read command to indicate to the stack that it can send
  *        the response to the client.
  * @param connection_handle Handle of the connection which requested to read the
  *        attribute
  * @param number_of_handles
  * @param handle_item See @ref handle_item_t
  * @retval None
  */

ble_status_t aci_gatt_read_multi_permit_req_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_read_multi_permit_req_event_rp0 *rp0 = (aci_gatt_read_multi_permit_req_event_rp0 *)buffer_in;
  uint8_t size = 3;
  int32_t i;
  handle_item_t handle_item[HCI_MAX_PAYLOAD_SIZE / sizeof(handle_item_t)];
  for (i = 0; i < rp0->number_of_handles; i++)
  {
    handle_item[i].handle = rp0->handle_item[i].handle;
    size += 2;
  }
  aci_gatt_read_multi_permit_req_event(rp0->connection_handle,
                                       rp0->number_of_handles,
                                       handle_item);

  return status;
}
/* aci_gatt_tx_pool_available_event */
/* Event len: 2 + 2 */
/**
  * @brief Each time BLE FW stack raises the error code @ref
  *        ble_status_insufficient_resources (0x64), the @ref
  *        aci_gatt_tx_pool_available_event event is generated as soon as the
  *        available buffer size  is greater than maximum ATT MTU (on stack
  *        versions below v2.1 this event is generated when at least 2 packets
  *        with MTU of 23 bytes are available).
  * @param connection_handle Connection handle related to the request
  * @param available_buffers Not used.
  * @retval None
  */

ble_status_t aci_gatt_tx_pool_available_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_tx_pool_available_event_rp0 *rp0 = (aci_gatt_tx_pool_available_event_rp0 *)buffer_in;
  aci_gatt_tx_pool_available_event(rp0->connection_handle,
                                   rp0->available_buffers);

  return status;
}
/* aci_gatt_server_confirmation_event */
/* Event len: 2 */
/**
  * @brief This event is generated when the client has sent the confirmation to a
  *        previously sent indication
  * @param connection_handle Connection handle related to the event
  * @retval None
  */

ble_status_t aci_gatt_server_confirmation_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_server_confirmation_event_rp0 *rp0 = (aci_gatt_server_confirmation_event_rp0 *)buffer_in;
  aci_gatt_server_confirmation_event(rp0->connection_handle);

  return status;
}
/* aci_gatt_prepare_write_permit_req_event */
/* Event len: 2 + 2 + 2 + 1 + rp0->data_length * (sizeof(uint8_t)) */
/**
  * @brief This event is given to the application when a prepare write request is
  *        received by the server from the client. This event will be given to
  *        the application only if the event bit for this event generation is set
  *        when the characteristic was added. When this event is received, the
  *        application has to check whether the value being requested for write
  *        can be allowed to be written and respond with the command @ref
  *        aci_gatt_write_resp. Based on the response from the application, the
  *        attribute value will be modified by the stack. If the write is
  *        rejected by the application, then the value of the attribute will not
  *        be modified and an error response will be sent to the client, with the
  *        error code as specified by the application.
  * @param connection_handle Handle of the connection on which there was the
  *        request to write the attribute
  * @param attribute_handle The handle of the attribute
  * @param offset The offset from which the prepare write has been requested
  * @param data_length Length of Data field
  * @param data The data that the client has requested to write
  * @retval None
  */

ble_status_t aci_gatt_prepare_write_permit_req_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_prepare_write_permit_req_event_rp0 *rp0 = (aci_gatt_prepare_write_permit_req_event_rp0 *)buffer_in;
  aci_gatt_prepare_write_permit_req_event(rp0->connection_handle,
                                          rp0->attribute_handle,
                                          rp0->offset,
                                          rp0->data_length,
                                          rp0->data);

  return status;
}
/* hci_le_connection_complete_event */
/* Event len: 1 + 2 + 1 + 1 + 6 + 2 + 2 + 2 + 1 */
/**
  * @brief The LE Connection Complete event indicates to both of the Hosts
  *        forming the connection that a new connection has been created. Upon
  *        the creation of the connection a connection_handle shall be assigned
  *        by the Controller, and passed to the Host in this event. If the
  *        connection establishment fails this event shall be provided to the
  *        Host that had issued the LE_Create_Connection command. This event
  *        indicates to the Host which issued a LE_Create_Connection command and
  *        received a Command status event if the connection establishment failed
  *        or was successful. The master_clock_accuracy parameter is only valid
  *        for a slave. On a master, this parameter shall be set to 0x00.
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param connection_handle Connection handle to be used to identify the
  *        connection with the peer device.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param role Role of the local device in the connection.
  *        Values:
  *        - 0x00: Master
  *        - 0x01: Slave
  * @param peer_address_type The address type of the peer device.
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  * @param peer_address Public Device Address or Random Device Address of the
  *        peer device
  * @param conn_interval Connection interval used on this connection. Time = N *
  *        1.25 msec
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param supervision_timeout Supervision timeout for the LE Link. It shall be a
  *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
  *        connInterval * 2. Time = N * 10 msec.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @param master_clock_accuracy Master clock accuracy. Only valid for a slave.
  *        Values:
  *        - 0x00: 500 ppm
  *        - 0x01: 250 ppm
  *        - 0x02: 150 ppm
  *        - 0x03: 100 ppm
  *        - 0x04: 75 ppm
  *        - 0x05: 50 ppm
  *        - 0x06: 30 ppm
  *        - 0x07: 20 ppm
  * @retval None
  */

ble_status_t hci_le_connection_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_connection_complete_event_rp0 *rp0 = (hci_le_connection_complete_event_rp0 *)buffer_in;
  hci_le_connection_complete_event(rp0->status,
                                   rp0->connection_handle,
                                   rp0->role,
                                   rp0->peer_address_type,
                                   rp0->peer_address,
                                   rp0->conn_interval,
                                   rp0->conn_latency,
                                   rp0->supervision_timeout,
                                   rp0->master_clock_accuracy);

  return status;
}
/* hci_le_advertising_report_event */
/* Event len: 1 + rp0->num_reports * (sizeof(advertising_report_t)) */
/**
  * @brief The LE Advertising Report event indicates that a Bluetooth device or
  *        multiple Bluetooth devices have responded to an active scan or
  *        received some information during a passive scan. The Controller may
  *        queue these advertising reports and send information from multiple
  *        devices in one LE Advertising Report event.
  * @param num_reports Number of responses in this event.
  *        Values:
  *        - 0x01
  * @param advertising_report See @ref advertising_report_t
  * @retval None
  */

ble_status_t hci_le_advertising_report_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_advertising_report_event_rp0 *rp0 = (hci_le_advertising_report_event_rp0 *)buffer_in;
  uint8_t size = 1;
  int32_t i;
  advertising_report_t advertising_report[HCI_MAX_PAYLOAD_SIZE / sizeof(advertising_report_t)];
  for (i = 0; i < rp0->num_reports; i++)
  {
    advertising_report[i].event_type = rp0->advertising_report[i].event_type;
    size += 1;
    advertising_report[i].address_type = rp0->advertising_report[i].address_type;
    size += 1;
    BLUENRG_MEMCPY((void *) advertising_report[i].address, (const void *) rp0->advertising_report[i].address, 6);
    size += 6;
    advertising_report[i].length_data = rp0->advertising_report[i].length_data;
    size += 1;
    advertising_report[i].data = rp0->advertising_report[i].data;
    size += rp0->advertising_report[i].length_data;
    advertising_report[i].rssi = (uint8_t)buffer_in[size];
    size += 1;
  }
  hci_le_advertising_report_event(rp0->num_reports,
                                  advertising_report);

  return status;
}
/* hci_le_connection_update_complete_event */
/* Event len: 1 + 2 + 2 + 2 + 2 */
/**
  * @brief The LE Connection Update Complete event is used to indicate that the
  *        Controller process to update the connection has completed. On a slave,
  *        if no connection parameters are updated, then this event shall not be
  *        issued. On a master, this event shall be issued if the
  *        Connection_Update command was sent.
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param connection_handle Connection handle to be used to identify the
  *        connection with the peer device.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param conn_interval Connection interval used on this connection. Time = N *
  *        1.25 msec
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param supervision_timeout Supervision timeout for the LE Link. It shall be a
  *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
  *        connInterval * 2. Time = N * 10 msec.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @retval None
  */

ble_status_t hci_le_connection_update_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_connection_update_complete_event_rp0 *rp0 = (hci_le_connection_update_complete_event_rp0 *)buffer_in;
  hci_le_connection_update_complete_event(rp0->status,
                                          rp0->connection_handle,
                                          rp0->conn_interval,
                                          rp0->conn_latency,
                                          rp0->supervision_timeout);

  return status;
}
/* hci_le_read_remote_used_features_complete_event */
/* Event len: 1 + 2 + 8 */
/**
  * @brief The LE Read Remote Used Features Complete event is used to indicate
  *        the completion of the process of the Controller obtaining the used
  *        features of the remote Bluetooth device specified by the
  *        connection_handle event parameter.
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param connection_handle Connection handle to be used to identify the
  *        connection with the peer device.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param le_features Bit Mask List of used LE features. For details see LE Link
  *        Layer specification.
  * @retval None
  */

ble_status_t hci_le_read_remote_used_features_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_read_remote_used_features_complete_event_rp0 *rp0 =
    (hci_le_read_remote_used_features_complete_event_rp0 *)buffer_in;
  hci_le_read_remote_used_features_complete_event(rp0->status,
                                                  rp0->connection_handle,
                                                  rp0->le_features);

  return status;
}
/* hci_le_long_term_key_request_event */
/* Event len: 2 + 8 + 2 */
/**
  * @brief The LE Long Term Key Request event indicates that the master device is
  *        attempting to encrypt or re-encrypt the link and is requesting the
  *        Long Term Key from the Host. (See [Vol 6] Part B, Section 5.1.3).
  * @param connection_handle Connection handle to be used to identify the
  *        connection with the peer device.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param random_number 64-bit random number
  * @param encrypted_diversifier 16-bit encrypted diversifier
  * @retval None
  */

ble_status_t hci_le_long_term_key_request_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_long_term_key_request_event_rp0 *rp0 = (hci_le_long_term_key_request_event_rp0 *)buffer_in;
  hci_le_long_term_key_request_event(rp0->connection_handle,
                                     rp0->random_number,
                                     rp0->encrypted_diversifier);

  return status;
}
/* hci_le_data_length_change_event */
/* Event len: 2 + 2 + 2 + 2 + 2 */
/**
  * @brief The LE Data Length Change event notifies the Host of a change to
  *        either the maximum Payload length or the maximum transmission time of
  *        Data Channel PDUs in either direction. The values reported are the
  *        maximum that will actually be used on the connection following the
  *        change.
  * @param connection_handle connection_handle to be used to identify a
  *        connection.
  * @param max_tx_octets The maximum number of payload octets in a Link Layer Data
  *        Channel PDU that the local Controller will send on this connection
  *        (connEffectiveMaxTxOctets defined in [Vol 6] Part B, Section 4.5.10).
  *        Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for
  *        future use)
  * @param max_tx_time The maximum time that the local Controller will take to send
  *        a Link Layer Data Channel PDU on this connection (connEffectiveMaxTx-
  *        Time defined in [Vol 6] Part B, Section 4.5.10). Range 0x0148-0x0848
  *        (0x0000 - 0x0127 and 0x0849 - 0xFFFF Reserved for future use)
  * @param max_rx_octets The maximum number of payload octets in a Link Layer Data
  *        Channel PDU that the local controller expects to receive on this
  *        connection (connEfectiveMaxRxOctets defined in [Vol 6] Part B, Section
  *        4.5.10). Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF
  *        Reserved for future use)
  * @param max_rx_time The maximum time that the local Controller expects to take
  *        to receive a Link Layer Data Channel PDU on this connection
  *        (connEffectiveMax-RxTime defined in [Vol 6] Part B, Section 4.5.10).
  *        Range 0x0148-0x0848 (0x0000 - 0x0127 and 0x0849 - 0xFFFF Reserved for
  *        future use)
  * @retval None
  */

ble_status_t hci_le_data_length_change_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_data_length_change_event_rp0 *rp0 = (hci_le_data_length_change_event_rp0 *)buffer_in;
  hci_le_data_length_change_event(rp0->connection_handle,
                                  rp0->max_tx_octets,
                                  rp0->max_tx_time,
                                  rp0->max_rx_octets,
                                  rp0->max_rx_time);

  return status;
}
/* hci_le_read_local_p256_public_key_complete_event */
/* Event len: 1 + 64 */
/**
  * @brief This event is generated when local P-256 key generation is complete.
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param local_p256_public_key Local P-256 public key.
  * @retval None
  */

ble_status_t hci_le_read_local_p256_public_key_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_read_local_p256_public_key_complete_event_rp0 *rp0 =
    (hci_le_read_local_p256_public_key_complete_event_rp0 *)buffer_in;
  hci_le_read_local_p256_public_key_complete_event(rp0->status,
                                                   rp0->local_p256_public_key);

  return status;
}
/* hci_le_generate_dhkey_complete_event */
/* Event len: 1 + 32 */
/**
  * @brief This event indicates that LE Diffie Hellman key generation has been
  *        completed by the Controller.
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param dh_key Diffie Hellman Key
  * @retval None
  */

ble_status_t hci_le_generate_dhkey_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_generate_dhkey_complete_event_rp0 *rp0 = (hci_le_generate_dhkey_complete_event_rp0 *)buffer_in;
  hci_le_generate_dhkey_complete_event(rp0->status,
                                       rp0->dh_key);

  return status;
}
/* hci_le_enhanced_connection_complete_event */
/* Event len: 1 + 2 + 1 + 1 + 6 + 6 + 6 + 2 + 2 + 2 + 1 */
/**
  * @brief The LE Enhanced Connection Complete event indicates to both of the
  *        Hosts forming the connection that a new connection has been created.
  *        Upon the creation of the connection a connection_handle shall be
  *        assigned by the Controller, and passed to the Host in this event. If
  *        the connection establishment fails, this event shall be provided to
  *        the Host that had issued the LE_Create_Connection command. If this
  *        event is unmasked and LE Connection Complete event is unmasked, only
  *        the LE Enhanced Connection Complete event is sent when a new
  *        connection has been completed. This event indicates to the Host that
  *        issued a LE_Create_Connection command and received a Command status
  *        event if the connection establishment failed or was successful. The
  *        master_clock_accuracy parameter is only valid for a slave. On a
  *        master, this parameter shall be set to 0x00.
  * @param status For standard error codes see Bluetooth specification, Vol. 2,
  *        part D. For proprietary error code refer to Error codes section
  * @param connection_handle Connection handle to be used to identify the
  *        connection with the peer device.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param role Role of the local device in the connection.
  *        Values:
  *        - 0x00: Master
  *        - 0x01: Slave
  * @param peer_address_type 0x00 Public Device Address 0x01 Random Device
  *        Address 0x02 Public Identity Address (Corresponds to Resolved Private
  *        Address) 0x03 Random (Static) Identity Address (Corresponds to
  *        Resolved Private Address)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Public Identity Address
  *        - 0x03: Random (Static) Identity Address
  * @param peer_address Public Device Address, Random Device Address, Public
  *        Identity Address or Random (static) Identity Address of the device to
  *        be connected.
  * @param local_resolvable_private_address Resolvable Private Address being used
  *        by the local device for this connection. This is only valid when the
  *        own_address_type is set to 0x02 or 0x03. For other own_address_type
  *        values, the Controller shall return all zeros.
  * @param peer_resolvable_private_address Resolvable Private Address being used
  *        by the peer device for this connection. This is only valid for
  *        peer_address_type 0x02 and 0x03. For other peer_address_type values,
  *        the Controller shall return all zeros.
  * @param conn_interval Connection interval used on this connection. Time = N *
  *        1.25 msec
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param supervision_timeout Supervision timeout for the LE Link. It shall be a
  *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
  *        connInterval * 2. Time = N * 10 msec.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @param master_clock_accuracy Master clock accuracy. Only valid for a slave.
  *        Values:
  *        - 0x00: 500 ppm
  *        - 0x01: 250 ppm
  *        - 0x02: 150 ppm
  *        - 0x03: 100 ppm
  *        - 0x04: 75 ppm
  *        - 0x05: 50 ppm
  *        - 0x06: 30 ppm
  *        - 0x07: 20 ppm
  * @retval None
  */

ble_status_t hci_le_enhanced_connection_complete_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_enhanced_connection_complete_event_rp0 *rp0 = (hci_le_enhanced_connection_complete_event_rp0 *)buffer_in;
  hci_le_enhanced_connection_complete_event(rp0->status,
                                            rp0->connection_handle,
                                            rp0->role,
                                            rp0->peer_address_type,
                                            rp0->peer_address,
                                            rp0->local_resolvable_private_address,
                                            rp0->peer_resolvable_private_address,
                                            rp0->conn_interval,
                                            rp0->conn_latency,
                                            rp0->supervision_timeout,
                                            rp0->master_clock_accuracy);

  return status;
}
/* hci_le_direct_advertising_report_event */
/* Event len: 1 + rp0->num_reports * (sizeof(direct_advertising_report_t)) */
/**
  * @brief The LE Direct Advertising Report event indicates that directed
  *        advertisements have been received where the advertiser is using a
  *        resolvable private address for the InitA field in the ADV_DIRECT_IND
  *        PDU and the scanning_filter_policy is equal to 0x02 or 0x03, see
  *        HCI_LE_Set_Scan_Parameters. direct_address_type and Direct_Addres is
  *        the address the directed advertisements are being directed to.
  *        address_type and Address is the address of the advertiser sending the
  *        directed advertisements.
  * @param num_reports Number of responses in this event.
  *        Values:
  *        - 0x01
  * @param direct_advertising_report See @ref direct_advertising_report_t
  * @retval None
  */

ble_status_t hci_le_direct_advertising_report_event_process(uint8_t *buffer_in)
{
  ble_status_t status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_direct_advertising_report_event_rp0 *rp0 = (hci_le_direct_advertising_report_event_rp0 *)buffer_in;
  uint8_t size = 1;
  int32_t i;
  direct_advertising_report_t direct_advertising_report[HCI_MAX_PAYLOAD_SIZE / sizeof(direct_advertising_report_t)];
  for (i = 0; i < rp0->num_reports; i++)
  {
    direct_advertising_report[i].event_type = rp0->direct_advertising_report[i].event_type;
    size += 1;
    direct_advertising_report[i].address_type = rp0->direct_advertising_report[i].address_type;
    size += 1;
    BLUENRG_MEMCPY((void *) direct_advertising_report[i].address,
                   (const void *) rp0->direct_advertising_report[i].address,
                   6);
    size += 6;
    direct_advertising_report[i].direct_address_type = rp0->direct_advertising_report[i].direct_address_type;
    size += 1;
    BLUENRG_MEMCPY((void *) direct_advertising_report[i].direct_address,
                   (const void *) rp0->direct_advertising_report[i].direct_address, 6);
    size += 6;
    direct_advertising_report[i].rssi = rp0->direct_advertising_report[i].rssi;
    size += 1;
  }
  hci_le_direct_advertising_report_event(rp0->num_reports,
                                         direct_advertising_report);

  return status;
}
