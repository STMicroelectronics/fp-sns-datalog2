/**
  ******************************************************************************
  * @file    bluenrg1_gatt_aci.c
  * @author  AMG - RF Application team
  * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode
  *          (gatt_aci)
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
#include "ble_types.h"
#include "bluenrg1_gatt_aci.h"
ble_status_t aci_gatt_init(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x101;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_add_service(uint8_t service_uuid_type,
                                  service_uuid_t *service_uuid,
                                  uint8_t service_type,
                                  uint8_t max_attribute_records,
                                  uint16_t *service_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_add_service_cp0 *cp0 = (aci_gatt_add_service_cp0 *)(cmd_buffer);
  aci_gatt_add_service_cp1 *cp1 =
    (aci_gatt_add_service_cp1 *)(cmd_buffer + 1 + (service_uuid_type == 1 ? 2 : (service_uuid_type == 2 ? 16 : 0)));
  aci_gatt_add_service_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->service_uuid_type = HTOB(service_uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (service_uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->service_uuid, (const void *) service_uuid, size);
    index_input += size;
    {
      cp1->service_type = HTOB(service_type, 1);
    }
    index_input += 1;
    {
      cp1->max_attribute_records = HTOB(max_attribute_records, 1);
    }
    index_input += 1;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x102;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *service_handle = BTOH(resp.service_handle, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_include_service(uint16_t service_handle,
                                      uint16_t include_start_handle,
                                      uint16_t include_end_handle,
                                      uint8_t include_uuid_type,
                                      include_uuid_t *include_uuid,
                                      uint16_t *include_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_include_service_cp0 *cp0 = (aci_gatt_include_service_cp0 *)(cmd_buffer);
  aci_gatt_include_service_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->service_handle = HTOB(service_handle, 2);
  index_input += 2;
  cp0->include_start_handle = HTOB(include_start_handle, 2);
  index_input += 2;
  cp0->include_end_handle = HTOB(include_end_handle, 2);
  index_input += 2;
  cp0->include_uuid_type = HTOB(include_uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (include_uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->include_uuid, (const void *) include_uuid, size);
    index_input += size;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x103;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *include_handle = BTOH(resp.include_handle, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_add_char(uint16_t service_handle,
                               uint8_t char_uuid_type,
                               char_uuid_t *char_uuid,
                               uint16_t char_value_length,
                               uint8_t char_properties,
                               uint8_t security_permissions,
                               uint8_t gatt_evt_mask,
                               uint8_t enc_key_size,
                               uint8_t is_variable,
                               uint16_t *char_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_add_char_cp0 *cp0 = (aci_gatt_add_char_cp0 *)(cmd_buffer);
  aci_gatt_add_char_cp1 *cp1 =
    (aci_gatt_add_char_cp1 *)(cmd_buffer + 2 + 1 + (char_uuid_type == 1 ? 2 : (char_uuid_type == 2 ? 16 : 0)));
  aci_gatt_add_char_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->service_handle = HTOB(service_handle, 2);
  index_input += 2;
  cp0->char_uuid_type = HTOB(char_uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (char_uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->char_uuid, (const void *) char_uuid, size);
    index_input += size;
    {
      cp1->char_value_length = HTOB(char_value_length, 2);
    }
    index_input += 2;
    {
      cp1->char_properties = HTOB(char_properties, 1);
    }
    index_input += 1;
    {
      cp1->security_permissions = HTOB(security_permissions, 1);
    }
    index_input += 1;
    {
      cp1->gatt_evt_mask = HTOB(gatt_evt_mask, 1);
    }
    index_input += 1;
    {
      cp1->enc_key_size = HTOB(enc_key_size, 1);
    }
    index_input += 1;
    {
      cp1->is_variable = HTOB(is_variable, 1);
    }
    index_input += 1;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x104;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *char_handle = BTOH(resp.char_handle, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_add_char_desc(uint16_t service_handle,
                                    uint16_t char_handle,
                                    uint8_t char_desc_uuid_type,
                                    char_desc_uuid_t *char_desc_uuid,
                                    uint8_t char_desc_value_max_len,
                                    uint8_t char_desc_value_length,
                                    uint8_t char_desc_value[],
                                    uint8_t security_permissions,
                                    uint8_t access_permissions,
                                    uint8_t gatt_evt_mask,
                                    uint8_t enc_key_size,
                                    uint8_t is_variable,
                                    uint16_t *char_desc_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  aci_gatt_add_char_desc_cp0 *cp0 = (aci_gatt_add_char_desc_cp0 *)(cmd_buffer);
  aci_gatt_add_char_desc_cp1 *cp1 =
    (aci_gatt_add_char_desc_cp1 *)(cmd_buffer + 2 + 2 + 1 +
                                   (char_desc_uuid_type == 1 ? 2 : (char_desc_uuid_type == 2 ? 16 : 0)));
  aci_gatt_add_char_desc_cp2 *cp2 =
    (aci_gatt_add_char_desc_cp2 *)(cmd_buffer + 2 + 2 + 1 +
                                   (char_desc_uuid_type == 1 ? 2 : (char_desc_uuid_type == 2 ? 16 : 0)) +
                                   1 + 1 + char_desc_value_length * (sizeof(uint8_t)));
  aci_gatt_add_char_desc_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->service_handle = HTOB(service_handle, 2);
  index_input += 2;
  cp0->char_handle = HTOB(char_handle, 2);
  index_input += 2;
  cp0->char_desc_uuid_type = HTOB(char_desc_uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (char_desc_uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->char_desc_uuid, (const void *) char_desc_uuid, size);
    index_input += size;
    {
      cp1->char_desc_value_max_len = HTOB(char_desc_value_max_len, 1);
    }
    index_input += 1;
    {
      cp1->char_desc_value_length = HTOB(char_desc_value_length, 1);
    }
    index_input += 1;
    BLUENRG_MEMCPY((void *) &cp1->char_desc_value, (const void *) char_desc_value,
                   char_desc_value_length * sizeof(uint8_t));
    index_input += char_desc_value_length * sizeof(uint8_t);
    {
      cp2->security_permissions = HTOB(security_permissions, 1);
    }
    index_input += 1;
    {
      cp2->access_permissions = HTOB(access_permissions, 1);
    }
    index_input += 1;
    {
      cp2->gatt_evt_mask = HTOB(gatt_evt_mask, 1);
    }
    index_input += 1;
    {
      cp2->enc_key_size = HTOB(enc_key_size, 1);
    }
    index_input += 1;
    {
      cp2->is_variable = HTOB(is_variable, 1);
    }
    index_input += 1;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x105;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *char_desc_handle = BTOH(resp.char_desc_handle, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_update_char_value(uint16_t service_handle,
                                        uint16_t char_handle,
                                        uint8_t val_offset,
                                        uint8_t char_value_length,
                                        uint8_t char_value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_update_char_value_cp0 *cp0 = (aci_gatt_update_char_value_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->service_handle = HTOB(service_handle, 2);
  index_input += 2;
  cp0->char_handle = HTOB(char_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 1);
  index_input += 1;
  cp0->char_value_length = HTOB(char_value_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->char_value, (const void *) char_value, char_value_length * sizeof(uint8_t));
    index_input += char_value_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x106;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_del_char(uint16_t serv_handle,
                               uint16_t char_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_del_char_cp0 *cp0 = (aci_gatt_del_char_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->serv_handle = HTOB(serv_handle, 2);
  index_input += 2;
  cp0->char_handle = HTOB(char_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x107;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_del_service(uint16_t serv_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_del_service_cp0 *cp0 = (aci_gatt_del_service_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->serv_handle = HTOB(serv_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x108;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_del_include_service(uint16_t serv_handle,
                                          uint16_t include_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_del_include_service_cp0 *cp0 = (aci_gatt_del_include_service_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->serv_handle = HTOB(serv_handle, 2);
  index_input += 2;
  cp0->include_handle = HTOB(include_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x109;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_set_event_mask(uint32_t gatt_evt_mask)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_set_event_mask_cp0 *cp0 = (aci_gatt_set_event_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->gatt_evt_mask = HTOB(gatt_evt_mask, 4);
  index_input += 4;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x10a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_exchange_config(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_exchange_config_cp0 *cp0 = (aci_gatt_exchange_config_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x10b;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_att_find_info_req(uint16_t connection_handle,
                                   uint16_t start_handle,
                                   uint16_t end_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_att_find_info_req_cp0 *cp0 = (aci_att_find_info_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x10c;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_att_find_by_type_value_req(uint16_t connection_handle,
                                            uint16_t start_handle,
                                            uint16_t end_handle,
                                            uint16_t uuid,
                                            uint8_t attribute_val_length,
                                            uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_att_find_by_type_value_req_cp0 *cp0 = (aci_att_find_by_type_value_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  cp0->uuid = HTOB(uuid, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x10d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_att_read_by_type_req(uint16_t connection_handle,
                                      uint16_t start_handle,
                                      uint16_t end_handle,
                                      uint8_t uuid_type,
                                      uuid_t *uuid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_att_read_by_type_req_cp0 *cp0 = (aci_att_read_by_type_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  cp0->uuid_type = HTOB(uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->uuid, (const void *) uuid, size);
    index_input += size;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x10e;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_att_read_by_group_type_req(uint16_t connection_handle,
                                            uint16_t start_handle,
                                            uint16_t end_handle,
                                            uint8_t uuid_type,
                                            uuid_t *uuid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_att_read_by_group_type_req_cp0 *cp0 = (aci_att_read_by_group_type_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  cp0->uuid_type = HTOB(uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->uuid, (const void *) uuid, size);
    index_input += size;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x10f;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_att_prepare_write_req(uint16_t connection_handle,
                                       uint16_t attr_handle,
                                       uint16_t val_offset,
                                       uint8_t attribute_val_length,
                                       uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_att_prepare_write_req_cp0 *cp0 = (aci_att_prepare_write_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x110;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_att_execute_write_req(uint16_t connection_handle,
                                       uint8_t execute)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_att_execute_write_req_cp0 *cp0 = (aci_att_execute_write_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->execute = HTOB(execute, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x111;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_disc_all_primary_services(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_disc_all_primary_services_cp0 *cp0 = (aci_gatt_disc_all_primary_services_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x112;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_disc_primary_service_by_uuid(uint16_t connection_handle,
                                                   uint8_t uuid_type,
                                                   uuid_t *uuid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_disc_primary_service_by_uuid_cp0 *cp0 = (aci_gatt_disc_primary_service_by_uuid_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->uuid_type = HTOB(uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->uuid, (const void *) uuid, size);
    index_input += size;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x113;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_find_included_services(uint16_t connection_handle,
                                             uint16_t start_handle,
                                             uint16_t end_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_find_included_services_cp0 *cp0 = (aci_gatt_find_included_services_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x114;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_disc_all_char_of_service(uint16_t connection_handle,
                                               uint16_t start_handle,
                                               uint16_t end_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_disc_all_char_of_service_cp0 *cp0 = (aci_gatt_disc_all_char_of_service_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x115;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_disc_char_by_uuid(uint16_t connection_handle,
                                        uint16_t start_handle,
                                        uint16_t end_handle,
                                        uint8_t uuid_type,
                                        uuid_t *uuid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_disc_char_by_uuid_cp0 *cp0 = (aci_gatt_disc_char_by_uuid_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  cp0->uuid_type = HTOB(uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->uuid, (const void *) uuid, size);
    index_input += size;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x116;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_disc_all_char_desc(uint16_t connection_handle,
                                         uint16_t char_handle,
                                         uint16_t end_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_disc_all_char_desc_cp0 *cp0 = (aci_gatt_disc_all_char_desc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->char_handle = HTOB(char_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x117;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_read_char_value(uint16_t connection_handle,
                                      uint16_t attr_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_read_char_value_cp0 *cp0 = (aci_gatt_read_char_value_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x118;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_read_using_char_uuid(uint16_t connection_handle,
                                           uint16_t start_handle,
                                           uint16_t end_handle,
                                           uint8_t uuid_type,
                                           uuid_t *uuid)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_read_using_char_uuid_cp0 *cp0 = (aci_gatt_read_using_char_uuid_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->start_handle = HTOB(start_handle, 2);
  index_input += 2;
  cp0->end_handle = HTOB(end_handle, 2);
  index_input += 2;
  cp0->uuid_type = HTOB(uuid_type, 1);
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch (uuid_type)
    {
      case 1:
        size = 2;
        break;
      case 2:
        size = 16;
        break;
      default:
        return BLE_STATUS_ERROR;
    }
    BLUENRG_MEMCPY((void *) &cp0->uuid, (const void *) uuid, size);
    index_input += size;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x119;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_read_long_char_value(uint16_t connection_handle,
                                           uint16_t attr_handle,
                                           uint16_t val_offset)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_read_long_char_value_cp0 *cp0 = (aci_gatt_read_long_char_value_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11a;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_read_multiple_char_value(uint16_t connection_handle,
                                               uint8_t number_of_handles,
                                               handle_entry_t handle_entry[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_read_multiple_char_value_cp0 *cp0 = (aci_gatt_read_multiple_char_value_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->number_of_handles = HTOB(number_of_handles, 1);
  index_input += 1;
  /* var_len_data input */
  {
    for (uint8_t i = 0; i < number_of_handles; i++)
    {
      cp0->handle_entry[i].handle = handle_entry[i].handle;
    }
    index_input += number_of_handles * 2;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11b;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_write_char_value(uint16_t connection_handle,
                                       uint16_t attr_handle,
                                       uint8_t attribute_val_length,
                                       uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_write_char_value_cp0 *cp0 = (aci_gatt_write_char_value_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11c;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_write_long_char_value(uint16_t connection_handle,
                                            uint16_t attr_handle,
                                            uint16_t val_offset,
                                            uint8_t attribute_val_length,
                                            uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_write_long_char_value_cp0 *cp0 = (aci_gatt_write_long_char_value_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_write_char_reliable(uint16_t connection_handle,
                                          uint16_t attr_handle,
                                          uint16_t val_offset,
                                          uint8_t attribute_val_length,
                                          uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_write_char_reliable_cp0 *cp0 = (aci_gatt_write_char_reliable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11e;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_write_long_char_desc(uint16_t connection_handle,
                                           uint16_t attr_handle,
                                           uint16_t val_offset,
                                           uint8_t attribute_val_length,
                                           uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_write_long_char_desc_cp0 *cp0 = (aci_gatt_write_long_char_desc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x11f;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_read_long_char_desc(uint16_t connection_handle,
                                          uint16_t attr_handle,
                                          uint16_t val_offset)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_read_long_char_desc_cp0 *cp0 = (aci_gatt_read_long_char_desc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x120;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_write_char_desc(uint16_t connection_handle,
                                      uint16_t attr_handle,
                                      uint8_t attribute_val_length,
                                      uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_write_char_desc_cp0 *cp0 = (aci_gatt_write_char_desc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x121;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_read_char_desc(uint16_t connection_handle,
                                     uint16_t attr_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_read_char_desc_cp0 *cp0 = (aci_gatt_read_char_desc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x122;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_write_without_resp(uint16_t connection_handle,
                                         uint16_t attr_handle,
                                         uint8_t attribute_val_length,
                                         uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_write_without_resp_cp0 *cp0 = (aci_gatt_write_without_resp_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x123;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_signed_write_without_resp(uint16_t connection_handle,
                                                uint16_t attr_handle,
                                                uint8_t attribute_val_length,
                                                uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_signed_write_without_resp_cp0 *cp0 = (aci_gatt_signed_write_without_resp_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x124;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_confirm_indication(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_confirm_indication_cp0 *cp0 = (aci_gatt_confirm_indication_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x125;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_write_resp(uint16_t connection_handle,
                                 uint16_t attr_handle,
                                 uint8_t write_status,
                                 uint8_t error_code,
                                 uint8_t attribute_val_length,
                                 uint8_t attribute_val[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_write_resp_cp0 *cp0 = (aci_gatt_write_resp_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->write_status = HTOB(write_status, 1);
  index_input += 1;
  cp0->error_code = HTOB(error_code, 1);
  index_input += 1;
  cp0->attribute_val_length = HTOB(attribute_val_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->attribute_val, (const void *) attribute_val, attribute_val_length * sizeof(uint8_t));
    index_input += attribute_val_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x126;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_allow_read(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_allow_read_cp0 *cp0 = (aci_gatt_allow_read_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x127;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_set_security_permission(uint16_t serv_handle,
                                              uint16_t attr_handle,
                                              uint8_t security_permissions)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_set_security_permission_cp0 *cp0 = (aci_gatt_set_security_permission_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->serv_handle = HTOB(serv_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->security_permissions = HTOB(security_permissions, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x128;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_set_desc_value(uint16_t serv_handle,
                                     uint16_t char_handle,
                                     uint16_t char_desc_handle,
                                     uint16_t val_offset,
                                     uint8_t char_desc_value_length,
                                     uint8_t char_desc_value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_set_desc_value_cp0 *cp0 = (aci_gatt_set_desc_value_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->serv_handle = HTOB(serv_handle, 2);
  index_input += 2;
  cp0->char_handle = HTOB(char_handle, 2);
  index_input += 2;
  cp0->char_desc_handle = HTOB(char_desc_handle, 2);
  index_input += 2;
  cp0->val_offset = HTOB(val_offset, 2);
  index_input += 2;
  cp0->char_desc_value_length = HTOB(char_desc_value_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->char_desc_value,
                   (const void *) char_desc_value,
                   char_desc_value_length * sizeof(uint8_t));
    index_input += char_desc_value_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x129;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_read_handle_value(uint16_t attr_handle,
                                        uint16_t offset,
                                        uint16_t value_length_requested,
                                        uint16_t *length,
                                        uint16_t *value_length,
                                        uint8_t value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_read_handle_value_cp0 *cp0 = (aci_gatt_read_handle_value_cp0 *)(cmd_buffer);
  aci_gatt_read_handle_value_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->offset = HTOB(offset, 2);
  index_input += 2;
  cp0->value_length_requested = HTOB(value_length_requested, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x12a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *length = BTOH(resp.length, 2);
  *value_length = BTOH(resp.value_length, 2);
  BLUENRG_MEMCPY((void *) value, (const void *) resp.value, *value_length * sizeof(uint8_t));
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_update_char_value_ext(uint16_t conn_handle_to_notify,
                                            uint16_t service_handle,
                                            uint16_t char_handle,
                                            uint8_t update_type,
                                            uint16_t char_length,
                                            uint16_t value_offset,
                                            uint8_t value_length,
                                            uint8_t value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_update_char_value_ext_cp0 *cp0 = (aci_gatt_update_char_value_ext_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->conn_handle_to_notify = HTOB(conn_handle_to_notify, 2);
  index_input += 2;
  cp0->service_handle = HTOB(service_handle, 2);
  index_input += 2;
  cp0->char_handle = HTOB(char_handle, 2);
  index_input += 2;
  cp0->update_type = HTOB(update_type, 1);
  index_input += 1;
  cp0->char_length = HTOB(char_length, 2);
  index_input += 2;
  cp0->value_offset = HTOB(value_offset, 2);
  index_input += 2;
  cp0->value_length = HTOB(value_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->value, (const void *) value, value_length * sizeof(uint8_t));
    index_input += value_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x12c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_deny_read(uint16_t connection_handle,
                                uint8_t error_code)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_deny_read_cp0 *cp0 = (aci_gatt_deny_read_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->error_code = HTOB(error_code, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x12d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gatt_set_access_permission(uint16_t serv_handle,
                                            uint16_t attr_handle,
                                            uint8_t access_permissions)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gatt_set_access_permission_cp0 *cp0 = (aci_gatt_set_access_permission_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->serv_handle = HTOB(serv_handle, 2);
  index_input += 2;
  cp0->attr_handle = HTOB(attr_handle, 2);
  index_input += 2;
  cp0->access_permissions = HTOB(access_permissions, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x12e;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
