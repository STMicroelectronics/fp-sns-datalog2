/**
  ******************************************************************************
  * @file    bluenrg1_gap_aci.c
  * @author  AMG - RF Application team
  * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode
  *          (gap_aci)
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
#include "ble_types.h"
#include "bluenrg1_gap_aci.h"
ble_status_t aci_gap_set_non_discoverable(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x081;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_limited_discoverable(uint8_t advertising_type,
                                              uint16_t advertising_interval_min,
                                              uint16_t advertising_interval_max,
                                              uint8_t own_address_type,
                                              uint8_t advertising_filter_policy,
                                              uint8_t local_name_length,
                                              uint8_t local_name[],
                                              uint8_t service_uuid_length,
                                              uint8_t service_uuid_list[],
                                              uint16_t slave_conn_interval_min,
                                              uint16_t slave_conn_interval_max)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  aci_gap_set_limited_discoverable_cp0 *cp0 = (aci_gap_set_limited_discoverable_cp0 *)(cmd_buffer);
  aci_gap_set_limited_discoverable_cp1 *cp1 =
    (aci_gap_set_limited_discoverable_cp1 *)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 +
                                             local_name_length * (sizeof(uint8_t)));
  aci_gap_set_limited_discoverable_cp2 *cp2 =
    (aci_gap_set_limited_discoverable_cp2 *)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 +
                                             local_name_length * (sizeof(uint8_t)) + 1 +
                                             service_uuid_length * (sizeof(uint8_t)));
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_type = HTOB(advertising_type, 1);
  index_input += 1;
  cp0->advertising_interval_min = HTOB(advertising_interval_min, 2);
  index_input += 2;
  cp0->advertising_interval_max = HTOB(advertising_interval_max, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->advertising_filter_policy = HTOB(advertising_filter_policy, 1);
  index_input += 1;
  cp0->local_name_length = HTOB(local_name_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->local_name, (const void *) local_name, local_name_length * sizeof(uint8_t));
    index_input += local_name_length * sizeof(uint8_t);
    {
      cp1->service_uuid_length = HTOB(service_uuid_length, 1);
    }
    index_input += 1;
    BLUENRG_MEMCPY((void *) &cp1->service_uuid_list, (const void *) service_uuid_list,
                   service_uuid_length * sizeof(uint8_t));
    index_input += service_uuid_length * sizeof(uint8_t);
    {
      cp2->slave_conn_interval_min = HTOB(slave_conn_interval_min, 2);
    }
    index_input += 2;
    {
      cp2->slave_conn_interval_max = HTOB(slave_conn_interval_max, 2);
    }
    index_input += 2;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x082;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_discoverable(uint8_t advertising_type,
                                      uint16_t advertising_interval_min,
                                      uint16_t advertising_interval_max,
                                      uint8_t own_address_type,
                                      uint8_t advertising_filter_policy,
                                      uint8_t local_name_length,
                                      uint8_t local_name[],
                                      uint8_t service_uuid_length,
                                      uint8_t service_uuid_list[],
                                      uint16_t slave_conn_interval_min,
                                      uint16_t slave_conn_interval_max)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  aci_gap_set_discoverable_cp0 *cp0 = (aci_gap_set_discoverable_cp0 *)(cmd_buffer);
  aci_gap_set_discoverable_cp1 *cp1 =
    (aci_gap_set_discoverable_cp1 *)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + local_name_length * (sizeof(uint8_t)));
  aci_gap_set_discoverable_cp2 *cp2 =
    (aci_gap_set_discoverable_cp2 *)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + local_name_length * (sizeof(uint8_t)) +
                                     1 + service_uuid_length * (sizeof(uint8_t)));
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_type = HTOB(advertising_type, 1);
  index_input += 1;
  cp0->advertising_interval_min = HTOB(advertising_interval_min, 2);
  index_input += 2;
  cp0->advertising_interval_max = HTOB(advertising_interval_max, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->advertising_filter_policy = HTOB(advertising_filter_policy, 1);
  index_input += 1;
  cp0->local_name_length = HTOB(local_name_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->local_name, (const void *) local_name, local_name_length * sizeof(uint8_t));
    index_input += local_name_length * sizeof(uint8_t);
    {
      cp1->service_uuid_length = HTOB(service_uuid_length, 1);
    }
    index_input += 1;
    BLUENRG_MEMCPY((void *) &cp1->service_uuid_list, (const void *) service_uuid_list,
                   service_uuid_length * sizeof(uint8_t));
    index_input += service_uuid_length * sizeof(uint8_t);
    {
      cp2->slave_conn_interval_min = HTOB(slave_conn_interval_min, 2);
    }
    index_input += 2;
    {
      cp2->slave_conn_interval_max = HTOB(slave_conn_interval_max, 2);
    }
    index_input += 2;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x083;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_direct_connectable(uint8_t own_address_type,
                                            uint8_t directed_advertising_type,
                                            uint8_t direct_address_type,
                                            uint8_t direct_address[6],
                                            uint16_t advertising_interval_min,
                                            uint16_t advertising_interval_max)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_set_direct_connectable_cp0 *cp0 = (aci_gap_set_direct_connectable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->directed_advertising_type = HTOB(directed_advertising_type, 1);
  index_input += 1;
  cp0->direct_address_type = HTOB(direct_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->direct_address, (const void *) direct_address, 6);
  index_input += 6;
  cp0->advertising_interval_min = HTOB(advertising_interval_min, 2);
  index_input += 2;
  cp0->advertising_interval_max = HTOB(advertising_interval_max, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x084;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_io_capability(uint8_t io_capability)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_set_io_capability_cp0 *cp0 = (aci_gap_set_io_capability_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->io_capability = HTOB(io_capability, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x085;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_authentication_requirement(uint8_t bonding_mode,
                                                    uint8_t mitm_mode,
                                                    uint8_t sc_support,
                                                    uint8_t key_press_notification_support,
                                                    uint8_t min_encryption_key_size,
                                                    uint8_t max_encryption_key_size,
                                                    uint8_t use_fixed_pin,
                                                    uint32_t fixed_pin,
                                                    uint8_t identity_address_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_set_authentication_requirement_cp0 *cp0 = (aci_gap_set_authentication_requirement_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->bonding_mode = HTOB(bonding_mode, 1);
  index_input += 1;
  cp0->mitm_mode = HTOB(mitm_mode, 1);
  index_input += 1;
  cp0->sc_support = HTOB(sc_support, 1);
  index_input += 1;
  cp0->key_press_notification_support = HTOB(key_press_notification_support, 1);
  index_input += 1;
  cp0->min_encryption_key_size = HTOB(min_encryption_key_size, 1);
  index_input += 1;
  cp0->max_encryption_key_size = HTOB(max_encryption_key_size, 1);
  index_input += 1;
  cp0->use_fixed_pin = HTOB(use_fixed_pin, 1);
  index_input += 1;
  cp0->fixed_pin = HTOB(fixed_pin, 4);
  index_input += 4;
  cp0->identity_address_type = HTOB(identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x086;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_authorization_requirement(uint16_t connection_handle,
                                                   uint8_t authorization_enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_set_authorization_requirement_cp0 *cp0 = (aci_gap_set_authorization_requirement_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->authorization_enable = HTOB(authorization_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x087;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_pass_key_resp(uint16_t connection_handle,
                                   uint32_t pass_key)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_pass_key_resp_cp0 *cp0 = (aci_gap_pass_key_resp_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->pass_key = HTOB(pass_key, 4);
  index_input += 4;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x088;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_authorization_resp(uint16_t connection_handle,
                                        uint8_t authorize)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_authorization_resp_cp0 *cp0 = (aci_gap_authorization_resp_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->authorize = HTOB(authorize, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x089;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_init(uint8_t role,
                          uint8_t privacy_enabled,
                          uint8_t device_name_char_len,
                          uint16_t *service_handle,
                          uint16_t *dev_name_char_handle,
                          uint16_t *appearance_char_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_init_cp0 *cp0 = (aci_gap_init_cp0 *)(cmd_buffer);
  aci_gap_init_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->role = HTOB(role, 1);
  index_input += 1;
  cp0->privacy_enabled = HTOB(privacy_enabled, 1);
  index_input += 1;
  cp0->device_name_char_len = HTOB(device_name_char_len, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x08a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *service_handle = BTOH(resp.service_handle, 2);
  *dev_name_char_handle = BTOH(resp.dev_name_char_handle, 2);
  *appearance_char_handle = BTOH(resp.appearance_char_handle, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_non_connectable(uint8_t advertising_event_type,
                                         uint8_t own_address_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_set_non_connectable_cp0 *cp0 = (aci_gap_set_non_connectable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_event_type = HTOB(advertising_event_type, 1);
  index_input += 1;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x08b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_undirected_connectable(uint16_t advertising_interval_min,
                                                uint16_t advertising_interval_max,
                                                uint8_t own_address_type,
                                                uint8_t adv_filter_policy)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_set_undirected_connectable_cp0 *cp0 = (aci_gap_set_undirected_connectable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_interval_min = HTOB(advertising_interval_min, 2);
  index_input += 2;
  cp0->advertising_interval_max = HTOB(advertising_interval_max, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->adv_filter_policy = HTOB(adv_filter_policy, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x08c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_slave_security_req(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_slave_security_req_cp0 *cp0 = (aci_gap_slave_security_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x08d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_update_adv_data(uint8_t adv_data_len,
                                     uint8_t adv_data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_update_adv_data_cp0 *cp0 = (aci_gap_update_adv_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->adv_data_len = HTOB(adv_data_len, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->adv_data, (const void *) adv_data, adv_data_len * sizeof(uint8_t));
    index_input += adv_data_len * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x08e;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_delete_ad_type(uint8_t ad_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_delete_ad_type_cp0 *cp0 = (aci_gap_delete_ad_type_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->ad_type = HTOB(ad_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x08f;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_get_security_level(uint16_t connection_handle,
                                        uint8_t *security_mode,
                                        uint8_t *security_level)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_get_security_level_cp0 *cp0 = (aci_gap_get_security_level_cp0 *)(cmd_buffer);
  aci_gap_get_security_level_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x090;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *security_mode = BTOH(resp.security_mode, 1);
  *security_level = BTOH(resp.security_level, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_event_mask(uint16_t gap_evt_mask)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_set_event_mask_cp0 *cp0 = (aci_gap_set_event_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->gap_evt_mask = HTOB(gap_evt_mask, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x091;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_configure_whitelist(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x092;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_terminate(uint16_t connection_handle,
                               uint8_t reason)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_terminate_cp0 *cp0 = (aci_gap_terminate_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->reason = HTOB(reason, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x093;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_clear_security_db(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x094;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_allow_rebond(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_allow_rebond_cp0 *cp0 = (aci_gap_allow_rebond_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x095;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_start_limited_discovery_proc(uint16_t le_scan_interval,
                                                  uint16_t le_scan_window,
                                                  uint8_t own_address_type,
                                                  uint8_t filter_duplicates)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_start_limited_discovery_proc_cp0 *cp0 = (aci_gap_start_limited_discovery_proc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->filter_duplicates = HTOB(filter_duplicates, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x096;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_start_general_discovery_proc(uint16_t le_scan_interval,
                                                  uint16_t le_scan_window,
                                                  uint8_t own_address_type,
                                                  uint8_t filter_duplicates)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_start_general_discovery_proc_cp0 *cp0 = (aci_gap_start_general_discovery_proc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->filter_duplicates = HTOB(filter_duplicates, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x097;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_start_name_discovery_proc(uint16_t le_scan_interval,
                                               uint16_t le_scan_window,
                                               uint8_t peer_address_type,
                                               uint8_t peer_address[6],
                                               uint8_t own_address_type,
                                               uint16_t conn_interval_min,
                                               uint16_t conn_interval_max,
                                               uint16_t conn_latency,
                                               uint16_t supervision_timeout,
                                               uint16_t minimum_ce_length,
                                               uint16_t maximum_ce_length)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_start_name_discovery_proc_cp0 *cp0 = (aci_gap_start_name_discovery_proc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x098;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_start_auto_connection_establish_proc(uint16_t le_scan_interval,
                                                          uint16_t le_scan_window,
                                                          uint8_t own_address_type,
                                                          uint16_t conn_interval_min,
                                                          uint16_t conn_interval_max,
                                                          uint16_t conn_latency,
                                                          uint16_t supervision_timeout,
                                                          uint16_t minimum_ce_length,
                                                          uint16_t maximum_ce_length,
                                                          uint8_t num_of_whitelist_entries,
                                                          whitelist_entry_t whitelist_entry[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_start_auto_connection_establish_proc_cp0 *cp0 =
    (aci_gap_start_auto_connection_establish_proc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  cp0->num_of_whitelist_entries = HTOB(num_of_whitelist_entries, 1);
  index_input += 1;
  /* var_len_data input */
  {
    for (uint8_t i = 0; i < num_of_whitelist_entries; i++)
    {
      cp0->whitelist_entry[i].peer_address_type = whitelist_entry[i].peer_address_type;
      BLUENRG_MEMCPY((void *) &cp0->whitelist_entry[i].peer_address,
                     (const void *) &whitelist_entry[i].peer_address, 6);
    }
    index_input += num_of_whitelist_entries * 7;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x099;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_start_general_connection_establish_proc(uint8_t le_scan_type,
                                                             uint16_t le_scan_interval,
                                                             uint16_t le_scan_window,
                                                             uint8_t own_address_type,
                                                             uint8_t scanning_filter_policy,
                                                             uint8_t filter_duplicates)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_start_general_connection_establish_proc_cp0 *cp0 =
    (aci_gap_start_general_connection_establish_proc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_type = HTOB(le_scan_type, 1);
  index_input += 1;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->scanning_filter_policy = HTOB(scanning_filter_policy, 1);
  index_input += 1;
  cp0->filter_duplicates = HTOB(filter_duplicates, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09a;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_start_selective_connection_establish_proc(uint8_t le_scan_type,
                                                               uint16_t le_scan_interval,
                                                               uint16_t le_scan_window,
                                                               uint8_t own_address_type,
                                                               uint8_t scanning_filter_policy,
                                                               uint8_t filter_duplicates,
                                                               uint8_t num_of_whitelist_entries,
                                                               whitelist_entry_t whitelist_entry[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_start_selective_connection_establish_proc_cp0 *cp0 =
    (aci_gap_start_selective_connection_establish_proc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_type = HTOB(le_scan_type, 1);
  index_input += 1;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->scanning_filter_policy = HTOB(scanning_filter_policy, 1);
  index_input += 1;
  cp0->filter_duplicates = HTOB(filter_duplicates, 1);
  index_input += 1;
  cp0->num_of_whitelist_entries = HTOB(num_of_whitelist_entries, 1);
  index_input += 1;
  /* var_len_data input */
  {
    for (uint8_t i = 0; i < num_of_whitelist_entries; i++)
    {
      cp0->whitelist_entry[i].peer_address_type = whitelist_entry[i].peer_address_type;
      BLUENRG_MEMCPY((void *) &cp0->whitelist_entry[i].peer_address,
                     (const void *) &whitelist_entry[i].peer_address, 6);
    }
    index_input += num_of_whitelist_entries * 7;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09b;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_create_connection(uint16_t le_scan_interval,
                                       uint16_t le_scan_window,
                                       uint8_t peer_address_type,
                                       uint8_t peer_address[6],
                                       uint8_t own_address_type,
                                       uint16_t conn_interval_min,
                                       uint16_t conn_interval_max,
                                       uint16_t conn_latency,
                                       uint16_t supervision_timeout,
                                       uint16_t minimum_ce_length,
                                       uint16_t maximum_ce_length)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_create_connection_cp0 *cp0 = (aci_gap_create_connection_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09c;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_terminate_gap_proc(uint8_t procedure_code)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_terminate_gap_proc_cp0 *cp0 = (aci_gap_terminate_gap_proc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->procedure_code = HTOB(procedure_code, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_start_connection_update(uint16_t connection_handle,
                                             uint16_t conn_interval_min,
                                             uint16_t conn_interval_max,
                                             uint16_t conn_latency,
                                             uint16_t supervision_timeout,
                                             uint16_t minimum_ce_length,
                                             uint16_t maximum_ce_length)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_start_connection_update_cp0 *cp0 = (aci_gap_start_connection_update_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09e;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_send_pairing_req(uint16_t connection_handle,
                                      uint8_t force_rebond)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_send_pairing_req_cp0 *cp0 = (aci_gap_send_pairing_req_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->force_rebond = HTOB(force_rebond, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x09f;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_resolve_private_addr(uint8_t address[6],
                                          uint8_t actual_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_resolve_private_addr_cp0 *cp0 = (aci_gap_resolve_private_addr_cp0 *)(cmd_buffer);
  aci_gap_resolve_private_addr_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->address, (const void *) address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a0;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) actual_address, (const void *) resp.actual_address, 6);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_broadcast_mode(uint16_t advertising_interval_min,
                                        uint16_t advertising_interval_max,
                                        uint8_t advertising_type,
                                        uint8_t own_address_type,
                                        uint8_t adv_data_length,
                                        uint8_t adv_data[],
                                        uint8_t num_of_whitelist_entries,
                                        whitelist_entry_t whitelist_entry[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[300];
  aci_gap_set_broadcast_mode_cp0 *cp0 = (aci_gap_set_broadcast_mode_cp0 *)(cmd_buffer);
  aci_gap_set_broadcast_mode_cp1 *cp1 =
    (aci_gap_set_broadcast_mode_cp1 *)(cmd_buffer + 2 + 2 + 1 + 1 + 1 + adv_data_length * (sizeof(uint8_t)));
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_interval_min = HTOB(advertising_interval_min, 2);
  index_input += 2;
  cp0->advertising_interval_max = HTOB(advertising_interval_max, 2);
  index_input += 2;
  cp0->advertising_type = HTOB(advertising_type, 1);
  index_input += 1;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->adv_data_length = HTOB(adv_data_length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->adv_data, (const void *) adv_data, adv_data_length * sizeof(uint8_t));
    index_input += adv_data_length * sizeof(uint8_t);
    {
      cp1->num_of_whitelist_entries = HTOB(num_of_whitelist_entries, 1);
    }
    index_input += 1;
    for (uint8_t i = 0; i < num_of_whitelist_entries; i++)
    {
      cp1->whitelist_entry[i].peer_address_type = whitelist_entry[i].peer_address_type;
      BLUENRG_MEMCPY((void *) &cp1->whitelist_entry[i].peer_address,
                     (const void *) &whitelist_entry[i].peer_address, 6);
    }
    index_input += num_of_whitelist_entries * 7;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a1;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_start_observation_proc(uint16_t le_scan_interval,
                                            uint16_t le_scan_window,
                                            uint8_t le_scan_type,
                                            uint8_t own_address_type,
                                            uint8_t filter_duplicates,
                                            uint8_t scanning_filter_policy)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_start_observation_proc_cp0 *cp0 = (aci_gap_start_observation_proc_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->le_scan_type = HTOB(le_scan_type, 1);
  index_input += 1;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->filter_duplicates = HTOB(filter_duplicates, 1);
  index_input += 1;
  cp0->scanning_filter_policy = HTOB(scanning_filter_policy, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a2;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_get_bonded_devices(uint8_t *num_of_addresses,
                                        bonded_device_entry_t bonded_device_entry[])
{
  struct hci_request rq_t;
  aci_gap_get_bonded_devices_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a3;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *num_of_addresses = BTOH(resp.num_of_addresses, 1);
  BLUENRG_MEMCPY((void *) bonded_device_entry, (const void *) resp.bonded_device_entry,
                 *num_of_addresses * sizeof(bonded_device_entry_t));
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_is_device_bonded(uint8_t peer_address_type,
                                      uint8_t peer_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_is_device_bonded_cp0 *cp0 = (aci_gap_is_device_bonded_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a4;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_numeric_comparison_value_confirm_yesno(uint16_t connection_handle,
                                                            uint8_t confirm_yes_no)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_numeric_comparison_value_confirm_yesno_cp0 *cp0 =
    (aci_gap_numeric_comparison_value_confirm_yesno_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->confirm_yes_no = HTOB(confirm_yes_no, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a5;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_passkey_input(uint16_t connection_handle,
                                   uint8_t input_type)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_passkey_input_cp0 *cp0 = (aci_gap_passkey_input_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->input_type = HTOB(input_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a6;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_get_oob_data(uint8_t oob_data_type,
                                  uint8_t *address_type,
                                  uint8_t address[6],
                                  uint8_t *oob_data_len,
                                  uint8_t oob_data[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_get_oob_data_cp0 *cp0 = (aci_gap_get_oob_data_cp0 *)(cmd_buffer);
  aci_gap_get_oob_data_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->oob_data_type = HTOB(oob_data_type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a7;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *address_type = BTOH(resp.address_type, 1);
  BLUENRG_MEMCPY((void *) address, (const void *) resp.address, 6);
  *oob_data_len = BTOH(resp.oob_data_len, 1);
  BLUENRG_MEMCPY((void *) oob_data, (const void *) resp.oob_data, 16);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_set_oob_data(uint8_t device_type,
                                  uint8_t address_type,
                                  uint8_t address[6],
                                  uint8_t oob_data_type,
                                  uint8_t oob_data_len,
                                  uint8_t oob_data[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_set_oob_data_cp0 *cp0 = (aci_gap_set_oob_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->device_type = HTOB(device_type, 1);
  index_input += 1;
  cp0->address_type = HTOB(address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->address, (const void *) address, 6);
  index_input += 6;
  cp0->oob_data_type = HTOB(oob_data_type, 1);
  index_input += 1;
  cp0->oob_data_len = HTOB(oob_data_len, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->oob_data, (const void *) oob_data, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a8;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_add_devices_to_resolving_list(uint8_t num_of_resolving_list_entries,
                                                   whitelist_identity_entry_t whitelist_identity_entry[],
                                                   uint8_t clear_resolving_list)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_add_devices_to_resolving_list_cp0 *cp0 = (aci_gap_add_devices_to_resolving_list_cp0 *)(cmd_buffer);
  aci_gap_add_devices_to_resolving_list_cp1 *cp1 =
    (aci_gap_add_devices_to_resolving_list_cp1 *)(cmd_buffer + 1 +
                                                  num_of_resolving_list_entries *
                                                  (sizeof(whitelist_identity_entry_t)));
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->num_of_resolving_list_entries = HTOB(num_of_resolving_list_entries, 1);
  index_input += 1;
  /* var_len_data input */
  {
    for (uint8_t i = 0; i < num_of_resolving_list_entries; i++)
    {
      cp0->whitelist_identity_entry[i].peer_identity_address_type =
        whitelist_identity_entry[i].peer_identity_address_type;
      BLUENRG_MEMCPY((void *) &cp0->whitelist_identity_entry[i].peer_identity_address,
                     (const void *) &whitelist_identity_entry[i].peer_identity_address, 6);
    }
    index_input += num_of_resolving_list_entries * 7;
    {
      cp1->clear_resolving_list = HTOB(clear_resolving_list, 1);
    }
    index_input += 1;
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0a9;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_gap_remove_bonded_device(uint8_t peer_identity_address_type,
                                          uint8_t peer_identity_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_gap_remove_bonded_device_cp0 *cp0 = (aci_gap_remove_bonded_device_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x0aa;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
