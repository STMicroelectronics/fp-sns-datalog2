/**
  ******************************************************************************
  * @file    bluenrg1_hal_aci.c
  * @author  AMG - RF Application team
  * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode
  *          (hal_aci)
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
#include "ble_types.h"
#include "bluenrg1_hal_aci.h"
ble_status_t aci_hal_get_fw_build_number(uint16_t *build_number)
{
  struct hci_request rq_t;
  aci_hal_get_fw_build_number_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x000;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *build_number = BTOH(resp.build_number, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_get_firmware_details(uint8_t *dtm_version_major,
                                          uint8_t *dtm_version_minor,
                                          uint8_t *dtm_version_patch,
                                          uint8_t *dtm_variant,
                                          uint16_t *dtm_Build_Number,
                                          uint8_t *btle_Stack_version_major,
                                          uint8_t *btle_Stack_version_minor,
                                          uint8_t *btle_Stack_version_patch,
                                          uint8_t *btle_Stack_development,
                                          uint16_t *btle_Stack_variant,
                                          uint16_t *btle_Stack_Build_Number)
{
  struct hci_request rq_t;
  aci_hal_get_firmware_details_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x001;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *dtm_version_major = BTOH(resp.dtm_version_major, 1);
  *dtm_version_minor = BTOH(resp.dtm_version_minor, 1);
  *dtm_version_patch = BTOH(resp.dtm_version_patch, 1);
  *dtm_variant = BTOH(resp.dtm_variant, 1);
  *dtm_Build_Number = BTOH(resp.dtm_Build_Number, 2);
  *btle_Stack_version_major = BTOH(resp.btle_Stack_version_major, 1);
  *btle_Stack_version_minor = BTOH(resp.btle_Stack_version_minor, 1);
  *btle_Stack_version_patch = BTOH(resp.btle_Stack_version_patch, 1);
  *btle_Stack_development = BTOH(resp.btle_Stack_development, 1);
  *btle_Stack_variant = BTOH(resp.btle_Stack_variant, 2);
  *btle_Stack_Build_Number = BTOH(resp.btle_Stack_Build_Number, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_write_config_data(uint8_t offset,
                                       uint8_t length,
                                       uint8_t value[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_write_config_data_cp0 *cp0 = (aci_hal_write_config_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->offset = HTOB(offset, 1);
  index_input += 1;
  cp0->length = HTOB(length, 1);
  index_input += 1;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->value, (const void *) value, length * sizeof(uint8_t));
    index_input += length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x00c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_read_config_data(uint8_t offset,
                                      uint8_t *data_length,
                                      uint8_t data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_read_config_data_cp0 *cp0 = (aci_hal_read_config_data_cp0 *)(cmd_buffer);
  aci_hal_read_config_data_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->offset = HTOB(offset, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x00d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *data_length = BTOH(resp.data_length, 1);
  BLUENRG_MEMCPY((void *) data, (const void *) resp.data, *data_length * sizeof(uint8_t));
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_set_tx_power_level(uint8_t en_high_power,
                                        uint8_t pa_level)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_set_tx_power_level_cp0 *cp0 = (aci_hal_set_tx_power_level_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->en_high_power = HTOB(en_high_power, 1);
  index_input += 1;
  cp0->pa_level = HTOB(pa_level, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x00f;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_le_tx_test_packet_number(uint32_t *number_of_packets)
{
  struct hci_request rq_t;
  aci_hal_le_tx_test_packet_number_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x014;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *number_of_packets = BTOH(resp.number_of_packets, 4);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_tone_start(uint8_t rf_channel,
                                uint8_t offset)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_tone_start_cp0 *cp0 = (aci_hal_tone_start_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->rf_channel = HTOB(rf_channel, 1);
  index_input += 1;
  cp0->offset = HTOB(offset, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x015;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_tone_stop(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x016;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_get_link_status(uint8_t link_status[8],
                                     uint16_t link_connection_handle[16 / 2])
{
  struct hci_request rq_t;
  aci_hal_get_link_status_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x017;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) link_status, (const void *) resp.link_status, 8);
  BLUENRG_MEMCPY((void *) link_connection_handle, (const void *) resp.link_connection_handle, 16);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_set_radio_activity_mask(uint16_t radio_activity_mask)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_set_radio_activity_mask_cp0 *cp0 = (aci_hal_set_radio_activity_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->radio_activity_mask = HTOB(radio_activity_mask, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x018;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_get_anchor_period(uint32_t *anchor_period,
                                       uint32_t *max_free_slot)
{
  struct hci_request rq_t;
  aci_hal_get_anchor_period_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x019;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *anchor_period = BTOH(resp.anchor_period, 4);
  *max_free_slot = BTOH(resp.max_free_slot, 4);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_set_event_mask(uint32_t event_mask)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_set_event_mask_cp0 *cp0 = (aci_hal_set_event_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->event_mask = HTOB(event_mask, 4);
  index_input += 4;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x01a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_updater_start(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x020;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_updater_reboot(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x021;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_get_updater_version(uint8_t *version)
{
  struct hci_request rq_t;
  aci_hal_get_updater_version_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x022;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *version = BTOH(resp.version, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_get_updater_bufsize(uint8_t *buffer_size)
{
  struct hci_request rq_t;
  aci_hal_get_updater_bufsize_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x023;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *buffer_size = BTOH(resp.buffer_size, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_updater_erase_blue_flag(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x024;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_updater_reset_blue_flag(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x025;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_updater_erase_sector(uint32_t address)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_updater_erase_sector_cp0 *cp0 = (aci_hal_updater_erase_sector_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->address = HTOB(address, 4);
  index_input += 4;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x026;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_updater_prog_data_blk(uint32_t address,
                                           uint16_t data_length,
                                           uint8_t data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_updater_prog_data_blk_cp0 *cp0 = (aci_hal_updater_prog_data_blk_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->address = HTOB(address, 4);
  index_input += 4;
  cp0->data_length = HTOB(data_length, 2);
  index_input += 2;
  /* var_len_data input */
  {
    BLUENRG_MEMCPY((void *) &cp0->data, (const void *) data, data_length * sizeof(uint8_t));
    index_input += data_length * sizeof(uint8_t);
  }
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x027;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_updater_read_data_blk(uint32_t address,
                                           uint16_t data_length,
                                           uint8_t data[])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_updater_read_data_blk_cp0 *cp0 = (aci_hal_updater_read_data_blk_cp0 *)(cmd_buffer);
  aci_hal_updater_read_data_blk_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->address = HTOB(address, 4);
  index_input += 4;
  cp0->data_length = HTOB(data_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x028;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) data, (const void *) resp.data, (rq_t.rlen - 1)*sizeof(uint8_t));
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_updater_calc_crc(uint32_t address,
                                      uint8_t num_of_sectors,
                                      uint32_t *crc)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_updater_calc_crc_cp0 *cp0 = (aci_hal_updater_calc_crc_cp0 *)(cmd_buffer);
  aci_hal_updater_calc_crc_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->address = HTOB(address, 4);
  index_input += 4;
  cp0->num_of_sectors = HTOB(num_of_sectors, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x029;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *crc = BTOH(resp.crc, 4);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_updater_hw_version(uint8_t *hw_version)
{
  struct hci_request rq_t;
  aci_hal_updater_hw_version_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x02a;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *hw_version = BTOH(resp.hw_version, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t aci_hal_transmitter_test_packets(uint8_t tx_frequency,
                                              uint8_t length_of_test_data,
                                              uint8_t packet_payload,
                                              uint16_t number_of_packets)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  aci_hal_transmitter_test_packets_cp0 *cp0 = (aci_hal_transmitter_test_packets_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->tx_frequency = HTOB(tx_frequency, 1);
  index_input += 1;
  cp0->length_of_test_data = HTOB(length_of_test_data, 1);
  index_input += 1;
  cp0->packet_payload = HTOB(packet_payload, 1);
  index_input += 1;
  cp0->number_of_packets = HTOB(number_of_packets, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x3f;
  rq_t.ocf = 0x02b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
