/**
  ******************************************************************************
  * @file    bluenrg1_hci_le.c
  * @author  AMG - RF Application team
  * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode
  *          (hci_le)
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
#include "ble_types.h"
#include "bluenrg1_hci_le.h"
ble_status_t hci_disconnect(uint16_t connection_handle,
                            uint8_t reason)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_disconnect_cp0 *cp0 = (hci_disconnect_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->reason = HTOB(reason, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x01;
  rq_t.ocf = 0x006;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_remote_version_information(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_read_remote_version_information_cp0 *cp0 = (hci_read_remote_version_information_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x01;
  rq_t.ocf = 0x01d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_set_event_mask(uint8_t event_mask[8])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_set_event_mask_cp0 *cp0 = (hci_set_event_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->event_mask, (const void *) event_mask, 8);
  index_input += 8;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x03;
  rq_t.ocf = 0x001;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_reset(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x03;
  rq_t.ocf = 0x003;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_transmit_power_level(uint16_t connection_handle,
                                           uint8_t type,
                                           int8_t *transmit_power_level)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_read_transmit_power_level_cp0 *cp0 = (hci_read_transmit_power_level_cp0 *)(cmd_buffer);
  hci_read_transmit_power_level_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->type = HTOB(type, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x03;
  rq_t.ocf = 0x02d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *transmit_power_level = BTOH(resp.transmit_power_level, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_local_version_information(uint8_t *hci_version,
                                                uint16_t *hci_revision,
                                                uint8_t *lmp_pal_version,
                                                uint16_t *manufacturer_name,
                                                uint16_t *lmp_pal_subversion)
{
  struct hci_request rq_t;
  hci_read_local_version_information_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x04;
  rq_t.ocf = 0x001;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *hci_version = BTOH(resp.hci_version, 1);
  *hci_revision = BTOH(resp.hci_revision, 2);
  *lmp_pal_version = BTOH(resp.lmp_pal_version, 1);
  *manufacturer_name = BTOH(resp.manufacturer_name, 2);
  *lmp_pal_subversion = BTOH(resp.lmp_pal_subversion, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_local_supported_commands(uint8_t supported_commands[64])
{
  struct hci_request rq_t;
  hci_read_local_supported_commands_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x04;
  rq_t.ocf = 0x002;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) supported_commands, (const void *) resp.supported_commands, 64);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_local_supported_features(uint8_t lmp_features[8])
{
  struct hci_request rq_t;
  hci_read_local_supported_features_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x04;
  rq_t.ocf = 0x003;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) lmp_features, (const void *) resp.lmp_features, 8);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_bd_addr(uint8_t bd_addr[6])
{
  struct hci_request rq_t;
  hci_read_bd_addr_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x04;
  rq_t.ocf = 0x009;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) bd_addr, (const void *) resp.bd_addr, 6);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_read_rssi(uint16_t connection_handle,
                           int8_t *rssi)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_read_rssi_cp0 *cp0 = (hci_read_rssi_cp0 *)(cmd_buffer);
  hci_read_rssi_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x05;
  rq_t.ocf = 0x005;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *rssi = BTOH(resp.rssi, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_event_mask(uint8_t le_event_mask[8])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_event_mask_cp0 *cp0 = (hci_le_set_event_mask_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->le_event_mask, (const void *) le_event_mask, 8);
  index_input += 8;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x001;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_buffer_size(uint16_t *hc_le_acl_data_packet_length,
                                     uint8_t *hc_total_num_le_acl_data_packets)
{
  struct hci_request rq_t;
  hci_le_read_buffer_size_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x002;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *hc_le_acl_data_packet_length = BTOH(resp.hc_le_acl_data_packet_length, 2);
  *hc_total_num_le_acl_data_packets = BTOH(resp.hc_total_num_le_acl_data_packets, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_local_supported_features(uint8_t le_features[8])
{
  struct hci_request rq_t;
  hci_le_read_local_supported_features_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x003;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) le_features, (const void *) resp.le_features, 8);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_random_address(uint8_t random_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_random_address_cp0 *cp0 = (hci_le_set_random_address_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->random_address, (const void *) random_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x005;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_advertising_parameters(uint16_t advertising_interval_min,
                                               uint16_t advertising_interval_max,
                                               uint8_t advertising_type,
                                               uint8_t own_address_type,
                                               uint8_t peer_address_type,
                                               uint8_t peer_address[6],
                                               uint8_t advertising_channel_map,
                                               uint8_t advertising_filter_policy)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_advertising_parameters_cp0 *cp0 = (hci_le_set_advertising_parameters_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_interval_min = HTOB(advertising_interval_min, 2);
  index_input += 2;
  cp0->advertising_interval_max = HTOB(advertising_interval_max, 2);
  index_input += 2;
  cp0->advertising_type = HTOB(advertising_type, 1);
  index_input += 1;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  cp0->advertising_channel_map = HTOB(advertising_channel_map, 1);
  index_input += 1;
  cp0->advertising_filter_policy = HTOB(advertising_filter_policy, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x006;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_advertising_channel_tx_power(int8_t *transmit_power_level)
{
  struct hci_request rq_t;
  hci_le_read_advertising_channel_tx_power_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x007;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *transmit_power_level = BTOH(resp.transmit_power_level, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_advertising_data(uint8_t advertising_data_length,
                                         uint8_t advertising_data[31])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_advertising_data_cp0 *cp0 = (hci_le_set_advertising_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_data_length = HTOB(advertising_data_length, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->advertising_data, (const void *) advertising_data, 31);
  index_input += 31;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x008;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_scan_response_data(uint8_t scan_response_data_length,
                                           uint8_t scan_response_data[31])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_scan_response_data_cp0 *cp0 = (hci_le_set_scan_response_data_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->scan_response_data_length = HTOB(scan_response_data_length, 1);
  index_input += 1;
  /* FIX: check on scan_response_data introduced to fix issue in projects for Cortex-M33 */
  if (scan_response_data != NULL)
  {
    BLUENRG_MEMCPY((void *) &cp0->scan_response_data, (const void *) scan_response_data, 31);
  }
  index_input += 31;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x009;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_advertise_enable(uint8_t advertising_enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_advertise_enable_cp0 *cp0 = (hci_le_set_advertise_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->advertising_enable = HTOB(advertising_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_scan_parameters(uint8_t le_scan_type,
                                        uint16_t le_scan_interval,
                                        uint16_t le_scan_window,
                                        uint8_t own_address_type,
                                        uint8_t scanning_filter_policy)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_scan_parameters_cp0 *cp0 = (hci_le_set_scan_parameters_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_type = HTOB(le_scan_type, 1);
  index_input += 1;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->scanning_filter_policy = HTOB(scanning_filter_policy, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_scan_enable(uint8_t le_scan_enable,
                                    uint8_t filter_duplicates)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_scan_enable_cp0 *cp0 = (hci_le_set_scan_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_enable = HTOB(le_scan_enable, 1);
  index_input += 1;
  cp0->filter_duplicates = HTOB(filter_duplicates, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_create_connection(uint16_t le_scan_interval,
                                      uint16_t le_scan_window,
                                      uint8_t initiator_filter_policy,
                                      uint8_t peer_address_type,
                                      uint8_t peer_address[6],
                                      uint8_t own_address_type,
                                      uint16_t conn_interval_min,
                                      uint16_t conn_interval_max,
                                      uint16_t conn_latency,
                                      uint16_t supervision_timeout,
                                      uint16_t minimum_ce_length,
                                      uint16_t maximum_ce_length)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_create_connection_cp0 *cp0 = (hci_le_create_connection_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->le_scan_interval = HTOB(le_scan_interval, 2);
  index_input += 2;
  cp0->le_scan_window = HTOB(le_scan_window, 2);
  index_input += 2;
  cp0->initiator_filter_policy = HTOB(initiator_filter_policy, 1);
  index_input += 1;
  cp0->peer_address_type = HTOB(peer_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_address, (const void *) peer_address, 6);
  index_input += 6;
  cp0->own_address_type = HTOB(own_address_type, 1);
  index_input += 1;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00d;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_create_connection_cancel(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00e;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_white_list_size(uint8_t *white_list_size)
{
  struct hci_request rq_t;
  hci_le_read_white_list_size_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x00f;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *white_list_size = BTOH(resp.white_list_size, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_clear_white_list(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x010;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_add_device_to_white_list(uint8_t address_type,
                                             uint8_t address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_add_device_to_white_list_cp0 *cp0 = (hci_le_add_device_to_white_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->address_type = HTOB(address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->address, (const void *) address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x011;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_remove_device_from_white_list(uint8_t address_type,
                                                  uint8_t address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_remove_device_from_white_list_cp0 *cp0 = (hci_le_remove_device_from_white_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->address_type = HTOB(address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->address, (const void *) address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x012;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_connection_update(uint16_t connection_handle,
                                      uint16_t conn_interval_min,
                                      uint16_t conn_interval_max,
                                      uint16_t conn_latency,
                                      uint16_t supervision_timeout,
                                      uint16_t minimum_ce_length,
                                      uint16_t maximum_ce_length)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_connection_update_cp0 *cp0 = (hci_le_connection_update_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->conn_interval_min = HTOB(conn_interval_min, 2);
  index_input += 2;
  cp0->conn_interval_max = HTOB(conn_interval_max, 2);
  index_input += 2;
  cp0->conn_latency = HTOB(conn_latency, 2);
  index_input += 2;
  cp0->supervision_timeout = HTOB(supervision_timeout, 2);
  index_input += 2;
  cp0->minimum_ce_length = HTOB(minimum_ce_length, 2);
  index_input += 2;
  cp0->maximum_ce_length = HTOB(maximum_ce_length, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x013;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_host_channel_classification(uint8_t le_channel_map[5])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_host_channel_classification_cp0 *cp0 = (hci_le_set_host_channel_classification_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->le_channel_map, (const void *) le_channel_map, 5);
  index_input += 5;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x014;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_channel_map(uint16_t connection_handle,
                                     uint8_t le_channel_map[5])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_channel_map_cp0 *cp0 = (hci_le_read_channel_map_cp0 *)(cmd_buffer);
  hci_le_read_channel_map_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x015;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) le_channel_map, (const void *) resp.le_channel_map, 5);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_remote_used_features(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_remote_used_features_cp0 *cp0 = (hci_le_read_remote_used_features_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x016;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_encrypt(uint8_t key[16],
                            uint8_t plaintext_data[16],
                            uint8_t encrypted_data[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_encrypt_cp0 *cp0 = (hci_le_encrypt_cp0 *)(cmd_buffer);
  hci_le_encrypt_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->key, (const void *) key, 16);
  index_input += 16;
  BLUENRG_MEMCPY((void *) &cp0->plaintext_data, (const void *) plaintext_data, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x017;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) encrypted_data, (const void *) resp.encrypted_data, 16);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_rand(uint8_t random_number[8])
{
  struct hci_request rq_t;
  hci_le_rand_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x018;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) random_number, (const void *) resp.random_number, 8);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_start_encryption(uint16_t connection_handle,
                                     uint8_t random_number[8],
                                     uint16_t encrypted_diversifier,
                                     uint8_t long_term_key[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_start_encryption_cp0 *cp0 = (hci_le_start_encryption_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMCPY((void *) &cp0->random_number, (const void *) random_number, 8);
  index_input += 8;
  cp0->encrypted_diversifier = HTOB(encrypted_diversifier, 2);
  index_input += 2;
  BLUENRG_MEMCPY((void *) &cp0->long_term_key, (const void *) long_term_key, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x019;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_long_term_key_request_reply(uint16_t connection_handle,
                                                uint8_t long_term_key[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_long_term_key_request_reply_cp0 *cp0 = (hci_le_long_term_key_request_reply_cp0 *)(cmd_buffer);
  hci_le_long_term_key_request_reply_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMCPY((void *) &cp0->long_term_key, (const void *) long_term_key, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01a;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_long_term_key_requested_negative_reply(uint16_t connection_handle)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_long_term_key_requested_negative_reply_cp0 *cp0 =
    (hci_le_long_term_key_requested_negative_reply_cp0 *)(cmd_buffer);
  hci_le_long_term_key_requested_negative_reply_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_supported_states(uint8_t le_states[8])
{
  struct hci_request rq_t;
  hci_le_read_supported_states_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01c;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) le_states, (const void *) resp.le_states, 8);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_receiver_test(uint8_t rx_frequency)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_receiver_test_cp0 *cp0 = (hci_le_receiver_test_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->rx_frequency = HTOB(rx_frequency, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_transmitter_test(uint8_t tx_frequency,
                                     uint8_t length_of_test_data,
                                     uint8_t packet_payload)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_transmitter_test_cp0 *cp0 = (hci_le_transmitter_test_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->tx_frequency = HTOB(tx_frequency, 1);
  index_input += 1;
  cp0->length_of_test_data = HTOB(length_of_test_data, 1);
  index_input += 1;
  cp0->packet_payload = HTOB(packet_payload, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01e;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_test_end(uint16_t *number_of_packets)
{
  struct hci_request rq_t;
  hci_le_test_end_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x01f;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *number_of_packets = BTOH(resp.number_of_packets, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_data_length(uint16_t connection_handle,
                                    uint16_t tx_octets,
                                    uint16_t tx_time)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_data_length_cp0 *cp0 = (hci_le_set_data_length_cp0 *)(cmd_buffer);
  hci_le_set_data_length_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->connection_handle = HTOB(connection_handle, 2);
  index_input += 2;
  cp0->tx_octets = HTOB(tx_octets, 2);
  index_input += 2;
  cp0->tx_time = HTOB(tx_time, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x022;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_suggested_default_data_length(uint16_t *suggested_max_tx_octets,
                                                       uint16_t *suggested_max_tx_time)
{
  struct hci_request rq_t;
  hci_le_read_suggested_default_data_length_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x023;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *suggested_max_tx_octets = BTOH(resp.suggested_max_tx_octets, 2);
  *suggested_max_tx_time = BTOH(resp.suggested_max_tx_time, 2);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_write_suggested_default_data_length(uint16_t suggested_max_tx_octets,
                                                        uint16_t suggested_max_tx_time)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_write_suggested_default_data_length_cp0 *cp0 = (hci_le_write_suggested_default_data_length_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->suggested_max_tx_octets = HTOB(suggested_max_tx_octets, 2);
  index_input += 2;
  cp0->suggested_max_tx_time = HTOB(suggested_max_tx_time, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x024;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_local_p256_public_key(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x025;
  rq_t.event = 0x0F;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_generate_dhkey(uint8_t remote_p256_public_key[64])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_generate_dhkey_cp0 *cp0 = (hci_le_generate_dhkey_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  BLUENRG_MEMCPY((void *) &cp0->remote_p256_public_key, (const void *) remote_p256_public_key, 64);
  index_input += 64;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x026;
  rq_t.event = 0x0F;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_add_device_to_resolving_list(uint8_t peer_identity_address_type,
                                                 uint8_t peer_identity_address[6],
                                                 uint8_t peer_irk[16],
                                                 uint8_t local_irk[16])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_add_device_to_resolving_list_cp0 *cp0 = (hci_le_add_device_to_resolving_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMCPY((void *) &cp0->peer_irk, (const void *) peer_irk, 16);
  index_input += 16;
  BLUENRG_MEMCPY((void *) &cp0->local_irk, (const void *) local_irk, 16);
  index_input += 16;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x027;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_remove_device_from_resolving_list(uint8_t peer_identity_address_type,
                                                      uint8_t peer_identity_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_remove_device_from_resolving_list_cp0 *cp0 = (hci_le_remove_device_from_resolving_list_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x028;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_clear_resolving_list(void)
{
  struct hci_request rq_t;
  ble_status_t status = 0;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x029;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_resolving_list_size(uint8_t *resolving_list_size)
{
  struct hci_request rq_t;
  hci_le_read_resolving_list_size_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02a;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *resolving_list_size = BTOH(resp.resolving_list_size, 1);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_peer_resolvable_address(uint8_t peer_identity_address_type,
                                                 uint8_t peer_identity_address[6],
                                                 uint8_t peer_resolvable_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_peer_resolvable_address_cp0 *cp0 = (hci_le_read_peer_resolvable_address_cp0 *)(cmd_buffer);
  hci_le_read_peer_resolvable_address_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02b;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) peer_resolvable_address, (const void *) resp.peer_resolvable_address, 6);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_read_local_resolvable_address(uint8_t peer_identity_address_type,
                                                  uint8_t peer_identity_address[6],
                                                  uint8_t local_resolvable_address[6])
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_read_local_resolvable_address_cp0 *cp0 = (hci_le_read_local_resolvable_address_cp0 *)(cmd_buffer);
  hci_le_read_local_resolvable_address_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  uint8_t index_input = 0;
  cp0->peer_identity_address_type = HTOB(peer_identity_address_type, 1);
  index_input += 1;
  BLUENRG_MEMCPY((void *) &cp0->peer_identity_address, (const void *) peer_identity_address, 6);
  index_input += 6;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02c;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  BLUENRG_MEMCPY((void *) local_resolvable_address, (const void *) resp.local_resolvable_address, 6);
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_address_resolution_enable(uint8_t address_resolution_enable)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_address_resolution_enable_cp0 *cp0 = (hci_le_set_address_resolution_enable_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->address_resolution_enable = HTOB(address_resolution_enable, 1);
  index_input += 1;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02d;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
ble_status_t hci_le_set_resolvable_private_address_timeout(uint16_t rpa_timeout)
{
  struct hci_request rq_t;
  uint8_t cmd_buffer[258];
  hci_le_set_resolvable_private_address_timeout_cp0 *cp0 =
    (hci_le_set_resolvable_private_address_timeout_cp0 *)(cmd_buffer);
  ble_status_t status = 0;
  uint8_t index_input = 0;
  cp0->rpa_timeout = HTOB(rpa_timeout, 2);
  index_input += 2;
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02e;
  rq_t.cparam = cmd_buffer;
  rq_t.command_len = index_input;
  rq_t.rparam = &status;
  rq_t.rlen = 1;
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (status)
  {
    return status;
  }
  return BLE_STATUS_SUCCESS;
}

ble_status_t hci_le_read_maximum_data_length(uint16_t *supportedMaxTxOctets,
                                             uint16_t *supportedMaxTxTime,
                                             uint16_t *supportedMaxRxOctets,
                                             uint16_t *supportedMaxRxTime)
{
  struct hci_request rq_t;
  hci_le_read_maximum_data_length_rp0 resp;
  BLUENRG_MEMSET(&resp, 0, sizeof(resp));
  BLUENRG_MEMSET(&rq_t, 0, sizeof(rq_t));
  rq_t.ogf = 0x08;
  rq_t.ocf = 0x02f;
  rq_t.rparam = &resp;
  rq_t.rlen = sizeof(resp);
  if (hci_send_req(&rq_t, FALSE) < 0)
  {
    return BLE_STATUS_TIMEOUT;
  }
  if (resp.status)
  {
    return resp.status;
  }
  *supportedMaxTxOctets = BTOH(resp.supportedMaxTxOctets, 2);
  *supportedMaxTxTime = BTOH(resp.supportedMaxTxTime, 2);
  *supportedMaxRxOctets = BTOH(resp.supportedMaxRxOctets, 2);
  *supportedMaxRxTime = BTOH(resp.supportedMaxRxTime, 2);
  return BLE_STATUS_SUCCESS;
}
