/**
  ******************************************************************************
  * @file    bluenrg1_gap_aci.h
  * @author  AMG - RF Application team
  * @brief   Header file for external uC - BlueNRG-x in network coprocessor mode
  *          (gap_aci)
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
#ifndef _BLUENRG1_GAP_ACI_H_
#define _BLUENRG1_GAP_ACI_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "bluenrg1_types.h"
/** @addtogroup Middlewares
  *  @{
  */

/** @defgroup ST
  *  @{
  */

/** @defgroup SimpleBlueNRG_HCI
  *  @{
  */

/**
  *@addtogroup GAP GAP
  *@brief GAP layer.
  *@{
  */

/**
  *@defgroup GAP_Functions GAP functions
  *@brief API for GAP layer.
  *@{
  */

/** Documentation for C struct whitelist_entry_t */
typedef struct whitelist_entry_t_s
{
  /** Address type.
    *  Values:
    *  - 0x00: Public Device Address
    *  - 0x01: Random Device Address
    */
  uint8_t peer_address_type;
  /** Public Device Address or Random Device Address of the device to be added to the
    *  white list.
    */
  uint8_t peer_address[6];
} whitelist_entry_t;
/** Documentation for C struct bonded_device_entry_t */
typedef struct bonded_device_entry_t_s
{
  /** Address type.
    *  Values:
    *  - 0x00: Public Device Address
    *  - 0x01: Random Device Address
    */
  uint8_t address_type;
  /** Public Device Address or Random Device Address of the device to be added to the
    *  white list.
    */
  uint8_t address[6];
} bonded_device_entry_t;
/** Documentation for C struct whitelist_identity_entry_t */
typedef struct whitelist_identity_entry_t_s
{
  /** Identity address type.
    *  Values:
    *  - 0x00: Public Identity Address
    *  - 0x01: Random (static) Identity Address
    */
  uint8_t peer_identity_address_type;
  /** Public or Random (static) Identity address of the peer device
   */
  uint8_t peer_identity_address[6];
} whitelist_identity_entry_t;
/**
  * @brief Put the device in non-discoverable mode. This command disables the LL
  *        advertising.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_non_discoverable(void);
/**
  * @brief Put the device in limited discoverable mode (as defined in Bluetooth
  *        Specification v.4.1, Vol. 3, Part C, section 9.2.3). The device will
  *        be discoverable for maximum period of TGAP (lim_adv_timeout) = 180
  *        seconds (from errata). The advertising can be disabled at any time by
  *        issuing @ref aci_gap_set_non_discoverable command. The
  *        Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both
  *        are set to 0, the GAP will use default values for adv intervals for
  *        limited discoverable mode (250 ms and 500 ms respectively). To allow a
  *        fast connection, the host can set local_name, service_uuid_list,
  *        slave_conn_interval_min and slave_conn_interval_max. If provided,
  *        these data will be  inserted into the advertising packet payload as AD
  *        data. These parameters are optional in this command. These values can
  *        be set in advertised data using GAP_Update_Adv_Data command
  *        separately. The total size of data in advertising packet cannot exceed
  *        31 bytes. With this command, the BLE Stack will also add automatically
  *        the following standard AD types: - AD Flags - Power Level When
  *        advertising timeout happens (i.e. limited discovery period has
  *        elapsed), controller generates @ref aci_gap_limited_discoverable_event
  *        event.
  * @param advertising_type Advertising type. advertising_type type cannot be any
  *        of GAP_ADV_HIGH_DC_DIRECT_IND or GAP_ADV_HIGH_DC_DIRECT_IND.
  *        Values:
  *        - 0x00: ADV_IND (Connectable undirected advertising)
  *        - 0x01: ADV_DIRECT_IND (Connectable directed advertising)
  *        - 0x02: ADV_SCAN_IND (Scannable undirected advertising)
  *        - 0x03: ADV_NONCONN_IND (Non connectable undirected advertising)
  * @param advertising_interval_min Minimum advertising interval for undirected
  *        and low duty cycle directed advertising. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @param advertising_interval_max Maximum advertising interval. Time = N *
  *        0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param advertising_filter_policy Advertising filter policy: not applicable
  *        (the value of advertising_filter_policy parameter is not used inside
  *        the Stack)
  * @param local_name_length Length of the local_name field in octets. If length
  *        is set to 0x00, local_name parameter is not used.
  * @param local_name Local name of the device. First byte must be 0x08 for
  *        Shortened Local Name  or 0x09 for Complete Local Name. No NULL
  *        character at the end.
  * @param service_uuid_length Length of the Service Uuid List in octets. If
  *        there is no service to be advertised, set this field to 0x00.
  * @param service_uuid_list This is the list of the UUIDs as defined in Volume
  *        3, Section 11 of GAP Specification. First byte is the AD Type. See
  *        also Supplement to the Bluetooth Core specification.
  * @param slave_conn_interval_min Minimum value for slave connection interval
  *        suggested by the Peripheral. If slave_conn_interval_min and
  *        slave_conn_interval_max are not 0x0000, Slave Connection Interval
  *        Range AD structure will be added in advertising data. Connection
  *        interval is defined in the following manner: connIntervalmin =
  *        slave_conn_interval_min x 1.25ms.
  *        Values:
  *        - 0x0000 (NaN)
  *        - 0xFFFF (NaN) : No specific minimum
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param slave_conn_interval_max Slave connection interval maximum value
  *        suggested by Peripheral. If slave_conn_interval_min and
  *        slave_conn_interval_max are not 0x0000, Slave Connection Interval
  *        Range AD structure will be added in advertising data. Connection
  *        interval is defined in the following manner: connIntervalmax =
  *        slave_conn_interval_max x 1.25ms
  *        Values:
  *        - 0x0000 (NaN)
  *        - 0xFFFF (NaN) : No specific maximum
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_limited_discoverable(uint8_t advertising_type,
                                              uint16_t advertising_interval_min,
                                              uint16_t advertising_interval_max,
                                              uint8_t own_address_type,
                                              uint8_t advertising_filter_policy,
                                              uint8_t local_name_length,
                                              uint8_t local_name[],
                                              uint8_t service_uuid_length,
                                              uint8_t service_uuid_list[],
                                              uint16_t slave_conn_interval_min,
                                              uint16_t slave_conn_interval_max);
/**
  * @brief Put the device in general discoverable mode (as defined in Bluetooth
  *        Specification v.4.1, Vol. 3, Part C, section 9.2.4). The device will
  *        be discoverable until the host issues  the @ref
  *        aci_gap_set_non_discoverable command. The Adv_Interval_Min and
  *        Adv_Interval_Max parameters are optional. If both are set to 0, the
  *        GAP uses the default values for adv intervals for general discoverable
  *        mode. When using connectable undirected advertising events: -
  *        Adv_Interval_Min = 30 ms  - Adv_Interval_Max = 60 ms When using non-
  *        connectable advertising events or scannable undirected advertising
  *        events: - Adv_Interval_Min = 100 ms  - Adv_Interval_Max = 150 ms  Host
  *        can set the Local Name, a Service UUID list and the Slave Connection
  *        Interval Range. If provided, these data will be inserted into the
  *        advertising packet payload as AD data. These parameters are optional
  *        in this command. These values can be also set using
  *        aci_gap_update_adv_data() separately. The total size of data in
  *        advertising packet cannot exceed 31 bytes. With this command, the BLE
  *        Stack will also add automatically the following standard AD types: -
  *        AD Flags - TX Power Level
  * @param advertising_type Advertising type. advertising_type type cannot be any
  *        of GAP_ADV_HIGH_DC_DIRECT_IND or GAP_ADV_HIGH_DC_DIRECT_IND.
  *        Values:
  *        - 0x00: ADV_IND (Connectable undirected advertising)
  *        - 0x01: ADV_DIRECT_IND (Connectable directed advertising)
  *        - 0x02: ADV_SCAN_IND (Scannable undirected advertising)
  *        - 0x03: ADV_NONCONN_IND (Non connectable undirected advertising)
  * @param advertising_interval_min Minimum advertising interval for undirected
  *        and low duty cycle directed advertising. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @param advertising_interval_max Maximum advertising interval. Time = N *
  *        0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param advertising_filter_policy Advertising filter policy: not applicable
  *        (the value of advertising_filter_policy parameter is not used inside
  *        the Stack)
  * @param local_name_length Length of the local_name field in octets. If length
  *        is set to 0x00, local_name parameter is not used.
  * @param local_name Local name of the device. First byte must be 0x08 for
  *        Shortened Local Name  or 0x09 for Complete Local Name. No NULL
  *        character at the end.
  * @param service_uuid_length Length of the Service Uuid List in octets. If
  *        there is no service to be advertised, set this field to 0x00.
  * @param service_uuid_list This is the list of the UUIDs as defined in Volume
  *        3, Section 11 of GAP Specification. First byte is the AD Type. See
  *        also Supplement to the Bluetooth Core specification.
  * @param slave_conn_interval_min Minimum value for slave connection interval
  *        suggested by the Peripheral. If slave_conn_interval_min and
  *        slave_conn_interval_max are not 0x0000, Slave Connection Interval
  *        Range AD structure will be added in advertising data. Connection
  *        interval is defined in the following manner: connIntervalmin =
  *        slave_conn_interval_min x 1.25ms.
  *        Values:
  *        - 0x0000 (NaN)
  *        - 0xFFFF (NaN) : No specific minimum
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param slave_conn_interval_max Slave connection interval maximum value
  *        suggested by Peripheral. If slave_conn_interval_min and
  *        slave_conn_interval_max are not 0x0000, Slave Connection Interval
  *        Range AD structure will be added in advertising data. Connection
  *        interval is defined in the following manner: connIntervalmax =
  *        slave_conn_interval_max x 1.25ms
  *        Values:
  *        - 0x0000 (NaN)
  *        - 0xFFFF (NaN) : No specific maximum
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_discoverable(uint8_t advertising_type,
                                      uint16_t advertising_interval_min,
                                      uint16_t advertising_interval_max,
                                      uint8_t own_address_type,
                                      uint8_t advertising_filter_policy,
                                      uint8_t local_name_length,
                                      uint8_t local_name[],
                                      uint8_t service_uuid_length,
                                      uint8_t service_uuid_list[],
                                      uint16_t slave_conn_interval_min,
                                      uint16_t slave_conn_interval_max);
/**
  * @brief      Set the device in direct connectable mode (as defined in
  *        Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.3.3). Device
  *        uses direct connectable mode to advertise using High Duty cycle
  *        advertisement events or Low Duty cycle advertisement events and the
  *        address as either what is specified in the Own Address Type parameter.
  *        The command specifies the type of the advertising used. If the privacy
  *        is enabled, the Type parameter in reconnection address is used for
  *        advertising, otherwise the address of the type specified in
  *        OwnAddrType is used. The device will be in directed connectable mode
  *        only for 1.28 seconds. If no connection is established within this
  *        duration, the device enters non discoverable mode and advertising will
  *        have to be again enabled explicitly. The controller generates a @ref
  *        hci_le_connection_complete_event event with the status set to 0x3C
  *        (Directed Advertising Timeout) if the connection was not established
  *        and 0x00 if the connection was successfully established. If Host
  *        privacy (i.e. privacy 1.1) is enabled this command returns
  *        BLE_STATUS_INVALID_PARAMS.
  * @param own_address_type Own address type:  - 0x00: Public Device Address
  *        (only if privacy is disabled)  - 0x01: Random Device Address (only if
  *        privacy is disabled)  - 0x02: Resolvable Private Address (only if
  *        privacy is enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  * @param directed_advertising_type Type of directed advertising.
  *        Values:
  *        - 0x01: High Duty Cycle Directed Advertising
  *        - 0x04: Low Duty Cycle Directed Advertising
  * @param direct_address_type Peer Address type.
  *        Values:
  *        - 0x00: Public Device Address or Public Identity Address
  *        - 0x01: Random Device Address or Random (static) Identity Address
  * @param direct_address Initiator Bluetooth address
  * @param advertising_interval_min Minimum advertising interval for undirected
  *        and low duty cycle directed advertising. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @param advertising_interval_max Maximum advertising interval. Time = N *
  *        0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_direct_connectable(uint8_t own_address_type,
                                            uint8_t directed_advertising_type,
                                            uint8_t direct_address_type,
                                            uint8_t direct_address[6],
                                            uint16_t advertising_interval_min,
                                            uint16_t advertising_interval_max);
/**
  * @brief Set the IO capabilities of the device. This command has to be given
  *        only when the device is not in a connected state.
  * @param io_capability IO capability of the device.
  *        Values:
  *        - 0x00: IO_CAP_DISPLAY_ONLY
  *        - 0x01: IO_CAP_DISPLAY_YES_NO
  *        - 0x02: IO_CAP_KEYBOARD_ONLY
  *        - 0x03: IO_CAP_NO_INPUT_NO_OUTPUT
  *        - 0x04: IO_CAP_KEYBOARD_DISPLAY
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_io_capability(uint8_t io_capability);
/**
  * @brief Set the authentication requirements for the device. This command has
  *        to be given only when the device is not in a connected state.
  * @param bonding_mode Bonding mode. Only if bonding is enabled (0x01), the
  *        bonding information is stored in flash
  *        Values:
  *        - 0x00: NO_BONDING
  *        - 0x01: BONDING
  * @param mitm_mode MITM mode.
  *        Values:
  *        - 0x00: MITM_PROTECTION_NOT_REQUIRED
  *        - 0x01: MITM_PROTECTION_REQUIRED
  * @param sc_support LE Secure connections support. - 0x00: Secure Connections
  *        Pairing not supported - 0x01: Secure Connections Pairing supported but
  *        optional - 0x02: Secure Connections Pairing supported and mandatory
  *        (SC Only Mode)
  *        Values:
  *        - 0x00: SC_IS_NOT_SUPPORTED
  *        - 0x01: SC_IS_SUPPORTED
  *        - 0x02: SC_IS_MANDATORY
  * @param key_press_notification_support Keypress notification support
  *        Values:
  *        - 0x00: KEYPRESS_IS_NOT_SUPPORTED
  *        - 0x01: KEYPRESS_IS_SUPPORTED
  * @param min_encryption_key_size Minimum encryption key size to be used during
  *        pairing
  * @param max_encryption_key_size Maximum encryption key size to be used during
  *        pairing
  * @param use_fixed_pin Use or not fixed pin. If set to 0x00, then during the
  *        pairing process the application will not be requested for a pin
  *        (fixed_pin will be used). If set to 0x01, then during pairing process
  *        if a passkey is required the application will be notified
  *        Values:
  *        - 0x00: USE_FIXED_PIN_FOR_PAIRING
  *        - 0x01: DONOT_USE_FIXED_PIN_FOR_PAIRING
  * @param fixed_pin Fixed pin to be used during pairing if MIMT protection is
  *        enabled. Any random value between 0 to 999999
  *        Values:
  *        - 0 ... 999999
  * @param identity_address_type Identity address type.
  *        Values:
  *        - 0x00: Public Identity Address
  *        - 0x01: Random (static) Identity Address
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_authentication_requirement(uint8_t bonding_mode,
                                                    uint8_t mitm_mode,
                                                    uint8_t sc_support,
                                                    uint8_t key_press_notification_support,
                                                    uint8_t min_encryption_key_size,
                                                    uint8_t max_encryption_key_size,
                                                    uint8_t use_fixed_pin,
                                                    uint32_t fixed_pin,
                                                    uint8_t identity_address_type);
/**
  * @brief Set the authorization requirements of the device. This command has to
  *        be given when connected to a device if authorization is required to
  *        access services which require authorization.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param authorization_enable Enable the authorization in the device and when a
  *        remote device tries to read/write a characteristic with authorization
  *        requirements, the stack will send back an error response with
  *        "Insufficient authorization" error code. After pairing is complete a
  *        ACI_GAP_AUTHORIZATION_REQ_EVENT will be sent to the Host.
  *        Values:
  *        - 0x00: AUTHORIZATION_NOT_REQUIRED
  *        - 0x01: AUTHORIZATION_REQUIRED
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_authorization_requirement(uint16_t connection_handle,
                                                   uint8_t authorization_enable);
/**
  * @brief This command should be send by the host in response to @ref
  *        aci_gap_pass_key_req_event event. The command parameter contains the
  *        pass key which will be used during the pairing process.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param pass_key Pass key that will be used during the pairing process.  Must
  *        be a six-digit decimal number.
  *        Values:
  *        - 0 ... 999999
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_pass_key_resp(uint16_t connection_handle,
                                   uint32_t pass_key);
/**
  * @brief Authorize a device to access attributes. This command should be send
  *        by the host in response to @ref aci_gap_authorization_req_event event.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param authorize Authorization response.
  *        Values:
  *        - 0x01: Authorize
  *        - 0x02: Reject
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_authorization_resp(uint16_t connection_handle,
                                        uint8_t authorize);
/**
  * @brief Initialize the GAP layer. Register the GAP service with the GATT. All
  *        the standard GAP characteristics will also be added: - Device Name -
  *        Appearance - Peripheral Preferred Connection Parameters (peripheral
  *        role only)  WARNING: A section of the Flash memory (pointed by
  *        stored_device_id_data_p) is used by this procedure. When this section
  *        is empty, data are written inside. This normally happens once during
  *        the lifetime of the device, when the command is executed for the first
  *        time (or every time it is called after that section has been erased).
  *        Do not power off the device while this function is writing into Flash
  *        memory. If the functions returns FLASH_WRITE_FAILED, it means that the
  *        flash area pointed by stored_device_id_data_p is corrupted (probably
  *        due to a power loss during the first call to aci_gap_init()). To fix
  *        the problem, that flash area has to be erased, so that the
  *        aci_gap_init() can reinitialize it correctly.
  * @param role Bitmap of allowed roles.
  *        Flags:
  *        - 0x01: Peripheral
  *        - 0x02: Broadcaster
  *        - 0x04: Central
  *        - 0x08: Observer
  * @param privacy_enabled Specify if privacy is enabled or not and which one .
  *        Values:
  *        - 0x00: Privacy disabled
  *        - 0x01: Privacy host enabled
  *        - 0x02: Privacy controller enabled
  * @param device_name_char_len Length of the device name characteristic
  *        Values:
  *        - 0 ... 248
  * @param[out] service_handle Handle of the GAP service
  * @param[out] dev_name_char_handle Device Name Characteristic handle
  * @param[out] appearance_char_handle Appearance Characteristic handle
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_init(uint8_t role,
                          uint8_t privacy_enabled,
                          uint8_t device_name_char_len,
                          uint16_t *service_handle,
                          uint16_t *dev_name_char_handle,
                          uint16_t *appearance_char_handle);
/**
  * @brief Put the device into non connectable mode. This mode does not support
  *        connection. The privacy setting done in the @ref aci_gap_init command
  *        plays a role in deciding the valid  parameters for this command.
  *        Advertiser filter policy is internally set to 0x00
  * @param advertising_event_type Advertising type.
  *        Values:
  *        - 0x02: ADV_SCAN_IND (Scannable undirected advertising)
  *        - 0x03: ADV_NONCONN_IND (Non connectable undirected advertising)
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_non_connectable(uint8_t advertising_event_type,
                                         uint8_t own_address_type);
/**
  * @brief Put the device into undirected connectable mode. If privacy is enabled
  *        in the device, a resolvable private address is generated and used as
  *        the  advertiser's address. If not, the address of the type specified
  *        in own_addr_type is used for advertising.
  * @param advertising_interval_min Minimum advertising interval for undirected
  *        and low duty cycle directed advertising. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @param advertising_interval_max Maximum advertising interval. Time = N *
  *        0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if controller privacy is enabled
  *        or if Host privacy (i.e. privacy 1.1) is enabled)  - 0x03: Non
  *        Resolvable Private Address (it is allowed only if Host privacy (i.e.
  *        privacy 1.1) is enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param adv_filter_policy Advertising filter policy. - 0x00: Allow Scan
  *        Request from Any, Allow Connect Request from Any - 0x03: Allow Scan
  *        Request from White List Only, Allow Connect Request from White List
  *        Only
  *        Values:
  *        - 0x00: NO_WHITE_LIST_USE
  *        - 0x03: WHITE_LIST_FOR_ALL
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_undirected_connectable(uint16_t advertising_interval_min,
                                                uint16_t advertising_interval_max,
                                                uint8_t own_address_type,
                                                uint8_t adv_filter_policy);
/**
  * @brief Send a slave security request to the master. This command has to be
  *        issued to notify the master of the security requirements of the slave.
  *        The master may encrypt the link, initiate the pairing procedure, or
  *        reject the request.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_slave_security_req(uint16_t connection_handle);
/**
  * @brief This command can be used to update the advertising data for a
  *        particular AD type. If the AD type specified does not exist, then it
  *        is added to the advertising data. If the overall advertising data
  *        length is more than 31 octets after the update, then the command is
  *        rejected and the old data is retained.
  * @param adv_data_len Length of adv_data in octets
  * @param adv_data Advertising data used by the device while advertising.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_update_adv_data(uint8_t adv_data_len,
                                     uint8_t adv_data[]);
/**
  * @brief This command can be used to delete the specified AD type from the
  *        advertisement data if present.
  * @param ad_type One of the AD types like in Bluetooth specification (see volume
  *        3, Part C, 11.1)
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_delete_ad_type(uint8_t ad_type);
/**
  * @brief This command can be used to get the current security settings of the
  *        device.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param[out] security_mode Security mode.
  *             Values:
  *             - 0x01: Security Mode 1
  *             - 0x02: Security Mode 2
  * @param[out] security_level Security Level.
  *             Values:
  *             - 0x01: Security Level 1
  *             - 0x02: Security Level 2
  *             - 0x03: Security Level 3
  *             - 0x04: Security Level 4
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_get_security_level(uint16_t connection_handle,
                                        uint8_t *security_mode,
                                        uint8_t *security_level);
/**
  * @brief It allows masking events from the GAP. The default configuration is
  *        all the events masked.
  * @param gap_evt_mask GAP event mask. Default: 0xFFFF.
  *        Flags:
  *        - 0x0000: No events
  *        - 0x0001: ACI_GAP_LIMITED_DISCOVERABLE_EVENT
  *        - 0x0002: ACI_GAP_PAIRING_COMPLETE_EVENT
  *        - 0x0004: ACI_GAP_PASS_KEY_REQ_EVENT
  *        - 0x0008: ACI_GAP_AUTHORIZATION_REQ_EVENT
  *        - 0x0010: ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT
  *        - 0x0020: ACI_GAP_BOND_LOST_EVENT
  *        - 0x0080: ACI_GAP_PROC_COMPLETE_EVENT
  *        - 0x0100: ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT
  *        - 0x0200: ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT
  *        - 0x0400: ACI_L2CAP_PROC_TIMEOUT_EVENT
  *        - 0x0800: ACI_GAP_ADDR_NOT_RESOLVED_EVENT
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_event_mask(uint16_t gap_evt_mask);
/**
  * @brief Add addresses of bonded devices into the controller's whitelist. The
  *        command will return an error if there are no devices in the database
  *        or if it was   unable to add the device into the whitelist.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_configure_whitelist(void);
/**
  * @brief Command the controller to terminate the connection. A @ref
  *        hci_disconnection_complete_event event will be generated when the link
  *        is disconnected. It is important to leave an 100 ms blank window
  *        before sending any new command (including system hardware reset),
  *        since immediately after @ref hci_disconnection_complete_event event,
  *        system could save important information in non volatile memory.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param reason The reason for ending the connection.
  *        Values:
  *        - 0x05: Authentication Failure
  *        - 0x13: Remote User Terminated Connection
  *        - 0x14: Remote Device Terminated Connection due to Low Resources
  *        - 0x15: Remote Device Terminated Connection due to Power Off
  *        - 0x1A: Unsupported Remote Feature
  *        - 0x3B: Unacceptable Connection Parameters
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_terminate(uint16_t connection_handle,
                               uint8_t reason);
/**
  * @brief Clear the security database. All the devices in the security database
  *        will be removed.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_clear_security_db(void);
/**
  * @brief Allows the security manager to complete the pairing procedure and re-
  *        bond with the master. This command should be given by the application
  *        when it receives the ACI_GAP_BOND_LOST_EVENT if it wants the re-
  *        bonding to happen successfully. If this command is not given on
  *        receiving the event, the bonding procedure will timeout.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_allow_rebond(uint16_t connection_handle);
/**
  * @brief Start the limited discovery procedure. The controller is commanded to
  *        start active scanning. When this procedure is started, only the
  *        devices in limited discoverable mode are returned to the upper layers.
  *        The procedure is terminated when either the upper layers issue a
  *        command to terminate  the procedure by issuing the command @ref
  *        aci_gap_terminate_gap_proc with the procedure  code set to 0x01 or a
  *        timeout happens. When the procedure is terminated due to any of the
  *        above  reasons, @ref aci_gap_proc_complete_event event is returned
  *        with the procedure code set to 0x01. The device found when the
  *        procedure is ongoing is returned to the upper layers through the event
  *        @ref hci_le_advertising_report_event.
  * @param le_scan_interval This is defined as the time interval from when the
  *        Controller started its last LE scan until it begins the subsequent LE
  *        scan. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param le_scan_window The duration of the LE scan. le_scan_window shall be
  *        less than or equal to le_scan_interval. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param filter_duplicates Enable/disable duplicate filtering.
  *        Values:
  *        - 0x00: Duplicate filtering disabled
  *        - 0x01: Duplicate filtering enabled
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_limited_discovery_proc(uint16_t le_scan_interval,
                                                  uint16_t le_scan_window,
                                                  uint8_t own_address_type,
                                                  uint8_t filter_duplicates);
/**
  * @brief Start the general discovery procedure. The controller is commanded to
  *        start active scanning. The procedure is terminated when  either the
  *        upper layers issue a command to terminate the procedure by issuing the
  *        command @ref aci_gap_terminate_gap_proc with the procedure code set to
  *        0x02 or a timeout happens. When the procedure is terminated due to any
  *        of the above reasons, @ref aci_gap_proc_complete_event event is
  *        returned with the procedure code set to 0x02. The device found when
  *        the procedure is ongoing is returned to @ref
  *        hci_le_advertising_report_event.
  * @param le_scan_interval This is defined as the time interval from when the
  *        Controller started its last LE scan until it begins the subsequent LE
  *        scan. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param le_scan_window The duration of the LE scan. le_scan_window shall be
  *        less than or equal to le_scan_interval. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param filter_duplicates Enable/disable duplicate filtering.
  *        Values:
  *        - 0x00: Duplicate filtering disabled
  *        - 0x01: Duplicate filtering enabled
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_general_discovery_proc(uint16_t le_scan_interval,
                                                  uint16_t le_scan_window,
                                                  uint8_t own_address_type,
                                                  uint8_t filter_duplicates);
/**
  * @brief Start the name discovery procedure. A LE_Create_Connection call will
  *        be made to the controller by GAP with the initiator filter policy set
  *        to "ignore whitelist and process connectable advertising packets only
  *        for the specified device". Once a connection is established, GATT
  *        procedure is started to read the device name characteristic. When the
  *        read is completed (successfully or unsuccessfully), a @ref
  *        aci_gap_proc_complete_event event is given to the upper layer. The
  *        event also contains the name of the device if the device name was read
  *        successfully.
  * @param le_scan_interval This is defined as the time interval from when the
  *        Controller started its last LE scan until it begins the subsequent LE
  *        scan. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param le_scan_window The duration of the LE scan. le_scan_window shall be
  *        less than or equal to le_scan_interval. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param peer_address_type Address type.
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  * @param peer_address Public Device Address, Random Device Address, Public
  *        Identity Address or Random (static) Identity Address of the
  *        advertising device.
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param conn_interval_min Minimum value for the connection event interval.
  *        This shall be less than or equal to conn_interval_max. Time = N * 1.25
  *        msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_interval_max Maximum value for the connection event interval.
  *        This shall be greater than or equal to conn_interval_min. Time = N *
  *        1.25 msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param supervision_timeout Supervision timeout for the LE Link. It shall be a
  *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
  *        connInterval * 2. Time = N * 10 msec.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @param minimum_ce_length Information parameter about the minimum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @param maximum_ce_length Information parameter about the maximum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_name_discovery_proc(uint16_t le_scan_interval,
                                               uint16_t le_scan_window,
                                               uint8_t peer_address_type,
                                               uint8_t peer_address[6],
                                               uint8_t own_address_type,
                                               uint16_t conn_interval_min,
                                               uint16_t conn_interval_max,
                                               uint16_t conn_latency,
                                               uint16_t supervision_timeout,
                                               uint16_t minimum_ce_length,
                                               uint16_t maximum_ce_length);
/**
  * @brief Start the auto connection establishment procedure. The devices
  *        specified are added to the white list of the controller and a
  *        LE_Create_Connection call will be made to the controller by GAP with
  *        the initiator filter policy set to "use whitelist to determine which
  *        advertiser to connect to". When a command is issued to terminate the
  *        procedure by upper layer, a LE_Create_Connection_Cancel call will be
  *        made to the controller by GAP. The procedure is terminated when either
  *        a connection is successfully established with one of the specified
  *        devices in the white list or the procedure is explicitly terminated by
  *        issuing the command @ref aci_gap_terminate_gap_proc with the procedure
  *        code set to 0x08. A @ref aci_gap_proc_complete_event event is returned
  *        with the procedure code set to 0x08. If controller privacy is enabled
  *        and the peer device (advertiser) is in the resolving list then  the
  *        link layer will generate a RPA, if it is not then the RPA/NRPA
  *        generated by the Host will be used.
  * @param le_scan_interval This is defined as the time interval from when the
  *        Controller started its last LE scan until it begins the subsequent LE
  *        scan. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param le_scan_window The duration of the LE scan. le_scan_window shall be
  *        less than or equal to le_scan_interval. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param conn_interval_min Minimum value for the connection event interval.
  *        This shall be less than or equal to conn_interval_max. Time = N * 1.25
  *        msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_interval_max Maximum value for the connection event interval.
  *        This shall be greater than or equal to conn_interval_min. Time = N *
  *        1.25 msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param supervision_timeout Supervision timeout for the LE Link. It shall be a
  *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
  *        connInterval * 2. Time = N * 10 msec.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @param minimum_ce_length Information parameter about the minimum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @param maximum_ce_length Information parameter about the maximum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @param num_of_whitelist_entries Number of devices that have to be added to
  *        the whitelist.
  *        Values:
  *        - 0x00 ... 0xFF
  * @param whitelist_entry See @ref whitelist_entry_t
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_auto_connection_establish_proc(uint16_t le_scan_interval,
                                                          uint16_t le_scan_window,
                                                          uint8_t own_address_type,
                                                          uint16_t conn_interval_min,
                                                          uint16_t conn_interval_max,
                                                          uint16_t conn_latency,
                                                          uint16_t supervision_timeout,
                                                          uint16_t minimum_ce_length,
                                                          uint16_t maximum_ce_length,
                                                          uint8_t num_of_whitelist_entries,
                                                          whitelist_entry_t whitelist_entry[]);
/**
  * @brief Start a general connection establishment procedure. The host enables
  *        scanning in the controller with the scanner filter policy set to
  *        "accept all advertising packets" and from the scanning results, all
  *        the devices are sent to the upper layer using the event
  *        LE_Advertising_Report. The upper layer then has to select one of the
  *        devices to which it wants to connect by issuing the command @ref
  *        aci_gap_create_connection. If privacy is enabled, then either a
  *        private resolvable address or a non resolvable address, based on the
  *        address type specified in the command is set as the scanner address
  *        but the gap create connection always uses a private resolvable address
  *        if the general connection establishment procedure is active. The
  *        procedure is terminated when a connection is established or the upper
  *        layer terminates the procedure by issuing the command @ref
  *        aci_gap_terminate_gap_proc with the procedure code set to 0x10. On
  *        completion of the procedure a @ref aci_gap_proc_complete_event event
  *        is generated with the procedure code set to 0x10. If controller
  *        privacy is enabled and the peer device (advertiser) is in the
  *        resolving list then the link layer will generate a RPA, if it is not
  *        then the RPA/NRPA generated by the Host will be used.
  * @param le_scan_type Passive or active scanning. With active scanning SCAN_REQ
  *        packets are sent.
  *        Values:
  *        - 0x00: Passive Scanning
  *        - 0x01: Active scanning
  * @param le_scan_interval This is defined as the time interval from when the
  *        Controller started its last LE scan until it begins the subsequent LE
  *        scan. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param le_scan_window The duration of the LE scan. le_scan_window shall be
  *        less than or equal to le_scan_interval. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param scanning_filter_policy Scanning filter policy:  - 0x00 Accept all
  *        advertisement packets.Directed advertising packets which are not
  *        addressed for this device shall be ignored.  - 0x01 Ignore
  *        advertisement packets from devices not in the White List Only.Directed
  *        advertising packets which are not addressed for this device shall be
  *        ignored.  - 0x02 Accept all undirected advertisement packets (it is
  *        allowed only if controller privacy or host privacy is
  *        enabled).Directed advertisement packets where initiator address is a
  *        RPA and Directed advertisement packets addressed to this device shall
  *        be accepted.  - 0x03 Accept all undirected advertisement packets from
  *        devices that are in the White List.Directed advertisement packets
  *        where initiator address is RPA and Directed advertisement packets
  *        addressed to this device shall be accepted.  - NOTE: if controller
  *        privacy is enabled scanning_filter_policy can only assume values 0x00
  *        or 0x02; if Host privacy is enabled scanning_filter_policy can only
  *        assume value 0x00.
  *        Values:
  *        - 0x00: Accept all
  *        - 0x01: Ignore devices not in the White List
  *        - 0x02: Accept all (use resolving list)
  *        - 0x03: Ignore devices not in the White List (use resolving list)
  * @param filter_duplicates Enable/disable duplicate filtering.
  *        Values:
  *        - 0x00: Duplicate filtering disabled
  *        - 0x01: Duplicate filtering enabled
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_general_connection_establish_proc(uint8_t le_scan_type,
                                                             uint16_t le_scan_interval,
                                                             uint16_t le_scan_window,
                                                             uint8_t own_address_type,
                                                             uint8_t scanning_filter_policy,
                                                             uint8_t filter_duplicates);
/**
  * @brief Start a selective connection establishment procedure. The GAP adds the
  *        specified device addresses into white list and enables scanning in the
  *        controller with the scanner filter policy set to "accept packets only
  *        from devices in whitelist". All the devices found are sent to the
  *        upper layer by the event @ref hci_le_advertising_report_event. The
  *        upper layer then has to select one of the devices to which it wants to
  *        connect by issuing the command @ref aci_gap_create_connection. On
  *        completion of the procedure a @ref aci_gap_proc_complete_event event
  *        is generated with the procedure code set to 0x20. The procedure is
  *        terminated when a connection is established or the upper layer
  *        terminates the procedure by issuing the command @ref
  *        aci_gap_terminate_gap_proc with the procedure code set to 0x20. If
  *        controller privacy is enabled and the peer device (advertiser) is in
  *        the resolving list then  the link layer will generate a RPA, if it is
  *        not then the RPA/NRPA generated by the Host will be used.
  * @param le_scan_type Passive or active scanning. With active scanning SCAN_REQ
  *        packets are sent.
  *        Values:
  *        - 0x00: Passive Scanning
  *        - 0x01: Active scanning
  * @param le_scan_interval This is defined as the time interval from when the
  *        Controller started its last LE scan until it begins the subsequent LE
  *        scan. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param le_scan_window The duration of the LE scan. le_scan_window shall be
  *        less than or equal to le_scan_interval. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param scanning_filter_policy Scanning filter policy:  - 0x00 Accept all
  *        advertisement packets.Directed advertising packets which are not
  *        addressed for this device shall be ignored.  - 0x01 Ignore
  *        advertisement packets from devices not in the White List Only.Directed
  *        advertising packets which are not addressed for this device shall be
  *        ignored.  - 0x02 Accept all undirected advertisement packets (it is
  *        allowed only if controller privacy or host privacy is
  *        enabled).Directed advertisement packets where initiator address is a
  *        RPA and Directed advertisement packets addressed to this device shall
  *        be accepted.  - 0x03 Accept all undirected advertisement packets from
  *        devices that are in the White List.Directed advertisement packets
  *        where initiator address is RPA and Directed advertisement packets
  *        addressed to this device shall be accepted.  - NOTE: if controller
  *        privacy is enabled scanning_filter_policy can only assume values 0x01
  *        or 0x03; if Host privacy is enabled scanning_filter_policy can only
  *        assume value 0x01.
  *        Values:
  *        - 0x00: Accept all
  *        - 0x01: Ignore devices not in the White List
  *        - 0x02: Accept all (use resolving list)
  *        - 0x03: Ignore devices not in the White List (use resolving list)
  * @param filter_duplicates Enable/disable duplicate filtering.
  *        Values:
  *        - 0x00: Duplicate filtering disabled
  *        - 0x01: Duplicate filtering enabled
  * @param num_of_whitelist_entries Number of devices that have to be added to
  *        the whitelist.
  *        Values:
  *        - 0x00 ... 0xFF
  * @param whitelist_entry See @ref whitelist_entry_t
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_selective_connection_establish_proc(uint8_t le_scan_type,
                                                               uint16_t le_scan_interval,
                                                               uint16_t le_scan_window,
                                                               uint8_t own_address_type,
                                                               uint8_t scanning_filter_policy,
                                                               uint8_t filter_duplicates,
                                                               uint8_t num_of_whitelist_entries,
                                                               whitelist_entry_t whitelist_entry[]);
/**
  * @brief Start the direct connection establishment procedure. A
  *        LE_Create_Connection call will be made to the controller by GAP with
  *        the initiator filter policy set to "ignore whitelist and process
  *        connectable advertising packets only for the specified device". The
  *        procedure can be terminated explicitly by the upper layer by issuing
  *        the command @ref aci_gap_terminate_gap_proc. When a command is issued
  *        to terminate the procedure by upper layer, a @ref
  *        hci_le_create_connection_cancel call will be made to the controller by
  *        GAP. On termination of the procedure, a @ref
  *        hci_le_connection_complete_event event is returned. The   procedure
  *        can be explicitly terminated by the upper layer by issuing the command
  *        @ref aci_gap_terminate_gap_proc with the procedure_code set to 0x40.
  *        If controller privacy is enabled and the peer device (advertiser) is
  *        in the resolving list then the link layer will generate a RPA, if it
  *        is not then the RPA/NRPA generated by the Host will be used.
  * @param le_scan_interval This is defined as the time interval from when the
  *        Controller started its last LE scan until it begins the subsequent LE
  *        scan. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param le_scan_window The duration of the LE scan. le_scan_window shall be
  *        less than or equal to le_scan_interval. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param peer_address_type Peer Address type.
  *        Values:
  *        - 0x00: Public Device Address or Public Identity Address
  *        - 0x01: Random Device Address or Random (static) Identity Address
  * @param peer_address Public Device Address, Random Device Address, Public
  *        Identity Address or Random (static) Identity Address of the
  *        advertising device.
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param conn_interval_min Minimum value for the connection event interval.
  *        This shall be less than or equal to conn_interval_max. Time = N * 1.25
  *        msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_interval_max Maximum value for the connection event interval.
  *        This shall be greater than or equal to conn_interval_min. Time = N *
  *        1.25 msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param supervision_timeout Supervision timeout for the LE Link. It shall be a
  *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
  *        connInterval * 2. Time = N * 10 msec.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @param minimum_ce_length Information parameter about the minimum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @param maximum_ce_length Information parameter about the maximum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_create_connection(uint16_t le_scan_interval,
                                       uint16_t le_scan_window,
                                       uint8_t peer_address_type,
                                       uint8_t peer_address[6],
                                       uint8_t own_address_type,
                                       uint16_t conn_interval_min,
                                       uint16_t conn_interval_max,
                                       uint16_t conn_latency,
                                       uint16_t supervision_timeout,
                                       uint16_t minimum_ce_length,
                                       uint16_t maximum_ce_length);
/**
  * @brief Terminate the specified GATT procedure. An @ref
  *        aci_gap_proc_complete_event event is returned with the procedure code
  *        set to the corresponding procedure.
  * @param procedure_code GAP procedure bitmap.
  *        Values:
  *        - 0x00: No events
  *        - 0x01: LIMITED_DISCOVERY_PROC
  *        - 0x02: GENERAL_DISCOVERY_PROC
  *        - 0x04: NAME_DISCOVERY_PROC
  *        - 0x08: AUTO_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x10: GENERAL_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x20: SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x40: DIRECT_CONNECTION_ESTABLISHMENT_PROC
  *        - 0x80: OBSERVATION_PROC
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_terminate_gap_proc(uint8_t procedure_code);
/**
  * @brief Start the connection update procedure (only when role is Master). A
  *        @ref hci_le_connection_update is called. On completion of the
  *        procedure, an @ref hci_le_connection_update_complete_event event is
  *        returned to the upper layer.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param conn_interval_min Minimum value for the connection event interval.
  *        This shall be less than or equal to conn_interval_max. Time = N * 1.25
  *        msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_interval_max Maximum value for the connection event interval.
  *        This shall be greater than or equal to conn_interval_min. Time = N *
  *        1.25 msec.
  *        Values:
  *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
  * @param conn_latency Slave latency for the connection in number of connection
  *        events.
  *        Values:
  *        - 0x0000 ... 0x01F3
  * @param supervision_timeout Supervision timeout for the LE Link. It shall be a
  *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
  *        connInterval * 2. Time = N * 10 msec.
  *        Values:
  *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
  * @param minimum_ce_length Information parameter about the minimum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @param maximum_ce_length Information parameter about the maximum length of
  *        connection needed for this LE connection. Time = N * 0.625 msec.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_connection_update(uint16_t connection_handle,
                                             uint16_t conn_interval_min,
                                             uint16_t conn_interval_max,
                                             uint16_t conn_latency,
                                             uint16_t supervision_timeout,
                                             uint16_t minimum_ce_length,
                                             uint16_t maximum_ce_length);
/**
  * @brief Send the SM pairing request to start a pairing process. The
  *        authentication requirements and IO capabilities should be set before
  *        issuing this command using the @ref aci_gap_set_io_capability and @ref
  *        aci_gap_set_authentication_requirement commands. A @ref
  *        aci_gap_pairing_complete_event event is returned after the pairing
  *        process is completed.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param force_rebond If 1, Pairing request will be sent even if the device was
  *        previously bonded,  otherwise pairing request is not sent.
  *        Values:
  *        - 0x00: NO
  *        - 0x01: YES
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_send_pairing_req(uint16_t connection_handle,
                                      uint8_t force_rebond);
/**
  * @brief This command tries to resolve the address provided with the IRKs
  *        present in its database. If the address is resolved successfully with
  *        any one of the IRKs present in the database, it returns success and
  *        also the corresponding public/static random address stored with the
  *        IRK in the database.
  * @param address Address to be resolved
  * @param[out] actual_address The public or static random address of the peer
  *             device, distributed during pairing phase.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_resolve_private_addr(uint8_t address[6],
                                          uint8_t actual_address[6]);
/**
  * @brief This command puts the device into broadcast mode. A privacy enabled
  *        device uses either a resolvable private address or a non-resolvable
  *        private address as specified in the Own_Addr_Type parameter of the
  *        command.
  * @param advertising_interval_min Minimum advertising interval for undirected
  *        and low duty cycle directed advertising. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @param advertising_interval_max Maximum advertising interval. Time = N *
  *        0.625 msec.
  *        Values:
  *        - 0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms)
  * @param advertising_type Non connectable advertising type
  *        Values:
  *        - 0x02: ADV_SCAN_IND (Scannable undirected advertising)
  *        - 0x03: ADV_NONCONN_IND (Non connectable undirected advertising)
  * @param own_address_type If Privacy is disabled, then the address can be
  *        public or static random. If Privacy is enabled, then the address can
  *        be a resolvable private address or a non-resolvable private address.
  *        Values:
  *        - 0x00: Public address
  *        - 0x01: Static random address
  *        - 0x02: Resolvable private address
  *        - 0x03: Non-resolvable private address
  * @param adv_data_length Length of the advertising data in the advertising
  *        packet.
  * @param adv_data Advertising data used by the device while advertising.
  * @param num_of_whitelist_entries Number of devices that have to be added to
  *        the whitelist.
  *        Values:
  *        - 0x00 ... 0xFF
  * @param whitelist_entry See @ref whitelist_entry_t
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_broadcast_mode(uint16_t advertising_interval_min,
                                        uint16_t advertising_interval_max,
                                        uint8_t advertising_type,
                                        uint8_t own_address_type,
                                        uint8_t adv_data_length,
                                        uint8_t adv_data[],
                                        uint8_t num_of_whitelist_entries,
                                        whitelist_entry_t whitelist_entry[]);
/**
  * @brief Starts an Observation procedure, when the device is in Observer Role.
  *        The host enables scanning in the controller. The advertising reports
  *        are sent to the upper layer using standard LE Advertising Report
  *        Event. (See Bluetooth Core v4.1, Vol. 2, part E, Ch. 7.7.65.2, LE
  *        Advertising Report Event). If controller privacy is enabled and the
  *        peer device (advertiser) is in the resolving list then the link layer
  *        will generate a RPA, if it is not then the RPA/NRPA generated by the
  *        Host will be used.
  * @param le_scan_interval This is defined as the time interval from when the
  *        Controller started its last LE scan until it begins the subsequent LE
  *        scan. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param le_scan_window The duration of the LE scan. le_scan_window shall be
  *        less than or equal to le_scan_interval. Time = N * 0.625 msec.
  *        Values:
  *        - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)
  * @param le_scan_type Passive or active scanning. With active scanning SCAN_REQ
  *        packets are sent.
  *        Values:
  *        - 0x00: Passive Scanning
  *        - 0x01: Active scanning
  * @param own_address_type Own address type:  - 0x00: Public Device Address (it
  *        is allowed only if privacy is disabled)  - 0x01: Random Device Address
  *        (it is allowed only if privacy is disabled)  - 0x02: Resolvable
  *        Private Address (it is allowed only if privacy is enabled)  - 0x03:
  *        Non Resolvable Private Address (it is allowed only if privacy is
  *        enabled)
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  *        - 0x02: Resolvable Private Address
  *        - 0x03: Non Resolvable Private Address
  * @param filter_duplicates Enable/disable duplicate filtering.
  *        Values:
  *        - 0x00: Duplicate filtering disabled
  *        - 0x01: Duplicate filtering enabled
  * @param scanning_filter_policy Scanning filter policy:  - 0x00 Accept all
  *        advertisement packets (it is allowed only if controller privacy is
  *        enabled).Directed advertising packets which are not addressed for this
  *        device shall be ignored.  - 0x01 Ignore advertisement packets from
  *        devices not in the White List Only.Directed advertising packets which
  *        are not addressed for this device shall be ignored.  - 0x02 Accept all
  *        undirected advertisement packets (it is allowed only if controller
  *        privacy or host privacy is enabled).Directed advertisement packets
  *        where initiator address is a RPA and Directed advertisement packets
  *        addressed to this device shall be accepted.  - 0x03 Accept all
  *        undirected advertisement packets from devices that are in the White
  *        List.Directed advertisement packets where initiator address is RPA and
  *        Directed advertisement packets addressed to this device shall be
  *        accepted.  - NOTE: If Host privacy is enabled scanning_filter_policy
  *        can only take values 0x00 or 0x01;
  *        Values:
  *        - 0x00: Accept all
  *        - 0x01: Ignore devices not in the White List
  *        - 0x02: Accept all (use resolving list)
  *        - 0x03: Ignore devices not in the White List (use resolving list)
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_start_observation_proc(uint16_t le_scan_interval,
                                            uint16_t le_scan_window,
                                            uint8_t le_scan_type,
                                            uint8_t own_address_type,
                                            uint8_t filter_duplicates,
                                            uint8_t scanning_filter_policy);
/**
  * @brief This command gets the list of the devices which are bonded. It returns
  *        the number of addresses and the corresponding address types and
  *        values. The maximum number of devices that can be returned is
  *        MAX_NUM_BONDED_DEVICES (12).
  * @param[out] num_of_addresses The number of bonded devices
  * @param[out] bonded_device_entry See @ref bonded_device_entry_t
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_get_bonded_devices(uint8_t *num_of_addresses,
                                        bonded_device_entry_t bonded_device_entry[]);
/**
  * @brief The command finds whether the device, whose address is specified in
  *        the command, is bonded. If the device is using a resolvable private
  *        address and it has been bonded, then the command will return
  *        BLE_STATUS_SUCCESS.
  * @param peer_address_type Address type.
  *        Values:
  *        - 0x00: Public Device Address
  *        - 0x01: Random Device Address
  * @param peer_address Address used by the peer device while advertising
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_is_device_bonded(uint8_t peer_address_type,
                                      uint8_t peer_address[6]);
/**
  * @brief This command allows the User to validate/confirm or not the Numeric
  *        Comparison value showed through the
  *        ACI_GAP_Numeric_Comparison_Value_Event.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param confirm_yes_no 0 : The Numeric Values showed on both local and peer
  *        device are different! 1 : The Numeric Values showed on both local and
  *        peer device are equal!
  *        Values:
  *        - 0x00: No
  *        - 0x01: YES
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_numeric_comparison_value_confirm_yesno(uint16_t connection_handle,
                                                            uint8_t confirm_yes_no);
/**
  * @brief This command permits to signal to the Stack the input type detected
  *        during Passkey input.
  * @param connection_handle Connection handle that identifies the connection.
  *        Values:
  *        - 0x0000 ... 0x0EFF
  * @param input_type Passkey input type detected
  *        Values:
  *        - 0x00: Passkey entry started
  *        - 0x01: Passkey digit entered
  *        - 0x02: Passkey digit erased
  *        - 0x03: Passkey cleared
  *        - 0x04: Passkey entry completed
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_passkey_input(uint16_t connection_handle,
                                   uint8_t input_type);
/**
  * @brief This command is sent by the User to get (i.e. to extract from the
  *        Stack) the OOB data generated by the Stack itself. In a complete
  *        system (i.e. having an OOB channel fully handled) this command should
  *        be invoked by the OOB Channel manager to require the local OOB data
  *        (hence without user interaction) to be sent via OOB to the remote peer
  *        candidate device. The requested OOB data are returned in response to
  *        the incoming command. The OOB data are not generated on the fly, but
  *        they are already available in the Stack.
  * @param oob_data_type OOB Data type. - 0x00: Legacy Privacy (LP) v.4.1 TK
  *        (Temporary Key) - 0x01: Secure Connections (SC) v.4.2 Random value r
  *        used for generation of Confirm - 0x02: Secure Connections (SC) v.4.2
  *        Confirm value C generated through AES-CMAC-128 based cryptographic
  *        function: C=f4(PKx, PKx, r, 0)
  *        Values:
  *        - 0x00: SM_TK
  *        - 0x01: SM_RANDOM_VALUE
  *        - 0x02: SM_CONFIRM_VALUE
  * @param[out] address_type Identity address type.
  *             Values:
  *             - 0x00: Public Identity Address
  *             - 0x01: Random (static) Identity Address
  * @param[out] address Public or Random (static) address of this  device
  * @param[out] oob_data_len Length of OOB Data carried by next data field
  * @param[out] oob_data OOB Data to be exported via OOB.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_get_oob_data(uint8_t oob_data_type,
                                  uint8_t *address_type,
                                  uint8_t address[6],
                                  uint8_t *oob_data_len,
                                  uint8_t oob_data[16]);
/**
  * @brief This command is sent (by the User) to input the OOB data arrived via
  *        OOB communication. It may be sent to set either the OOB Authentication
  *        data of the Local device, or the data received via OOB by the Remote
  *        peer candidate device. It can be used with oob_data_len set to 0 to
  *        generate OOB authentication data for Secure Connections. In a complete
  *        system (i.e. having an OOB channel fully handled) this command should
  *        be invoked by the OOB Channel manager when receiving the OOB data
  *        (hence without user interaction). Since the BLE stack v 2.x
  *        implementation supports just one entry for the Remote peer candidate
  *        list containing the OOB data, at every command invocation the data
  *        existing in that entry are overwritten.
  * @param device_type OOB Device type:  - 0x00: The Address information are
  *        ignored.    - oob_data_len= 0x00: this triggers the automatic
  *        regeneration of OOB Authentication data (for Secure Connections only;
  *        a ECDH-Public Key must).    - oob_data_len in [0..16]: the oob_data
  *        carried by the command will overwrite the current local Authentication
  *        OOB Data.  - 0x01: The Address information is used to search the entry
  *        of the Remote peer candidate list containing the OOB data for that
  *        specific remote device; if no entry exists, the a new entry is used,
  *        if available (current implementation supports just 1 entry in this
  *        list).    - oob_data_len in [0..16]: the oob_data carried by the
  *        command overwrites (if present) the remote Authentication OOB Data.
  *        Values:
  *        - 0x00: Local device
  *        - 0x01: Remote device
  * @param address_type Identity address type.
  *        Values:
  *        - 0x00: Public Identity Address
  *        - 0x01: Random (static) Identity Address
  * @param address Public or Random (static) address of the peer device
  * @param oob_data_type OOB Data type. - 0x00: Legacy Privacy (LP) v.4.1 TK
  *        (Temporary Key) - 0x01: Secure Connections (SC) v.4.2 Random value r
  *        used for generation of Confirm - 0x02: Secure Connections (SC) v.4.2
  *        Confirm value C generated through AES-CMAC-128 based cryptographic
  *        function: C=f4(PKx, PKx, r, 0)
  *        Values:
  *        - 0x00: SM_TK
  *        - 0x01: SM_RANDOM_VALUE
  *        - 0x02: SM_CONFIRM_VALUE
  * @param oob_data_len Length of OOB Data carried by next data field
  *        Values:
  *        - 0x00 ... 0x10
  * @param oob_data OOB Data to be exported via OOB.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_set_oob_data(uint8_t device_type,
                                  uint8_t address_type,
                                  uint8_t address[6],
                                  uint8_t oob_data_type,
                                  uint8_t oob_data_len,
                                  uint8_t oob_data[16]);
/**
  * @brief This  command is used to add one device to the list of address
  *        translations used to resolve Resolvable Private Addresses in the
  *        Controller.
  * @param num_of_resolving_list_entries Number of devices that have to be added
  *        to the resolving list.
  * @param whitelist_identity_entry See @ref whitelist_identity_entry_t
  * @param clear_resolving_list Clear the resolving list before adding the
  *        devices.
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_add_devices_to_resolving_list(uint8_t num_of_resolving_list_entries,
                                                   whitelist_identity_entry_t whitelist_identity_entry[],
                                                   uint8_t clear_resolving_list);
/**
  * @brief This command can be used to remove a specified device from the bonding
  *        table.
  * @param peer_identity_address_type Identity address type.
  *        Values:
  *        - 0x00: Public Identity Address
  *        - 0x01: Random (static) Identity Address
  * @param peer_identity_address Public or Random (static) Identity address of
  *        the peer device
  * @retval Value indicating success or error code.
  */
ble_status_t aci_gap_remove_bonded_device(uint8_t peer_identity_address_type,
                                          uint8_t peer_identity_address[6]);
/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

#ifdef __cplusplus
}
#endif

#endif /* _BLUENRG1_GAP_ACI_H_ */
