/**
  ******************************************************************************
  * @file    UtilTask.c
  * @author  SRA
  * @brief   UtilTask_t definition.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  *
  ******************************************************************************
  */

#include "UtilTask.h"
#include "UtilTask_vtbl.h"
#include "services/sysmem.h"
#include "services/sysdebug.h"
#include "services/SQuery.h"
#include "services/SysTimestamp.h"
#include "mx.h"


#ifndef UTIL_TASK_CFG_STACK_DEPTH
#define UTIL_TASK_CFG_STACK_DEPTH                   TX_MINIMUM_STACK
#endif

#ifndef UTIL_TASK_CFG_PRIORITY
#define UTIL_TASK_CFG_PRIORITY                      (TX_MAX_PRIORITIES-2)
#endif

#define UTIL_TASK_ANTI_DEBOUNCH_PERIOD_TICK         (12U)

#define SYS_DEBUGF(level, message)      SYS_DEBUGF3(SYS_DBG_UTIL, level, message)

#if defined(DEBUG) || defined (SYS_DEBUG)
#define sTaskObj                               sUtilTaskObj
#endif

/**
  * Class object declaration. The class object encapsulates members that are shared between
  * all instance of the class.
  */
typedef struct _UtilTaskClass_t
{
  /**
    * UtilTask class virtual table.
    */
  AManagedTaskEx_vtbl vtbl;

  /**
    * UtilTask class (PM_STATE, ExecuteStepFunc) map. The map is implemented with an array and
    * the key is the index. Number of items of this array must be equal to the number of PM state
    * of the application. If the managed task does nothing in a PM state, then set to NULL the
    * relative entry in the map.
    */
  pExecuteStepFunc_t p_pm_state2func_map[];
} UtilTaskClass_t;

/* Imported function declaration */
/*********************************/

sys_error_code_t UsbCdcTask_Write(UCHAR *buffer, ULONG requested_length,
                                  ULONG *actual_length); //TODO: STF - must I import UsbCdcTask.h ??


/* Private member function declaration */
/***************************************/

/**
  * Execute one step of the task control loop while the system is in STATE1 or SENSOR_ACTIVE mode.
  *
  * @param _this [IN] sTaskObjecifies a pointer to a task object.
  * @return SYS_NO_EROR_CODE if success, a task specific error code otherwise.
  */
static sys_error_code_t UtilTaskExecuteStep(AManagedTask *_this);

/**
  * @brief Random function initialization.
  *        Initialize srand() using a random number generated by RNG peripheral
  * @param None
  * @retval None
  */
static void RND_Init(void);

/* Inline function forward declaration */
/***************************************/


/**
  * The only instance of the task object.
  */
static UtilTask_t sTaskObj;

/**
  * The class object.
  */
static const UtilTaskClass_t sTheClass =
{
  /* Class virtual table */
  {
    UtilTask_vtblHardwareInit,
    UtilTask_vtblOnCreateTask,
    UtilTask_vtblDoEnterPowerMode,
    UtilTask_vtblHandleError,
    UtilTask_vtblOnEnterTaskControlLoop,
    UtilTask_vtblForceExecuteStep,
    UtilTask_vtblOnEnterPowerMode
  },

  /* class (PM_STATE, ExecuteStepFunc) map */
  {
    UtilTaskExecuteStep,
    NULL,
    UtilTaskExecuteStep
  }
};

/* Public API definition */
/*************************/

AManagedTaskEx *UtilTaskAlloc(const void *pLEDConfigMX, const void *pUBConfigMX)
{
  /* Initialize the super class */
  AMTInitEx(&sTaskObj.super);

  sTaskObj.super.vptr = &sTheClass.vtbl;

  sTaskObj.pLEDConfigMX = pLEDConfigMX;
  sTaskObj.pUBConfigMX = pUBConfigMX;

  return (AManagedTaskEx *) &sTaskObj;
}


/* AManagedTask virtual functions definition */
/*********************************************/

sys_error_code_t UtilTask_vtblHardwareInit(AManagedTask *_this, void *p_params)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *)_this;

  if (p_obj->pLEDConfigMX != NULL)
  {
    /*configure the LED*/
    MX_GPIOParams_t *p_led_params = (MX_GPIOParams_t *)p_obj->pLEDConfigMX;
    p_led_params->p_mx_init_f();
  }

  if (p_obj->pUBConfigMX != NULL)
  {
    /* configure the user button*/
    MX_GPIOParams_t *p_ub_params = (MX_GPIOParams_t *)p_obj->pUBConfigMX;
    p_ub_params->p_mx_init_f();
  }

  /* Configure random number generated */
  RND_Init();

  return res;
}

sys_error_code_t UtilTask_vtblOnCreateTask(AManagedTask *_this, tx_entry_function_t *p_task_code, CHAR **p_name,
                                           VOID **pvStackStart, ULONG *p_stack_size,
                                           UINT *p_priority, UINT *p_preempt_threshold,
                                           ULONG *p_time_slice, ULONG *p_auto_start,
                                           ULONG *p_params)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *)_this;

  p_obj->counter = 0;
  _this->m_pfPMState2FuncMap = sTheClass.p_pm_state2func_map;

  *p_task_code = AMTRun;
  *p_name = "UTIL";
  *pvStackStart = NULL; /* allocate the task stack in the system memory pool. */
  *p_stack_size = UTIL_TASK_CFG_STACK_DEPTH;
  *p_params = (ULONG)_this;
  *p_priority = UTIL_TASK_CFG_PRIORITY;
  *p_preempt_threshold = UTIL_TASK_CFG_PRIORITY;
  *p_time_slice = TX_NO_TIME_SLICE;
  *p_auto_start = TX_AUTO_START;

  return res;
}

sys_error_code_t UtilTask_vtblDoEnterPowerMode(AManagedTask *_this, const EPowerMode active_power_mode,
                                               const EPowerMode new_power_mode)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *)_this;
  MX_GPIOParams_t *p_led_params = (MX_GPIOParams_t *)p_obj->pLEDConfigMX;

  if (new_power_mode == E_POWER_MODE_SENSORS_ACTIVE)
  {
//    SysTsStart(SysGetTimestampSrv(), true);
  }
  else if (new_power_mode == E_POWER_MODE_STATE1)
  {
//    SysTsStop(SysGetTimestampSrv());
    if (p_led_params != NULL)
    {
      HAL_GPIO_WritePin(p_led_params->port, p_led_params->pin, GPIO_PIN_SET);
    }
  }

  SYS_DEBUGF(SYS_DBG_LEVEL_VERBOSE, ("UTIL: %d -> %d.\r\n", active_power_mode, new_power_mode));

  return res;
}

sys_error_code_t UtilTask_vtblHandleError(AManagedTask *_this, SysEvent error)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  /*  UtilTask_t *p_obj = (UtilTask_t*)_this; */

  return res;
}

sys_error_code_t UtilTask_vtblOnEnterTaskControlLoop(AManagedTask *_this)
{
  assert_param(_this);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *)_this;

  if (p_obj->pLEDConfigMX != NULL)
  {
    MX_GPIOParams_t *p_led_params = (MX_GPIOParams_t *)p_obj->pLEDConfigMX;
    HAL_GPIO_WritePin(p_led_params->port, p_led_params->pin, GPIO_PIN_SET);
  }

  SYS_DEBUGF(SYS_DBG_LEVEL_VERBOSE, ("UTIL: start.\r\n"));

  return res;
}


/* AManagedTaskEx virtual functions definition */
/***********************************************/

sys_error_code_t UtilTask_vtblForceExecuteStep(AManagedTaskEx *_this, EPowerMode active_power_mode)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  /*  UtilTask_t *p_obj = (UtilTask_t*)_this; */

  return res;
}

sys_error_code_t UtilTask_vtblOnEnterPowerMode(AManagedTaskEx *_this, const EPowerMode active_power_mode,
                                               const EPowerMode new_power_mode)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  /*  UtilTask_t *p_obj = (UtilTask_t*)_this; */

  return res;
}

/* Private function definition */
/*******************************/

static sys_error_code_t UtilTaskExecuteStep(AManagedTask *_this)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *)_this;
  static bool half_period = true;
  MX_GPIOParams_t *p_led_params = (MX_GPIOParams_t *)p_obj->pLEDConfigMX;
  tx_thread_sleep(AMT_MS_TO_TICKS(500));
  if (!half_period)
  {
    p_obj->counter++;
    EPowerMode active_power_mode = SysGetPowerStatus().active_power_mode;
    if (active_power_mode == E_POWER_MODE_STATE1)
    {
//      SYS_DEBUGF(SYS_DBG_LEVEL_VERBOSE, ("Hello NUCLEO-U575ZI-Q %d!!\r\n", p_obj->counter));
    }
    else if (active_power_mode == E_POWER_MODE_SENSORS_ACTIVE)
    {
      if (p_led_params != NULL)
      {
        HAL_GPIO_TogglePin(p_led_params->port, p_led_params->pin);
      }
    }
  }

  __NOP();
  half_period = !half_period;

  return res;
}


/**
  * @brief Random function initialization.
  *        Initialize srand() using a random number generated by RNG peripheral
  * @param None
  * @retval None
  */
static void RND_Init(void)
{
  RNG_HandleTypeDef RngHandle;

  /* Used for storing Random 32bit Number */
  uint32_t aRandom32bit;

  /* Configure the RNG peripheral */
  RngHandle.Instance = RNG;
  RngHandle.Init.ClockErrorDetection = RNG_CED_DISABLE;

  /* DeInitialize the RNG peripheral */
  if (HAL_RNG_DeInit(&RngHandle) != HAL_OK)
  {
    /* DeInitialization Error */
    sys_error_handler();
  }

  /* Initialize the RNG peripheral */
  if (HAL_RNG_Init(&RngHandle) != HAL_OK)
  {
    /* Initialization Error */
    sys_error_handler();
  }

  if (HAL_RNG_GenerateRandomNumber(&RngHandle, &aRandom32bit) != HAL_OK)
  {
    /* Random number generation error */
    sys_error_handler();
  }

  HAL_RNG_DeInit(&RngHandle);

  /* Initialize srand() using the random number generated by RNG peripheral */
  srand(aRandom32bit);
}


/* CubeMX integration */
/**********************/

void Util_USR_EXTI_Callback(uint16_t pin)
{
  /* anti debounch */
  static uint32_t t_start = 0;
  if (HAL_GetTick() - t_start > UTIL_TASK_ANTI_DEBOUNCH_PERIOD_TICK)
  {
    /* trigger the power mode transaction */
    SysEvent evt = {.nRawEvent = SYS_PM_MAKE_EVENT(SYS_PM_EVT_SRC_PB, SYS_PM_EVT_PARAM_SHORT_PRESS) };
    SysPostPowerModeEvent(evt);
  }
}

