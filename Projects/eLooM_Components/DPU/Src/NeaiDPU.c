/**
  ******************************************************************************
  * @file    NeaiDPU.c
  * @author  SRA - MCD
  * @brief   Define the NeaiDPIU.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

#include "NeaiDPU.h"
#include "NeaiDPU_vtbl.h"
#include "knowledge_ncc.h"
#include "services/sysmem.h"
#include "services/sysdebug.h"

#define SYS_DEBUGF(level, message)  SYS_DEBUGF3(SYS_DBG_NEAI, level, message)


/**
  * Class object declaration.
  */
typedef struct _NeaiDPU_Class
{
  /**
    * IDPU2_t class virtual table.
    */
  IDPU2_vtbl vtbl;

} NeaiDPU_Class_t;


/* Objects instance */
/********************/

/**
  * The class object.
  */
static const NeaiDPU_Class_t sTheClass =
{
  /* class virtual table */
  {
    ADPU2_vtblAttachToDataSource,
    ADPU2_vtblDetachFromDataSource,
    ADPU2_vtblAttachToDPU,
    ADPU2_vtblDetachFromDPU,
    ADPU2_vtblDispatchEvents,
    ADPU2_vtblRegisterNotifyCallback,
    NeaiDPU_vtblProcess
  }
};


/* Private member function declaration */
/***************************************/


/* Inline function forward declaration */
/***************************************/


/* IDPU2 virtual functions definition */
/**************************************/

sys_error_code_t NeaiDPU_vtblProcess(IDPU2_t *_this, EMData_t in_data, EMData_t out_data)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  NeaiDPU_t *p_obj = (NeaiDPU_t *)_this;
  float *p_out = (float *)EMD_Data(&out_data);

  enum neai_state status;
  float *p_signal = (float *)EMD_Data(&in_data);
  if (p_obj->proc_mode ==  E_NEAI_ANOMALY_LEARN && p_obj->proc.anomalyLearn)
  {
    status = p_obj->proc.anomalyLearn(p_signal);
    p_out[0] = (float)status;
  }
  else if (p_obj->proc_mode ==  E_NEAI_ANOMALY_DETECT && p_obj->proc.anomalyDetect)
  {
    uint8_t proc_out;
    status = p_obj->proc.anomalyDetect(p_signal, &proc_out);
    p_out[0] = (float)status;
    p_out[1] = (float)proc_out;
  }
  else if (p_obj->proc_mode ==  E_NEAI_CLASSIFICATION && p_obj->proc.classification)
  {
    uint16_t id_class;
    status = p_obj->proc.classification(p_signal, &p_out[2], &id_class);
    p_out[0] = (float)status;
    p_out[1] = (float)id_class;
  }
  else
  {
    SYS_DEBUGF(SYS_DBG_LEVEL_WARNING, ("NEAI: mode (%d) not initialized\r\n", p_obj->proc_mode));
    res = SYS_UNDEFINED_ERROR_CODE;
  }

#if defined(SYS_DEBUG)
  if (!SYS_IS_ERROR_CODE(res))
  {
    SYS_DEBUGF(SYS_DBG_LEVEL_ALL, ("NEAI: mode (%d), status (%f)\r\n", p_obj->proc_mode, p_out[0]));

    if (!(status == NEAI_NOT_ENOUGH_CALL_TO_LEARNING) && !(status == NEAI_OK))
    {
      if (status == NEAI_INIT_FCT_NOT_CALLED)
      {
        SYS_DEBUGF(SYS_DBG_LEVEL_WARNING, ("NEAI: Init function not called\r\n"));
      }
      else if (status == NEAI_NOT_ENOUGH_CALL_TO_LEARNING)
      {
        SYS_DEBUGF(SYS_DBG_LEVEL_WARNING, ("NEAI: need more learning signals \r\n"));
      }
      else
        SYS_DEBUGF(SYS_DBG_LEVEL_WARNING, ("NEAI: (mode %d) status: %d \r\n", p_obj->proc_mode, status));
    }
  }
#endif

  return res;
}


/* Public API functions definition */
/***********************************/

IDPU2_t *NeaiDPU_Alloc()
{
  NeaiDPU_t *p_obj = (NeaiDPU_t *) SysAlloc(sizeof(NeaiDPU_t));

  if (p_obj != NULL)
  {
    ((IDPU2_t *)p_obj)->vptr = &sTheClass.vtbl;

    /* link the DPU to the processing function generated by the NanoEdge AI Studio (or the stub library)*/
    p_obj->proc_init.anomalyInit        = neai_anomalydetection_init;
    p_obj->proc.anomalyLearn            = neai_anomalydetection_learn;
    p_obj->proc.anomalyDetect           = neai_anomalydetection_detect;
    p_obj->proc_init.classificationInit = neai_classification_init_ncc;
    p_obj->proc.classification          = neai_classification_ncc;
  }

  return (IDPU2_t *)p_obj;
}

IDPU2_t *NeaiDPU_StaticAlloc(void *p_mem_block)
{
  NeaiDPU_t *p_obj = (NeaiDPU_t *)p_mem_block;

  if (p_obj != NULL)
  {
    ((IDPU2_t *)p_obj)->vptr = &sTheClass.vtbl;

    /* link the DPU to the processing function generated by the NanoEdge AI Studio (or the stub library)*/
    p_obj->proc_init.anomalyInit        = neai_anomalydetection_init;
    p_obj->proc.anomalyLearn            = neai_anomalydetection_learn;
    p_obj->proc.anomalyDetect           = neai_anomalydetection_detect;
    p_obj->proc_init.classificationInit = neai_classification_init_ncc;
    p_obj->proc.classification          = neai_classification_ncc;
  }

  return (IDPU2_t *)p_obj;
}

sys_error_code_t NeaiDPU_SetProcessingMode(NeaiDPU_t *_this, ENeaiMode_t mode)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  uint8_t in_axes;
  uint16_t in_signal_size, out_signal_size;

  if ((mode == E_NEAI_ANOMALY_DETECT) || (mode == E_NEAI_ANOMALY_LEARN) || (mode == E_NEAI_CLASSIFICATION))
  {
    _this->proc_mode = mode;
  }

  switch (mode)
  {
    case E_NEAI_ANOMALY_LEARN:
    case E_NEAI_ANOMALY_DETECT:
      in_axes = AXIS_NUMBER;
      in_signal_size = DATA_INPUT_USER;
      out_signal_size = 2;
      break;

    case E_NEAI_CLASSIFICATION:
      in_axes = AXIS_NUMBER_NCC;
      in_signal_size = DATA_INPUT_USER_NCC;
      out_signal_size = 2 + CLASS_NUMBER_NCC;
      break;

    default:
      res = SYS_NOT_IMPLEMENTED_ERROR_CODE;
      SYS_SET_SERVICE_LEVEL_ERROR_CODE(SYS_NOT_IMPLEMENTED_ERROR_CODE);
      break;
  }

  if (!SYS_IS_ERROR_CODE(res))
  {
    /* Prepare the EMData_t to initialize the base class.*/
    EMData_t in_data, out_data;
    uint8_t *p_in_payload = _this->super.in_data.p_payload;
    uint8_t *p_out_payload = _this->super.out_data.p_payload;
    if (in_axes == 1)
    {
      res = EMD_Init(&in_data, p_in_payload, E_EM_FLOAT, E_EM_MODE_LINEAR, 1, in_signal_size);

    }
    else
    {
      res = EMD_Init(&in_data, p_in_payload, E_EM_FLOAT, E_EM_MODE_INTERLEAVED, 2, in_signal_size, in_axes);
    }
    if (SYS_IS_ERROR_CODE(res))
    {
      sys_error_handler();
    }

    res = EMD_Init(&out_data, p_out_payload, E_EM_FLOAT, E_EM_MODE_LINEAR, 1, out_signal_size);
    if (SYS_IS_ERROR_CODE(res))
    {
      sys_error_handler();
    }

    _this->super.in_data = in_data;
    _this->super.out_data = out_data;
  }

  return res;
}

sys_error_code_t NeaiDPU_KnowledgeInit(NeaiDPU_t *_this)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;

  switch (_this->proc_mode)
  {
    case E_NEAI_ANOMALY_LEARN:
    case E_NEAI_ANOMALY_DETECT:
      _this->proc_init.anomalyInit();
      break;
    case E_NEAI_CLASSIFICATION:
      _this->proc_init.classificationInit(knowledge_ncc);
      break;
    default:
      res = SYS_NOT_IMPLEMENTED_ERROR_CODE;
      SYS_SET_SERVICE_LEVEL_ERROR_CODE(SYS_NOT_IMPLEMENTED_ERROR_CODE);
  }

  return res;
}

sys_error_code_t NeaiDPU_Init(NeaiDPU_t *_this, ENeaiMode_t mode)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  uint8_t in_axes;
  uint16_t in_signal_size, out_signal_size;

  _this->proc_mode = mode;
  switch (mode)
  {
    case E_NEAI_ANOMALY_LEARN:
    case E_NEAI_ANOMALY_DETECT:
      in_axes = AXIS_NUMBER;
      in_signal_size = DATA_INPUT_USER;
      out_signal_size = 2;
      break;

    case E_NEAI_CLASSIFICATION:
      in_axes = AXIS_NUMBER_NCC;
      in_signal_size = DATA_INPUT_USER_NCC;
      out_signal_size = 2 + CLASS_NUMBER_NCC;
      break;

    default:
      res = SYS_NOT_IMPLEMENTED_ERROR_CODE;
      SYS_SET_SERVICE_LEVEL_ERROR_CODE(SYS_NOT_IMPLEMENTED_ERROR_CODE);
      break;
  }

  if (!SYS_IS_ERROR_CODE(res))
  {
    /* Prepare the EMData_t to initialize the base class.*/
    EMData_t in_data, out_data;
    if (in_axes == 1)
    {
      res = EMD_Init(&in_data, NULL, E_EM_FLOAT, E_EM_MODE_LINEAR, 1, in_signal_size);

    }
    else
    {
      res = EMD_Init(&in_data, NULL, E_EM_FLOAT, E_EM_MODE_INTERLEAVED, 2, in_signal_size, in_axes);
    }
    if (SYS_IS_ERROR_CODE(res))
    {
      sys_error_handler();
    }

    res = EMD_Init(&out_data, NULL, E_EM_FLOAT, E_EM_MODE_LINEAR, 1, out_signal_size);
    if (SYS_IS_ERROR_CODE(res))
    {
      sys_error_handler();
    }

    /*initialize the base class.*/
    res = ADPU2_Init((ADPU2_t *)_this, in_data, out_data);

    /*complete the NeaiDPU_t initialization.*/
    if (SYS_IS_ERROR_CODE(res))
    {
      sys_error_handler();
    }

    /* take the ownership of the Sensor Event IF. Note: it is no needed anymore, but we leave it for backward compatibility.*/
    IEventListenerSetOwner((IEventListener *) ADPU2_GetEventListenerIF((ADPU2_t *)_this), _this);

    /* initialize AI libraries knowledge */
    (void)NeaiDPU_KnowledgeInit(_this);
  }


  return res;
}

sys_error_code_t NeaiDPU_PrepareToProcessData(NeaiDPU_t *_this)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;

  ADPU2_Reset((ADPU2_t *)_this);

  return res;
}

sys_error_code_t NeaiDPU_ADSetSensitivity(NeaiDPU_t *_this, float sensitivity)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;

  _this->sensitivity = sensitivity;

  neai_anomalydetection_set_sensitivity(_this->sensitivity);

  return res;
}


/* Private member function definition */
/**************************************/

