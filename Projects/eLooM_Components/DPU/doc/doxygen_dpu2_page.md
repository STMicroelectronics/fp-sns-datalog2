\page dpu2_main Digital Processing Unit v2 (DPU)

\tableofcontents

\section dpu2_introduction Introduction
Digital Processing Unit (DPU) is an eLooM-based application-level component that provides a set of processing blocks, also called DPU, which can be chained together, to apply some computation (**process**) over **input data** generated by a data source object (::ISourceObservable), like a sensor, and generate **output data**.

\anchor dpu2_fig1 \image html dpu2_use_cases.png "Fig.1 - DPU main uses cases" width=800px

It depends on the \ref emdata_main "EMData" component, also, but not only, for the data format definition. In fact a DPU manipulates multidimensional
array of homogeneous data stored in [raw major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order) using the ::EMData_t class.

\subsection dpu2_requirements Main requirements
According to the use cases of \ref dpu2_fig1 "Fig.1" a DPU can:
- **Attach** to (**detach** from) a data source
- **Attach** to (**detach** from) a DPU
- **Process** input data
- **Notify** other application objects when a new processed output is ready

These are the main functional requirements that a DPU must implement and they are modeled in the ::IDPU2_t interface, that is the base interface for all DPU.


\anchor dpu2_fig2 \image html dpu2_IDPU2_t.png "Fig.2 - IDPU2_t interface"

Moreover a DPU must:
- Be easy to use (API simple to understand)
- Be easy to extend (a developer must be able to create a new DPU with few effort)

These last two non-functional requirements guarantee a good user experience for a developer.


\section dpu2_prog_model DPU programming model
DPU are designed around the concept of data to manipulate data: a DPU receives input data (**in_data**), and it processes the data to generate output data
(**out_data**). A DPU attached to a data source receives data as soon as the data are generated by the data source. This means that a DPU cannot ask the
data source for data, but it is activated every time it receives new input data. We can imagine it as a data stream that
flows from the data source to the DPU as showed in \ref dpu2_fig3 "Fig.3".

\anchor dpu2_fig3 \image html dpu2_high_level_diagram_1.png "Fig.3 - DPU2 - data stream" width=900px

Another property of the DPU that we can identify from the above image is that a DPU is completely defined by its in_data, out_data and the processing function.
We also want to be able to connect different data sources with their specific data format to a DPU, and, generally, the data format of the data source and the in_data can be different. This introduce a problem of data conversion that we model and solve by adding the concept of data builder. A **data builder**
is an object placed between a data source and a DPU, and it is able to use the data stream to build a in_data for the DPU.

\anchor dpu2_fig4 \image html dpu2_high_level_animation.gif "Fig.4 - DPU2 - high level diagram" width=900px

The DPU component provides few data builders ready to use and a simple interface (::IDataBuilder_t) to implement new data builders:
- ::DefDataBuilder_t: it can be used when the basic type (::EMData_t::type) of the data generated by the data source and the in_data of the DPU are the same.
  It stores the data form the data stream in the DPU internal buffer, and when the in_data is ready it notifies the DPU.
- ::T1toT2DataBuilder_t: it is similar to ::Int16toFloatDataBuilder_t data builder, but it is able to convert from any type to any other
  thanks to an application defined conversion function (::Convert_f).
- ::Int16toFloatDataBuilder_t: it can be used when the basic type of the of data generated by the data source is `int16_t` and the one of the DPU in_data is
  `float`. It does the conversion from `int16_t` to `float` and store the data in the DPU internal buffer. When the in_data is ready it notifies the DPU.
  It is a slightly optimized version of ::T1toT2DataBuilder_t.

\subsection dpu2_memory DPU and memory management
In a embedded application the memory (internal or external RAM, etc.) is a limited resource. The amount of memory used by a DPU to store and process the data
changes from application to application, from few KB to tens or hundreds of KB, or even more. A DPU needs two blocks of memory, one to store the payload of
one or more in_data (called signal) and and another to store the payload of one out_data as displayed in \ref dpu2_fig5 "Fig.5".

\anchor dpu2_fig5 \image html dpu2_memory_managment.jpg "Fig.5 - DPU2 - memory buffers" width=900px

Following the design principles of \ref eLooM_main "eLooM framework" the DPU does not allocate big chunk of memory, but it delegate the application.
The rationale is that, only at application level is possible to select where to allocate a memory block according to the specific embedded application.
Instead a DPU provides easy to use API to set the data buffer:
- ADPU2_SetInDataBuffer() to set and release the memory buffer used by the DPU to manage the input data
- ADPU2_SetOutDataBuffer() to set and release the memory buffer used by the DPU to manage the output data

\subsection dpu2_example Example code
Using a DPU is, normally, a three steps process:
- **step 1**: allocate and initialize the DPU. After the allocation the DPU must be initialized. This is mandatory before using all others DPU APIs.
- **step 2**: allocate the buffers used by the DPU.
- **step 3**: connecting the DPU with a data source using a proper data builder.

Let's see how to use one of the DPU provided with the component by analyzing a simple example. Imagine we want to use the ::NeaiDPU_t to process
the data coming from a sensor.

\code{.c}
  /*Step 1: allocate and initialize the DPU for the learning phase.*/
  /*this is the DPU we use to integrate NanoEdge Library.*/
  static NeaiDPU_t sDPU;
  ADPU2_t *p_dpu = (ADPU2_t*) NeaiDPU_StaticAlloc(&sDPU);
  (void) NeaiDPU_Init(&sDPU, E_NEAI_ANOMALY_LEARN);
  (void)ADPU2_SetTag(p_dpu, 0x7);

  /*Step 2: allocate the input data buffer for the DPU. The memory allocation is delegated to the application. */
  /* how many signal I want to handle in parallel?
   * If the ODR is not too high or the inference time is not too long, then a buffer for two signals should be enough:
   * - 1 buffer to acquire a data in the sensor task
   * - 1 buffer to process a data in the process task
   */
  const uint8_t max_signals_in_buffer = 2;
  size_t buff_size = ADPU2_GetInDataPayloadSize(p_dpu) * max_signals_in_buffer;
  /*allocate the input buffer in the framework heap*/
  uint8_t *p_buff = SysAlloc(buff_size);
  assert_param(p_buff != NULL);
  res = ADPU2_SetInDataBuffer(p_dpu, p_buff, buff_size);
  assert_param(!SYS_IS_ERROR_CODE(res));
  /*allocate the output data buffer for the DPU: it must be big enough to store 1 output data.*/
  buff_size = ADPU2_GetOutDataPayloadSize(p_dpu);
  /*allocate the output buffer in the framework heap*/
  p_buff = SysAlloc(buff_size);
  assert_param(p_buff != NULL);
  res = ADPU2_SetOutDataBuffer(p_dpu, p_buff, buff_size);
  assert_param(!SYS_IS_ERROR_CODE(res));

  /*Step3: connect the DPU with the data source (sensor). */
   *We need a data builder to convert the data from the sensor format (int16_t) to the input data wanted by the DPU (float)
   */
  /*Get the ISourceObservable IF of the sensor*/
  ISourceObservable *p_data_src = SMGetSensorObserver(sensor_id);
  /*allocate the data builder */
  IDataBuilder_t *p_data_builder = Int16ToFloatDB_Alloc();
  if (p_data_builder != NULL)
  {
    res = IDPU2_AttachToDataSource((IDPU2_t*)p_dpu, p_data_source, p_data_builder, E_IDB_NO_DATA_LOSS)
    assert_param(!SYS_IS_ERROR_CODE(res));
  }
\endcode

The DPU is now ready to process the data generated by the data source. If we want to observe the out_data generated by the DPU, we can use
the method ADPU2_GetEventSrcIF() to get a pointer to the ::IEventSrc interface of the DPU and register a listener of type ::IDataEventListener_t.
When a new out_data is ready the DPU notifies all registered listeners using the virtual function IDataEventListenerOnNewDataReady().


\section dpu2_architecture Architecture of a DPU
The component provides an implementation of the ::IDPU2_t interface, that is the [abstract class](https://computinglearner.com/abstract-class-in-object-oriented-programming/) ::ADPU2_t.
This abstract class implements all the virtual functions of the ::IDPU2_t interface except the IDPU2_Process() function. All the concrete DPU
provided by the component inherit from ::ADPU2_t as displayed in \ref dpu2_fig6 "Fig.6"

\anchor dpu2_fig6 \image html dpu2_class_hierarchy.png "Fig.6 - DPU v2 class hierarchy"

It manages most of the complexity of a DPU and its integration in the application framework, but it is still an abstract class. To have
a concrete usable DPU a developer need to extend the ::ADPU2_t to provide:
- The **initialization** function
- The virtual **processing** function, IDPU2_Process()

The initialization function defines the in_data and out_data using ::EMData_t format, and it must call the ADPU2_Init() to complete the object initialization. The processing function is called by the framework when a new in_data is ready and its specific of a concrete DPU. For an example
look at ::Dummy_DPU2_t.

The architecture of the ::ADPU2_t is displayed in \ref dpu2_fig7 "Fig.7". It uses the event/listener design pattern to:
- Receive data from the attached data source (::ADPU2_t implements ::IDataEventListener_t)
- To notify all registered lister objects when a new out_data is ready (::ADPU2_t implements ::DataEventSrc_t)

To manage the **input data buffer** (see \ref dpu2_fig5 "Fig.5") it uses a ::CircularBuffer - ::ADPU2_t::cbh. All the signals are stored in the circular
buffer and processed in a first in first out order. Note that the circular buffer is transparent to a developer (it is not exposed by the by the public API of ::ADPU2_t).

Other useful API function exported by the abstract class are ADPU2_SetTag() and ADPU2_GetTag(). A tag is an application specific 32-bit value stored in the DPU.


\anchor dpu2_fig7 \image html dpu2_class_diagram.png "Fig.7 - DPU v2 class diagram" width=900px

