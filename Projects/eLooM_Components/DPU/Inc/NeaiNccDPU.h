/**
  ******************************************************************************
  * @file    NeaiNccDPU.h
  * @author  SRA - MCD
  * @brief   Digital processing Unit specialized for NanoEdgeAI n-class classification (nCC) library.
  *
  * This DPU process the data using neai library generated by NanoEdgeAI studio.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

#ifndef DPU_INC_NEAINCCDPU_H_
#define DPU_INC_NEAINCCDPU_H_

#ifdef __cplusplus
extern "C" {
#endif


#include "ADPU2.h"
#include "ADPU2_vtbl.h"
#include "ANeaiNcc_Model.h"

/**
  * Function pointers to the functions generated by NanoEdge AI Studio.
  */
typedef struct
{
  enum neai_state(*classificationInit)(const float_t *);
  enum neai_state(*classification)(float_t *, float_t *, uint16_t *);

} NEAI_Ncc_vtbl_t;

/**
  * Create  type name for _NeaiDPU_t.
  */
typedef struct _NeaiNccDPU_t NeaiNccDPU_t;

/**
  * NeaiNccDPU_t internal state.
  */
struct _NeaiNccDPU_t
{
  /**
    * Base class object.
    */
  ADPU2_t super;

  /**
    * @brief NanoEdge nCC Model interface.
    *
    * This interface is used to operate on a model generated by NanoEdge.
    * To use this interface, the user needs to implement the abstract class @ANeaiNcc_Model_t
    * and register it with the DPU using the @NeaiNccDPU_Init function.
    *
    * @note Registration of the model is required before it can be used with the DPU.
    */
  ANeaiNcc_Model_t *p_ANeaiNcc_Model;
};


/* Public API declaration */
/**************************/

/**
  * Allocate an instance of NeaiNccDPU_t in the heap.
  *
  * @return a pointer to the generic object ::IDPU if success,
  * or NULL if out of memory error occurs.
  */
IDPU2_t *NeaiNccDPU_Alloc(void);

/**
  * Allocate an instance of NeaiNccDPU_t in a memory block specified by the application.
  * The size of the memory block must be greater or equal to sizeof(NeaiNccDPU_t).
  * This allocator allows the application to avoid the dynamic allocation.
  *
  * \code
  * NeaiNccDPU_t dpu;
  * NeaiNccDPU_StaticAlloc(&dpu);
  * \endcode
  *
  * @param p_mem_block [IN] specify a memory block allocated by the application.
  *        The size of the memory block must be greater or equal to sizeof(NeaiNccDPU_t).
  * @return a pointer to the generic object ::IDPU2_t if success,
  * or NULL if out of memory error occurs.
  */
IDPU2_t *NeaiNccDPU_StaticAlloc(void *p_mem_block);


/**
  * Initialize the DPU. It must called before using the instance.
  * After the initialization the DPU needs two memory buffers to manage the input and output data.
  * The memory allocation is delegated to the application. The application use the following methods
  * to set the buffers needed by the DPU:
  * - ADPU2_SetInDataBuffer()
  * - ADPU2_SetOutDataBuffer()
  *
  * @param _this [IN] specifies a pointer to the object.
  * @return SYS_NO_ERROR_CODE if success, an application specific error code otherwise.
  */
sys_error_code_t NeaiNccDPU_Init(NeaiNccDPU_t *_this, INeaiNcc_Model_t *p_aneaincc_model);


/* IDPU2 virtual functions */
sys_error_code_t NeaiNccDPU_vtblProcess(IDPU2_t *_this, EMData_t in_data, EMData_t out_data); /*!< @sa IDPU2_Process */


#ifdef __cplusplus
}
#endif

#endif /* DPU_INC_NEAINCCDPU_H_ */
