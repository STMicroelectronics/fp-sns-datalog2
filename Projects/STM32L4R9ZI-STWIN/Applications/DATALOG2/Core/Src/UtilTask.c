/**
  ******************************************************************************
  * @file    UtilTask.c
  * @author  SRA
  * @brief   UtilTask_t definition.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  *
  ******************************************************************************
  */

#include "UtilTask.h"
#include "UtilTask_vtbl.h"
#include "app_messages_parser.h"
#include "services/sysdebug.h"
#include "services/sysmem.h"
#include "App_model.h"
#include "main.h"

/* TODO: change XXX with a short id for the task */

#ifndef UTIL_TASK_CFG_STACK_DEPTH
#define UTIL_TASK_CFG_STACK_DEPTH              (120)
#endif

#ifndef UTIL_TASK_CFG_PRIORITY
#define UTIL_TASK_CFG_PRIORITY                 (tskIDLE_PRIORITY)
#endif

#ifndef UTIL_TASK_CFG_IN_QUEUE_ITEM_SIZE
#define UTIL_TASK_CFG_IN_QUEUE_ITEM_SIZE       sizeof(struct utilMessage_t)
#endif

#ifndef UTIL_TASK_CFG_IN_QUEUE_ITEM_COUNT
#define UTIL_TASK_CFG_IN_QUEUE_ITEM_COUNT      10
#endif

#ifndef UTIL_TASK_CFG_UL_TIMER_PERIOD_MS
#define UTIL_TASK_CFG_UL_TIMER_PERIOD_MS       250
#endif

#define UTIL_UPDATE_BATTERY_CHAR_PERIOD_MS    2000U
#define RCG_BAT_MIN_VOLTAGE                   3000 //! Rechargeable battery minimum voltage in mV
#define RCG_BAT_MAX_VOLTAGE                   4200 //! Rechargeable battery maximum voltage in mV

/* TODO: define the symbol SYS_DBG_UTIL in the file sysdebug_config.h */
#define SYS_DEBUGF(level, message)             SYS_DEBUGF3(SYS_DBG_UTIL, level, message)

#if defined(DEBUG) || defined (SYS_DEBUG)
#define sTaskObj                               sUtilTaskObj
#endif

/**
  * Class object declaration. The class object encapsulates members that are shared between
  * all instance of the class.
  */
typedef struct _UtilTaskClass_t
{
  /**
    * UtilTask class virtual table.
    */
  AManagedTaskEx_vtbl vtbl;

  /**
    * UtilTask class (PM_STATE, ExecuteStepFunc) map. The map is implemented with an array and
    * the key is the index. Number of items of this array must be equal to the number of PM state
    * of the application. If the managed task does nothing in a PM state, then set to NULL the
    * relative entry in the map.
    */
  pExecuteStepFunc_t p_pm_state2func_map[];
} UtilTaskClass_t;

/* Private member function declaration */
/***************************************/

/**
  * Execute one step of the task control loop while the system is in STATE1.
  *
  * @param _this [IN] specifies a pointer to a task object.
  * @return SYS_NO_EROR_CODE if success, a task specific error code otherwise.
  */
static sys_error_code_t UtilTaskExecuteStepState1(AManagedTask *_this);

/**
  * Execute one step of the task control loop while the system is in SENSORS_ACTIVE.
  *
  * @param _this [IN] specifies a pointer to a task object.
  * @return SYS_NO_EROR_CODE if success, a task specific error code otherwise.
  */
static sys_error_code_t UtilTaskExecuteStepSensorsActive(AManagedTask *_this);

/**
  * Callback function called when the User Led software timer expires.
  *
  * @param xTimer [IN] specifies the handle of the expired timer.
  */
static VOID UtilTaskSwTimerCallbackUserLed(ULONG timer);

/**
  * Initialize the BatteryCharger
  */
static void PB_PWR_Init(void);

/**
  * @brief Random function initialization.
  *        Initialize srand() using a random number generated by RNG peripheral
  * @param None
  * @retval None
  */
static void RND_Init(void);

/* Inline function forward declaration */
/***************************************/


/**
  * The only instance of the task object.
  */
static UtilTask_t sTaskObj;

/**
  * The class object.
  */
static const UtilTaskClass_t sTheClass =
{
  /* Class virtual table */
  {
    UtilTask_vtblHardwareInit,
    UtilTask_vtblOnCreateTask,
    UtilTask_vtblDoEnterPowerMode,
    UtilTask_vtblHandleError,
    UtilTask_vtblOnEnterTaskControlLoop,
    UtilTask_vtblForceExecuteStep,
    UtilTask_vtblOnEnterPowerMode
  },

  /* class (PM_STATE, ExecuteStepFunc) map */
  {
    UtilTaskExecuteStepState1,
    NULL,
    UtilTaskExecuteStepSensorsActive
  }
};

/* Public API definition */
/*************************/

AManagedTaskEx *UtilTaskAlloc(const void *p_mx_bc_tim_drv_cfg, const void *p_mx_bc_gpio_sw_drv_cfg,
                              const void *p_mx_bc_gpio_chg_drv_cfg,
                              const void *p_mx_bc_gpio_cen_drv_cfg, const void *p_mx_bc_tim_chg_drv_cfg, const void *p_mx_bc_adc_drv_cfg,
                              const void *p_mx_ub_drv_cfg, const void *p_mx_led1_drv_cfg, const void *p_mx_led2_drv_cfg)
{
  /* In this application there is only one Keyboard task,
   * so this allocator implement the singleton design pattern.
   */

  /* Initialize the super class */
  AMTInitEx(&sTaskObj.super);

  sTaskObj.super.vptr = &sTheClass.vtbl;
  sTaskObj.p_mx_bc_tim_drv_cfg = p_mx_bc_tim_drv_cfg;
  sTaskObj.p_mx_bc_gpio_sw_drv_cfg = p_mx_bc_gpio_sw_drv_cfg;
  sTaskObj.p_mx_bc_gpio_chg_drv_cfg = p_mx_bc_gpio_chg_drv_cfg;
  sTaskObj.p_mx_bc_gpio_cen_drv_cfg = p_mx_bc_gpio_cen_drv_cfg;
  sTaskObj.p_mx_bc_tim_chg_drv_cfg = p_mx_bc_tim_chg_drv_cfg;
  sTaskObj.p_mx_bc_adc_drv_cfg = p_mx_bc_adc_drv_cfg;
  sTaskObj.p_mx_ub_drv_cfg = p_mx_ub_drv_cfg;
  sTaskObj.p_mx_led1_drv_cfg = p_mx_led1_drv_cfg;
  sTaskObj.p_mx_led2_drv_cfg = p_mx_led2_drv_cfg;

  return (AManagedTaskEx *) &sTaskObj;
}


sys_error_code_t UtilTask_GetBatteryStatus(uint8_t *batt_percentage, uint8_t *status)
{
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *) &sTaskObj;

  BCPAcquireState(&p_obj->bc_protocol, &p_obj->BattVolt, &p_obj->STBC02_state);
  if (p_obj->BattVolt > (uint16_t)RCG_BAT_MAX_VOLTAGE)
  {
    p_obj->BattVolt = RCG_BAT_MAX_VOLTAGE;
  }
  if (p_obj->BattVolt < (uint16_t)RCG_BAT_MIN_VOLTAGE)
  {
    p_obj->BattVolt = RCG_BAT_MIN_VOLTAGE;
  }

  *batt_percentage = ((p_obj->BattVolt - RCG_BAT_MIN_VOLTAGE) * 100) / (RCG_BAT_MAX_VOLTAGE - RCG_BAT_MIN_VOLTAGE);

  if (*batt_percentage > 100)
  {
    *batt_percentage = 100;
  }

  switch (p_obj->STBC02_state)
  {
    case DISCHARGING:
      *status = UTIL_BATTERY_STATUS_DISCHARGING;
      break;

    case CHARGING:
      *status = UTIL_BATTERY_STATUS_CHARGING;
      break;

    case BATTERY_NOT_CONNECTED:
      *status = UTIL_BATTERY_STATUS_NOT_CONNECTED;
      break;

    case PLUGGED_NOT_CHARGING:
      *status = UTIL_BATTERY_STATUS_FULL;
      break;

    default:
      *status = UTIL_BATTERY_STATUS_UNKNOWN;
      break;
  }

  return res;
}


/* AManagedTask virtual functions definition */
/*********************************************/

sys_error_code_t UtilTask_vtblHardwareInit(AManagedTask *_this, void *p_params)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *) _this;

  if (!SYS_IS_ERROR_CODE(res))
  {
    p_obj->p_bc_timer_driver = BCTimerDriverAlloc();
    if (p_obj->p_bc_timer_driver == NULL)
    {
      SYS_DEBUGF(SYS_DBG_LEVEL_SEVERE, ("UTIL task: unable to alloc BCDriver_t object.\r\n"));
      res = SYS_GET_LAST_LOW_LEVEL_ERROR_CODE();
    }
    else
    {
      BCTimerDriverParams_t cfg_params =
      {
        .p_mx_tim_cfg = (void *) p_obj->p_mx_bc_tim_drv_cfg,
        .p_mx_gpio_sw_cfg = (void *) p_obj->p_mx_bc_gpio_sw_drv_cfg,
      };

      res = IDrvInit(p_obj->p_bc_timer_driver, &cfg_params);
      if (SYS_IS_ERROR_CODE(res))
      {
        SYS_DEBUGF(SYS_DBG_LEVEL_SEVERE, ("UTIL task: error BC during driver initialization\r\n"));
      }
    }
  }

  if (!SYS_IS_ERROR_CODE(res))
  {
    p_obj->p_bc_tim_chg_driver = BCTimChgDriverAlloc();
    if (p_obj->p_bc_tim_chg_driver == NULL)
    {
      SYS_DEBUGF(SYS_DBG_LEVEL_SEVERE, ("UTIL task: unable to alloc BCDriver_t object.\r\n"));
      res = SYS_GET_LAST_LOW_LEVEL_ERROR_CODE();
    }
    else
    {
      BCTimChgDriverParams_t cfg_params =
      {
        .p_mx_tim_cfg = (void *) p_obj->p_mx_bc_tim_chg_drv_cfg,
        .p_mx_gpio_chg_cfg = (void *) p_obj->p_mx_bc_gpio_chg_drv_cfg,
        .p_mx_gpio_cen_cfg = (void *) p_obj->p_mx_bc_gpio_cen_drv_cfg,
      };

      res = IDrvInit(p_obj->p_bc_tim_chg_driver, &cfg_params);
      if (SYS_IS_ERROR_CODE(res))
      {
        SYS_DEBUGF(SYS_DBG_LEVEL_SEVERE, ("UTIL task: error BC during driver initialization\r\n"));
      }
    }
  }

  if (!SYS_IS_ERROR_CODE(res))
  {
    p_obj->p_bc_adc_driver = BCAdcDriverAlloc();
    if (p_obj->p_bc_adc_driver == NULL)
    {
      SYS_DEBUGF(SYS_DBG_LEVEL_SEVERE, ("UTIL task: unable to alloc BCDriver_t object.\r\n"));
      res = SYS_GET_LAST_LOW_LEVEL_ERROR_CODE();
    }
    else
    {
      res = IDrvInit(p_obj->p_bc_adc_driver, (void *) p_obj->p_mx_bc_adc_drv_cfg);
      if (SYS_IS_ERROR_CODE(res))
      {
        SYS_DEBUGF(SYS_DBG_LEVEL_SEVERE, ("UTIL task: error BC during driver initialization\r\n"));
      }
    }
  }

  if (!SYS_IS_ERROR_CODE(res))
  {
    /* Initialize the LED and User Button */
    // configure User Button 1
    if (p_obj->p_mx_ub_drv_cfg != NULL)
    {
      ((MX_GPIOParams_t *)p_obj->p_mx_ub_drv_cfg)->p_mx_init_f();
    }

    // configure Led1
    if (p_obj->p_mx_led1_drv_cfg != NULL)
    {
      MX_GPIOParams_t *p_ld1_params = (MX_GPIOParams_t *)p_obj->p_mx_led1_drv_cfg;
      p_ld1_params->p_mx_init_f();
      HAL_GPIO_WritePin(p_ld1_params->port, p_ld1_params->pin, GPIO_PIN_RESET);
    }

    // configure Led2
    if (p_obj->p_mx_led2_drv_cfg != NULL)
    {
      MX_GPIOParams_t *p_ld2_params = (MX_GPIOParams_t *)p_obj->p_mx_led2_drv_cfg;
      p_ld2_params->p_mx_init_f();
      HAL_GPIO_WritePin(p_ld2_params->port, p_ld2_params->pin, GPIO_PIN_RESET);
    }

  }

  // configure the BatteryCharger
  PB_PWR_Init();

  // Configure random number generated
  RND_Init();

  return res;
}

sys_error_code_t UtilTask_vtblOnCreateTask(AManagedTask *_this, tx_entry_function_t *pTaskCode, CHAR **pName,
                                           VOID **pvStackStart, ULONG *pStackDepth,
                                           UINT *pPriority, UINT *pPreemptThreshold, ULONG *pTimeSlice, ULONG *pAutoStart, ULONG *pParams)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *) _this;

  // Create task specific sw resources.

  uint16_t item_size = UTIL_TASK_CFG_IN_QUEUE_ITEM_SIZE;
  VOID *p_queue_items_buff = SysAlloc(UTIL_TASK_CFG_IN_QUEUE_ITEM_COUNT * item_size);
  if (p_queue_items_buff == NULL)
  {
    res = SYS_UTIL_TASK_INIT_ERROR_CODE;
    SYS_SET_SERVICE_LEVEL_ERROR_CODE(res);
    return res;
  }

  if (TX_SUCCESS != tx_queue_create(&p_obj->in_queue, "UTIL_Q", item_size / 4, p_queue_items_buff,
                                    UTIL_TASK_CFG_IN_QUEUE_ITEM_COUNT * item_size))
  {
    res = SYS_UTIL_TASK_INIT_ERROR_CODE;
    SYS_SET_SERVICE_LEVEL_ERROR_CODE(res);
    return res;
  }

  /* Software timer for user led management */
  if (TX_SUCCESS != tx_timer_create(&p_obj->user_led_timer, "USER_LED_T", UtilTaskSwTimerCallbackUserLed, (ULONG)TX_NULL,
                                    AMT_MS_TO_TICKS(UTIL_TASK_CFG_UL_TIMER_PERIOD_MS), AMT_MS_TO_TICKS(UTIL_TASK_CFG_UL_TIMER_PERIOD_MS),
                                    TX_AUTO_ACTIVATE))
  {
    res = SYS_APP_TASK_INIT_ERROR_CODE;
    SYS_SET_SERVICE_LEVEL_ERROR_CODE(res);
    return res;
  }

  /* initialize the protocol object */
  res = BCPInit(&p_obj->bc_protocol, p_obj->p_bc_timer_driver, p_obj->p_bc_tim_chg_driver, p_obj->p_bc_adc_driver);

  if (SYS_IS_ERROR_CODE(res))
  {
    return res;
  }

  /* set the (PM_STATE, ExecuteStepFunc) map from the class object.  */
  _this->m_pfPMState2FuncMap = sTheClass.p_pm_state2func_map;
  p_obj->BattVolt = 0;
  p_obj->STBC02_state = (ESTBC02_STATE_t) 4;

  *pTaskCode = AMTExRun;
  *pName = "UTIL";
  *pvStackStart = NULL; // allocate the task stack in the system memory pool.
  *pStackDepth = UTIL_TASK_CFG_STACK_DEPTH;
  *pParams = (ULONG) _this;
  *pPriority = UTIL_TASK_CFG_PRIORITY;
  *pPreemptThreshold = UTIL_TASK_CFG_PRIORITY;
  *pTimeSlice = TX_NO_TIME_SLICE;
  *pAutoStart = TX_AUTO_START;

  return res;
}

sys_error_code_t UtilTask_vtblDoEnterPowerMode(AManagedTask *_this, const EPowerMode active_power_mode,
                                               const EPowerMode new_power_mode)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *) _this;

  if (new_power_mode == E_POWER_MODE_STATE1)
  {
    /* turn on the USER LED 1 */
    if (p_obj->p_mx_led1_drv_cfg != NULL)
    {
      MX_GPIOParams_t *p_ld1_params = (MX_GPIOParams_t *)p_obj->p_mx_led1_drv_cfg;
      HAL_GPIO_WritePin(p_ld1_params->port, p_ld1_params->pin, GPIO_PIN_SET);
    }
  }
  else if (new_power_mode == E_POWER_MODE_SENSORS_ACTIVE)
  {

  }
  else if (new_power_mode == E_POWER_MODE_SLEEP_1)
  {
    /* turn off the LED1 */
    if (p_obj->p_mx_led1_drv_cfg != NULL)
    {
      MX_GPIOParams_t *p_ld1_params = (MX_GPIOParams_t *)p_obj->p_mx_led1_drv_cfg;
      HAL_GPIO_WritePin(p_ld1_params->port, p_ld1_params->pin, GPIO_PIN_RESET);
    }
  }

  SYS_DEBUGF(SYS_DBG_LEVEL_VERBOSE, ("UTIL: -> %d\r\n", (uint8_t)new_power_mode));

  return res;
}

sys_error_code_t UtilTask_vtblHandleError(AManagedTask *_this, SysEvent error)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  /*  UtilTask_t *p_obj = (UtilTask_t*)_this; */

  return res;
}

sys_error_code_t UtilTask_vtblOnEnterTaskControlLoop(AManagedTask *_this)
{
  assert_param(_this);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *) _this;

  SYS_DEBUGF(SYS_DBG_LEVEL_DEFAULT, ("UTIL: start.\r\n"));

  /* Enable User button interrupt */
  if (p_obj->p_mx_ub_drv_cfg != NULL)
  {
    MX_GPIOParams_t *p_ub_params = (MX_GPIOParams_t *)p_obj->p_mx_ub_drv_cfg;
    HAL_NVIC_EnableIRQ(p_ub_params->irq_n);
  }

  /* Start the driver for Single Wire communication */
  IDrvStart(p_obj->p_bc_tim_chg_driver);

#ifdef ENABLE_THREADX_DBG_PIN
  p_obj->super.m_xTaskHandle.pxTaskTag = UTIL_TASK_CFG_TAG;
#endif

  return res;
}

/* AManagedTaskEx virtual functions definition */
/***********************************************/

sys_error_code_t UtilTask_vtblForceExecuteStep(AManagedTaskEx *_this, EPowerMode active_power_mode)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *) _this;

  struct utilMessage_t msg = { .msgId = APP_REPORT_ID_FORCE_STEP };

  if (active_power_mode == E_POWER_MODE_STATE1)
  {
    if (TX_SUCCESS != tx_queue_front_send(&p_obj->in_queue, &msg, AMT_MS_TO_TICKS(100)))
    {
      res = SYS_TASK_QUEUE_FULL_ERROR_CODE;
    }
  }
  else if (active_power_mode == E_POWER_MODE_SENSORS_ACTIVE)
  {
    tx_thread_wait_abort(&_this->m_xTaskHandle);
  }
  else
  {
    tx_thread_resume(&_this->m_xTaskHandle);
  }

  return res;
}

sys_error_code_t UtilTask_vtblOnEnterPowerMode(AManagedTaskEx *_this, const EPowerMode active_power_mode,
                                               const EPowerMode new_power_mode)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  /*  UtilTask_t *p_obj = (UtilTask_t*)_this; */

  return res;
}

/* Private function definition */
/*******************************/

static sys_error_code_t UtilTaskExecuteStepState1(AManagedTask *_this)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *) _this;
  static uint8_t led_count_state1 = 0;

  struct utilMessage_t msg =
  {
    0
  };

  AMTExSetInactiveState((AManagedTaskEx *) _this, TRUE);

  if (TX_SUCCESS == tx_queue_receive(&p_obj->in_queue, &msg, TX_WAIT_FOREVER))
  {
    AMTExSetInactiveState((AManagedTaskEx *) _this, FALSE);

    if (msg.msgId == APP_REPORT_ID_FORCE_STEP)
    {
      __NOP();
    }
    else if (msg.msgId == APP_MESSAGE_ID_UTIL)
    {
      if (msg.nCmdID == UTIL_CMD_ID_BUTTON_EVT)
      {
        /* turn-off the battery charger */
        res = BCPPowerOff(&p_obj->bc_protocol);
      }
      else if (msg.nCmdID == UTIL_CMD_ID_DATALOG_LED)
      {
        led_count_state1++;
        if (led_count_state1 == 4)
        {
          led_count_state1 = 0;
          if (p_obj->p_mx_led1_drv_cfg != NULL)
          {
            MX_GPIOParams_t *p_ld1_params = (MX_GPIOParams_t *)p_obj->p_mx_led1_drv_cfg;
            HAL_GPIO_TogglePin(p_ld1_params->port, p_ld1_params->pin);
          }
        }
      }
    }
  }

  return res;
}


static sys_error_code_t UtilTaskExecuteStepSensorsActive(AManagedTask *_this)
{
  assert_param(_this != NULL);
  sys_error_code_t res = SYS_NO_ERROR_CODE;
  UtilTask_t *p_obj = (UtilTask_t *) _this;

  struct utilMessage_t msg =
  {
    0
  };

  AMTExSetInactiveState((AManagedTaskEx *) _this, TRUE);

  if (TX_SUCCESS == tx_queue_receive(&p_obj->in_queue, &msg, TX_WAIT_FOREVER))
  {
    AMTExSetInactiveState((AManagedTaskEx *) _this, FALSE);
    if (msg.msgId == APP_MESSAGE_ID_UTIL)
    {
      if (msg.nCmdID == UTIL_CMD_ID_DATALOG_LED)
      {
        if (p_obj->p_mx_led1_drv_cfg != NULL)
        {
          MX_GPIOParams_t *p_ld1_params = (MX_GPIOParams_t *)p_obj->p_mx_led1_drv_cfg;
          HAL_GPIO_TogglePin(p_ld1_params->port, p_ld1_params->pin);
        }
      }
    }
  }

  return res;
}


static VOID UtilTaskSwTimerCallbackUserLed(ULONG timer)
{
  UtilTask_t *p_obj = (UtilTask_t *) &sTaskObj;

  struct utilMessage_t msg =
  {
    .msgId = APP_MESSAGE_ID_UTIL,
    .nCmdID = UTIL_CMD_ID_DATALOG_LED
  };

  if (TX_SUCCESS != tx_queue_send(&sTaskObj.in_queue, &msg, TX_NO_WAIT))
  {
    // unable to send the report. Signal the error
    sys_error_handler();
  }

  bool sd_detected;
  log_controller_get_sd_mounted(&sd_detected);

  if (sd_detected)
  {
    if (p_obj->p_mx_led2_drv_cfg != NULL)
    {
      MX_GPIOParams_t *p_ld2_params = (MX_GPIOParams_t *)p_obj->p_mx_led2_drv_cfg;
      HAL_GPIO_WritePin(p_ld2_params->port, p_ld2_params->pin, GPIO_PIN_SET);
    }
  }
  else
  {
    if (p_obj->p_mx_led2_drv_cfg != NULL)
    {
      MX_GPIOParams_t *p_ld2_params = (MX_GPIOParams_t *)p_obj->p_mx_led2_drv_cfg;
      HAL_GPIO_WritePin(p_ld2_params->port, p_ld2_params->pin, GPIO_PIN_RESET);
    }
  }
}

/**
  * @brief  Initialize the Power button PWR.
  * @param  None
  * @retval None
  */
static void PB_PWR_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct;

  __HAL_RCC_GPIOD_CLK_ENABLE();

  /* Configure Button pin as input with External interrupt */
  GPIO_InitStruct.Pin = POWER_BUTTON_Pin;
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;

  HAL_GPIO_Init(POWER_BUTTON_GPIO_Port, &GPIO_InitStruct);

  /* Enable and set Button EXTI Interrupt to the lowest priority */
  HAL_NVIC_SetPriority((IRQn_Type) POWER_BUTTON_EXTI_IRQn, 3, 0x00);
  HAL_NVIC_EnableIRQ((IRQn_Type) POWER_BUTTON_EXTI_IRQn);
}

/**
  * @brief Random function initialization.
  *        Initialize srand() using a random number generated by RNG peripheral
  * @param None
  * @retval None
  */
static void RND_Init(void)
{
  RNG_HandleTypeDef RngHandle;

  /* Used for storing Random 32bit Number */
  uint32_t aRandom32bit;

  /* Configure the RNG peripheral */
  RngHandle.Instance = RNG;
  RngHandle.Init.ClockErrorDetection = RNG_CED_DISABLE;

  /* DeInitialize the RNG peripheral */
  if (HAL_RNG_DeInit(&RngHandle) != HAL_OK)
  {
    /* DeInitialization Error */
    sys_error_handler();
  }

  /* Initialize the RNG peripheral */
  if (HAL_RNG_Init(&RngHandle) != HAL_OK)
  {
    /* Initialization Error */
    sys_error_handler();
  }

  if (HAL_RNG_GenerateRandomNumber(&RngHandle, &aRandom32bit) != HAL_OK)
  {
    /* Random number generation error */
    sys_error_handler();
  }

  HAL_RNG_DeInit(&RngHandle);

  /* Initialize srand() using the random number generated by RNG peripheral */
  srand(aRandom32bit);
}


/* CubeMX integration */
/**********************/


void Util_PWR_EXTI_Callback(uint16_t nPin)
{
  /* anti debounch */
  static uint32_t t_start = 0;
  if (HAL_GetTick() - t_start > 1000)
  {
    if (nPin == POWER_BUTTON_Pin)
    {
      /* turn on the LED 1 */
      if (sTaskObj.p_mx_led1_drv_cfg != NULL)
      {
        MX_GPIOParams_t *p_ld1_params = (MX_GPIOParams_t *)sTaskObj.p_mx_led1_drv_cfg;
        HAL_GPIO_WritePin(p_ld1_params->port, p_ld1_params->pin, GPIO_PIN_SET);
      }

      struct utilMessage_t msg =
      {
        .msgId = APP_MESSAGE_ID_UTIL,
        .nCmdID = UTIL_CMD_ID_BUTTON_EVT
      };

      if (TX_SUCCESS != tx_queue_send(&sTaskObj.in_queue, &msg, TX_NO_WAIT))
      {
        // unable to send the report. Signal the error
        sys_error_handler();
      }
    }
  }
  t_start = HAL_GetTick();
}

/**
  * @brief  Enable Disable the jump to second flash bank and reboot board
  * @param  None
  * @retval None
  */
void SwitchBank(void)
{
  FLASH_OBProgramInitTypeDef    OBInit;
  /* Set BFB2 bit to enable boot from Flash Bank2 */
  /* Allow Access to Flash control registers and user Flash */
  HAL_FLASH_Unlock();

  /* Clear OPTVERR bit set on virgin samples */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);

  /* Allow Access to option bytes sector */
  HAL_FLASH_OB_Unlock();

  /* Get the Dual boot configuration status */
  HAL_FLASHEx_OBGetConfig(&OBInit);

  /* Enable/Disable dual boot feature */
  OBInit.OptionType = OPTIONBYTE_USER;
  OBInit.USERType   = OB_USER_BFB2;

  if (((OBInit.USERConfig) & (OB_BFB2_ENABLE)) == OB_BFB2_ENABLE)
  {
    OBInit.USERConfig = OB_BFB2_DISABLE;
    SYS_DEBUGF(SYS_DBG_LEVEL_VERBOSE, ("->Disable DualBoot\r\n"));
  }
  else
  {
    OBInit.USERConfig = OB_BFB2_ENABLE;
    SYS_DEBUGF(SYS_DBG_LEVEL_VERBOSE, ("->Enable DualBoot\r\n"));
  }

  if (HAL_FLASHEx_OBProgram(&OBInit) != HAL_OK)
  {
    /*
    Error occurred while setting option bytes configuration.
    User can add here some code to deal with this error.
    To know the code error, user can call function 'HAL_FLASH_GetError()'
    */
    //    Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
  }

  /* Start the Option Bytes programming process */
  if (HAL_FLASH_OB_Launch() != HAL_OK)
  {
    /*
    Error occurred while reloading option bytes configuration.
    User can add here some code to deal with this error.
    To know the code error, user can call function 'HAL_FLASH_GetError()'
    */
    //    Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
  }
  HAL_FLASH_OB_Lock();
  HAL_FLASH_Lock();
}

